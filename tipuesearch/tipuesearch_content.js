var tipuesearch = {"pages":[{"title":" MCTC-library ","text":"MCTC-library Common tool chain for working with molecular structure data in various applications.\nThis library provides a unified way to perform operations on molecular structure data, like reading and writing to common geometry file formats. Input and Output Standard environment Light testing framework Getting Started Meson Fortran Package Manager (fpm) Input and Output The IO module ( mctc_io ) provides access to a common type to declare molecular structure data ( structure_type ).\nAlso, reader routines ( mctc_io_read ) to obtain structure_type objects from input files are available.\nTo write a structure_type object a set of writer routines are available as well ( mctc_io_write ). Standard environment The tool chain library provides an environment module ( mctc_env ) to allow the usage of common constants across different users.\nFor a minimal error handling the error_type is available and should be passed as allocatable type to the library procedures.\nThe allocation status of the error_type is used to determine failed executions and the respective error message is stored transparently in the error_type . Light testing framework Additionally, the environment module provides a testsuite implementation to setup a slim and light testing framework in dependent applications.\nThe test framework can be easily setup by the mctc_env_testing module. Getting Started Meson Create a new meson project and include mctc-lib either as git-submodule in your subprojects directory or create a wrap file to fetch it from upstream: [wrap-git] directory = mctc-lib url = https://github.com/grimme-lab/mctc-lib revision = head To load the project the necessary boilerplate code for subprojects is just mctc_prj = subproject ( 'mctc-lib' , version : '>=0.1' , default_options : [ 'default_library=static' , ], ) mctc_dep = mctc_prj . get_variable ( 'mctc_dep' ) Now you can add mctc_dep to your dependencies and access the public API by the mctc module. We recommend to set the default library type of mctc-lib to static when linking your applications or library against it.\nNote for library type both and shared mctc-lib will install itself along with your project. For more fine-tuned control you can access: the library target with mctc_lib the private include dir of this target, containing the Fortran module files, with mctc_inc the license files of mctc-lib with mctc_lic If you are linking your application statically against mctc-lib and still want to distribute the license files of mctc-lib (thank you), just use install_data ( mctc_prj . get_variable ( 'mctc_lic' ), install_dir : get_option ( 'datadir' ) / 'licenses' / meson . project_name () / 'mctc-lib' , ) Fortran Package Manager (fpm) This project supports fpm as build system as well.\nJust add it to the dependencies in your fpm.toml file: [dependencies] [dependencies.mctc-lib] git = \"https://github.com/grimme-lab/mctc-lib\" Developer Info Grimme group, Bonn","tags":"home","loc":"index.html"},{"title":"testsuite_type – MCTC-library ","text":"type, public :: testsuite_type Collection of unit tests Components Type Visibility Attributes Name Initial procedure( collect_interface ), public, pointer, nopass :: collect => null() Entry point of the test character(len=:), public, allocatable :: name Name of the testsuite Source Code type :: testsuite_type !> Name of the testsuite character ( len = :), allocatable :: name !> Entry point of the test procedure ( collect_interface ), pointer , nopass :: collect => null () end type testsuite_type","tags":"","loc":"type/testsuite_type.html"},{"title":"unittest_type – MCTC-library ","text":"type, public :: unittest_type Declaration of a unit test Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name Name of the test logical, public :: should_fail = .false. Whether test is supposed to fail procedure( test_interface ), public, pointer, nopass :: test => null() Entry point of the test Source Code type :: unittest_type !> Name of the test character ( len = :), allocatable :: name !> Entry point of the test procedure ( test_interface ), pointer , nopass :: test => null () !> Whether test is supposed to fail logical :: should_fail = . false . end type unittest_type","tags":"","loc":"type/unittest_type.html"},{"title":"pdb_data – MCTC-library ","text":"type, public :: pdb_data Atomic pdb data type. keeps information from PDB input that is currently not used by the\ncaller program (like residues or chains) but is needed to write\nthe PDB output eventually ATOM   2461  HA3 GLY A 153     -10.977  -7.661   2.011  1.00  0.00           H\nTER    2462      GLY A 153\na6----i5---xa4--aa3-xai4--axxxf8.3----f8.3----f8.3----f6.2--f6.2--xxxxxxa4--a2a2\nHETATM 2463  CHA HEM A 154       9.596 -13.100  10.368  1.00  0.00           C Components Type Visibility Attributes Name Initial character(len=1), public :: chains = ' ' integer, public :: charge = 0 character(len=1), public :: code = ' ' logical, public :: het = .false. character(len=1), public :: loc = ' ' character(len=4), public :: name = ' ' character(len=3), public :: residue = ' ' integer, public :: residue_number = 0 character(len=4), public :: segid = ' ' Source Code type :: pdb_data logical :: het = . false . integer :: charge = 0 integer :: residue_number = 0 character ( len = 4 ) :: name = ' ' character ( len = 1 ) :: loc = ' ' character ( len = 3 ) :: residue = ' ' character ( len = 1 ) :: chains = ' ' character ( len = 1 ) :: code = ' ' character ( len = 4 ) :: segid = ' ' end type pdb_data","tags":"","loc":"type/pdb_data.html"},{"title":"sdf_data – MCTC-library ","text":"type, public :: sdf_data SDF atomic data. We only support some entries, the rest is simply dropped.\nthe format is: ddcccssshhhbbbvvvHHHrrriiimmmnnneee Components Type Visibility Attributes Name Initial integer, public :: charge = 0 c field integer, public :: hydrogens = 0 h field integer, public :: isotope = 0 d field integer, public :: valence = 0 v field Source Code type :: sdf_data integer :: isotope = 0 !< d field integer :: charge = 0 !< c field integer :: hydrogens = 0 !< h field integer :: valence = 0 !< v field end type sdf_data","tags":"","loc":"type/sdf_data.html"},{"title":"structure_info – MCTC-library ","text":"type, public :: structure_info structure input info contains informations from different input file formats Components Type Visibility Attributes Name Initial logical, public :: angs_coord = .false. Unit of the atomic coordinates should be in Angstrom if possible logical, public :: angs_lattice = .false. Unit of the lattice vectors should be in Angstrom if possible logical, public :: cartesian = .true. Periodic coordinates should use preferably cartesian coordinates logical, public :: lattice = .true. Lattice information should use preferably lattice vectors logical, public :: missing_hydrogen = .false. SDF hydrogen query present or PDB without hydrogen atoms found real(kind=wp), public :: scale = 1.0_wp Vasp coordinate scaling information logical, public :: selective = .false. Vasp selective dynamics keyword is present logical, public :: two_dimensional = .false. SDF 2D structure present Source Code type :: structure_info !> Vasp coordinate scaling information real ( wp ) :: scale = 1.0_wp !> Vasp selective dynamics keyword is present logical :: selective = . false . !> SDF 2D structure present logical :: two_dimensional = . false . !> SDF hydrogen query present or PDB without hydrogen atoms found logical :: missing_hydrogen = . false . !> Periodic coordinates should use preferably cartesian coordinates logical :: cartesian = . true . !> Lattice information should use preferably lattice vectors logical :: lattice = . true . !> Unit of the lattice vectors should be in Angstrom if possible logical :: angs_lattice = . false . !> Unit of the atomic coordinates should be in Angstrom if possible logical :: angs_coord = . false . end type structure_info","tags":"","loc":"type/structure_info.html"},{"title":"token_type – MCTC-library ","text":"type, public :: token_type Text token Components Type Visibility Attributes Name Initial integer, public :: first Begin of sequence integer, public :: last End of sequence Source Code type :: token_type !> Begin of sequence integer :: first !> End of sequence integer :: last end type token_type","tags":"","loc":"type/token_type.html"},{"title":"error_type – MCTC-library ","text":"type, public :: error_type Error message Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: message Payload of the error integer, public :: stat Error code Source Code type :: error_type !> Error code integer :: stat !> Payload of the error character ( len = :), allocatable :: message end type error_type","tags":"","loc":"type/error_type.html"},{"title":"structure_type – MCTC-library ","text":"type, public :: structure_type Structure representation Components Type Visibility Attributes Name Initial integer, public, allocatable :: bond (:,:) Bond indices real(kind=wp), public :: charge = 0.0_wp Total charge character(len=:), public, allocatable :: comment Comment, name or identifier for this structure integer, public, allocatable :: id (:) Species identifier type( structure_info ), public :: info = structure_info() Vendor specific structure annotations real(kind=wp), public, allocatable :: lattice (:,:) Lattice parameters integer, public :: nat = 0 Number of atoms integer, public :: nbd = 0 Number of bonds integer, public :: nid = 0 Number of unique species integer, public, allocatable :: num (:) Atomic number for each species type( pdb_data ), public, allocatable :: pdb (:) PDB atomic data annotations logical, public, allocatable :: periodic (:) Periodic directions type( sdf_data ), public, allocatable :: sdf (:) SDF atomic data annotations character(len=symbol_length), public, allocatable :: sym (:) Element symbol for each species integer, public :: uhf = 0 Number of unpaired electrons real(kind=wp), public, allocatable :: xyz (:,:) Cartesian coordinates, in Bohr Source Code type :: structure_type !> Number of atoms integer :: nat = 0 !> Number of unique species integer :: nid = 0 !> Number of bonds integer :: nbd = 0 !> Species identifier integer , allocatable :: id (:) !> Atomic number for each species integer , allocatable :: num (:) !> Element symbol for each species character ( len = symbol_length ), allocatable :: sym (:) !> Cartesian coordinates, in Bohr real ( wp ), allocatable :: xyz (:, :) !> Number of unpaired electrons integer :: uhf = 0 !> Total charge real ( wp ) :: charge = 0.0_wp !> Lattice parameters real ( wp ), allocatable :: lattice (:, :) !> Periodic directions logical , allocatable :: periodic (:) !> Bond indices integer , allocatable :: bond (:, :) !> Comment, name or identifier for this structure character ( len = :), allocatable :: comment !> Vendor specific structure annotations type ( structure_info ) :: info = structure_info () !> SDF atomic data annotations type ( sdf_data ), allocatable :: sdf (:) !> PDB atomic data annotations type ( pdb_data ), allocatable :: pdb (:) end type structure_type","tags":"","loc":"type/structure_type.html"},{"title":"collect_interface – MCTC-library","text":"interface public  subroutine collect_interface(testsuite) Arguments Type Intent Optional Attributes Name type( unittest_type ), intent(out), allocatable :: testsuite (:) Collection of tests Description Collect all tests","tags":"","loc":"interface/collect_interface.html"},{"title":"test_interface – MCTC-library","text":"interface public  subroutine test_interface(error) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling Description Entry point for tests","tags":"","loc":"interface/test_interface.html"},{"title":"structure_reader – MCTC-library","text":"interface public  subroutine structure_reader(self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Description Read molecular structure data from formatted unit","tags":"","loc":"interface/structure_reader.html"},{"title":"new_testsuite – MCTC-library","text":"public  function new_testsuite(name, collect) result(self) Register a new testsuite Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of the testsuite procedure( collect_interface ) :: collect Entry point to collect tests Return Value type( testsuite_type ) Newly registered testsuite Source Code function new_testsuite ( name , collect ) result ( self ) !> Name of the testsuite character ( len =* ), intent ( in ) :: name !> Entry point to collect tests procedure ( collect_interface ) :: collect !> Newly registered testsuite type ( testsuite_type ) :: self self % name = name self % collect => collect end function new_testsuite","tags":"","loc":"proc/new_testsuite.html"},{"title":"new_unittest – MCTC-library","text":"public  function new_unittest(name, test, should_fail) result(self) Register a new unit test Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of the test procedure( test_interface ) :: test Entry point for the test logical, intent(in), optional :: should_fail Whether test is supposed to error or not Return Value type( unittest_type ) Newly registered test Source Code function new_unittest ( name , test , should_fail ) result ( self ) !> Name of the test character ( len =* ), intent ( in ) :: name !> Entry point for the test procedure ( test_interface ) :: test !> Whether test is supposed to error or not logical , intent ( in ), optional :: should_fail !> Newly registered test type ( unittest_type ) :: self self % name = name self % test => test if ( present ( should_fail )) self % should_fail = should_fail end function new_unittest","tags":"","loc":"proc/new_unittest.html"},{"title":"select_suite – MCTC-library","text":"public  function select_suite(suites, name) result(pos) Select a test suite from all available suites Arguments Type Intent Optional Attributes Name type( testsuite_type ) :: suites (:) Available test suites character(len=*), intent(in) :: name Name identifying the test suite Return Value integer Selected test suite Source Code function select_suite ( suites , name ) result ( pos ) !> Name identifying the test suite character ( len =* ), intent ( in ) :: name !> Available test suites type ( testsuite_type ) :: suites (:) !> Selected test suite integer :: pos integer :: it pos = 0 do it = 1 , size ( suites ) if ( name == suites ( it )% name ) then pos = it exit end if end do end function select_suite","tags":"","loc":"proc/select_suite.html"},{"title":"select_test – MCTC-library","text":"public  function select_test(tests, name) result(pos) Select a unit test from all available tests Arguments Type Intent Optional Attributes Name type( unittest_type ) :: tests (:) Available unit tests character(len=*), intent(in) :: name Name identifying the test suite Return Value integer Selected test suite Source Code function select_test ( tests , name ) result ( pos ) !> Name identifying the test suite character ( len =* ), intent ( in ) :: name !> Available unit tests type ( unittest_type ) :: tests (:) !> Selected test suite integer :: pos integer :: it pos = 0 do it = 1 , size ( tests ) if ( name == tests ( it )% name ) then pos = it exit end if end do end function select_test","tags":"","loc":"proc/select_test.html"},{"title":"run_selected – MCTC-library","text":"public  subroutine run_selected(collect, name, unit, stat) Driver for selective testing Arguments Type Intent Optional Attributes Name procedure( collect_interface ) :: collect Collect tests character(len=*), intent(in) :: name Name of the selected test integer, intent(in) :: unit Unit for IO integer, intent(inout) :: stat Number of failed tests Source Code subroutine run_selected ( collect , name , unit , stat ) !> Collect tests procedure ( collect_interface ) :: collect !> Name of the selected test character ( len =* ), intent ( in ) :: name !> Unit for IO integer , intent ( in ) :: unit !> Number of failed tests integer , intent ( inout ) :: stat type ( unittest_type ), allocatable :: testsuite (:) integer :: ii call collect ( testsuite ) ii = select_test ( testsuite , name ) if ( ii > 0 . and . ii <= size ( testsuite )) then call run_unittest ( testsuite ( ii ), unit , stat ) else write ( unit , fmt ) \"Available tests:\" do ii = 1 , size ( testsuite ) write ( unit , fmt ) \"-\" , testsuite ( ii )% name end do stat = - huge ( ii ) end if end subroutine run_selected","tags":"","loc":"proc/run_selected.html"},{"title":"run_testsuite – MCTC-library","text":"public  subroutine run_testsuite(collect, unit, stat, parallel) Driver for testsuite Arguments Type Intent Optional Attributes Name procedure( collect_interface ) :: collect Collect tests integer, intent(in) :: unit Unit for IO integer, intent(inout) :: stat Number of failed tests logical, intent(in), optional :: parallel Run tests in parallel Source Code subroutine run_testsuite ( collect , unit , stat , parallel ) !> Collect tests procedure ( collect_interface ) :: collect !> Unit for IO integer , intent ( in ) :: unit !> Number of failed tests integer , intent ( inout ) :: stat !> Run tests in parallel logical , intent ( in ), optional :: parallel type ( unittest_type ), allocatable :: testsuite (:) logical :: parallelize integer :: ii parallelize = . false . if ( present ( parallel )) parallelize = parallel call collect ( testsuite ) !$omp parallel do shared(testsuite, unit) reduction(+:stat) if(parallelize) do ii = 1 , size ( testsuite ) !$omp critical(mctc_env_testsuite) write ( unit , '(1x, 3(1x, a), 1x, \"(\", i0, \"/\", i0, \")\")' ) & & \"Starting\" , testsuite ( ii )% name , \"...\" , ii , size ( testsuite ) !$omp end critical(mctc_env_testsuite) call run_unittest ( testsuite ( ii ), unit , stat ) end do end subroutine run_testsuite","tags":"","loc":"proc/run_testsuite.html"},{"title":"test_failed – MCTC-library","text":"public  subroutine test_failed(error, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling character(len=*), intent(in) :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message Source Code subroutine test_failed ( error , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> A detailed message describing the error character ( len =* ), intent ( in ) :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more allocate ( error ) error % stat = mctc_stat % fatal if ( present ( more )) then error % message = message // new_line ( 'a' ) // more else error % message = message end if end subroutine test_failed","tags":"","loc":"proc/test_failed.html"},{"title":"check – MCTC-library","text":"public interface check Module Procedures private  subroutine check_stat(error, stat, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer, intent(in) :: stat Status of operation character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private  subroutine check_logical(error, expression, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling logical, intent(in) :: expression Result of logical operator character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private  subroutine check_float_sp(error, actual, expected, message, more, thr, rel) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling real(kind=sp), intent(in) :: actual Found floating point value real(kind=sp), intent(in) :: expected Expected floating point value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message real(kind=sp), intent(in), optional :: thr Allowed threshold for matching floating point values logical, intent(in), optional :: rel Check for relative errors instead private  subroutine check_float_dp(error, actual, expected, message, more, thr, rel) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling real(kind=dp), intent(in) :: actual Found floating point value real(kind=dp), intent(in) :: expected Expected floating point value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message real(kind=dp), intent(in), optional :: thr Allowed threshold for matching floating point values logical, intent(in), optional :: rel Check for relative errors instead private  subroutine check_int_i1(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i1), intent(in) :: actual Found integer value integer(kind=i1), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private  subroutine check_int_i2(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i2), intent(in) :: actual Found integer value integer(kind=i2), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private  subroutine check_int_i4(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i4), intent(in) :: actual Found integer value integer(kind=i4), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private  subroutine check_int_i8(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i8), intent(in) :: actual Found integer value integer(kind=i8), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private  subroutine check_bool(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling logical, intent(in) :: actual Found boolean value logical, intent(in) :: expected Expected boolean value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private  subroutine check_string(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling character(len=*), intent(in) :: actual Found boolean value character(len=*), intent(in) :: expected Expected boolean value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message","tags":"","loc":"interface/check.html"},{"title":"resize – MCTC-library","text":"public interface resize Module Procedures private  subroutine resize_pdb_data(var, n) Arguments Type Intent Optional Attributes Name type( pdb_data ), intent(inout), allocatable :: var (:) integer, intent(in), optional :: n","tags":"","loc":"interface/resize.html"},{"title":"write_gaussian_external – MCTC-library","text":"public  subroutine write_gaussian_external(mol, unit) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(in) :: mol integer, intent(in) :: unit Source Code subroutine write_gaussian_external ( mol , unit ) type ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer :: iat write ( unit , '(4i10)' ) mol % nat , 1 , nint ( mol % charge ), mol % uhf do iat = 1 , mol % nat write ( unit , '(i10,4f20.12)' ) mol % num ( mol % id ( iat )), mol % xyz (:, iat ), 0.0_wp end do end subroutine write_gaussian_external","tags":"","loc":"proc/write_gaussian_external.html"},{"title":"filename – MCTC-library","text":"public  function filename(unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Return Value character(len=:), allocatable","tags":"","loc":"proc/filename.html"},{"title":"to_string – MCTC-library","text":"public pure function to_string(val, width) result(string) Represent an integer as character sequence. Arguments Type Intent Optional Attributes Name integer, intent(in) :: val integer, intent(in), optional :: width Return Value character(len=:), allocatable Source Code pure function to_string ( val , width ) result ( string ) integer , intent ( in ) :: val integer , intent ( in ), optional :: width character ( len = :), allocatable :: string integer , parameter :: buffer_len = range ( val ) + 2 character ( len = buffer_len ) :: buffer integer :: pos integer :: n character ( len = 1 ), parameter :: numbers ( 0 : 9 ) = & [ \"0\" , \"1\" , \"2\" , \"3\" , \"4\" , \"5\" , \"6\" , \"7\" , \"8\" , \"9\" ] if ( val == 0 ) then if ( present ( width )) then string = repeat ( \" \" , width - 1 ) // numbers ( 0 ) else string = numbers ( 0 ) end if return end if n = abs ( val ) buffer = \"\" pos = buffer_len + 1 do while ( n > 0 ) pos = pos - 1 buffer ( pos : pos ) = numbers ( mod ( n , 10 )) n = n / 10 end do if ( val < 0 ) then pos = pos - 1 buffer ( pos : pos ) = '-' end if if ( present ( width )) then string = repeat ( \" \" , max ( width - ( buffer_len + 1 - pos ), 0 )) // buffer ( pos :) else string = buffer ( pos :) end if end function to_string","tags":"","loc":"proc/to_string.html"},{"title":"getline – MCTC-library","text":"public  subroutine getline(unit, line, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Formatted IO unit character(len=:), intent(out), allocatable :: line Line to read integer, intent(out) :: iostat Status of operation character(len=:), optional, allocatable :: iomsg Error message Source Code subroutine getline ( unit , line , iostat , iomsg ) !> Formatted IO unit integer , intent ( in ) :: unit !> Line to read character ( len = :), allocatable , intent ( out ) :: line !> Status of operation integer , intent ( out ) :: iostat !> Error message character ( len = :), allocatable , optional :: iomsg integer , parameter :: bufsize = 512 character ( len = bufsize ) :: buffer character ( len = bufsize ) :: msg integer :: size integer :: stat allocate ( character ( len = 0 ) :: line ) do read ( unit , '(a)' , advance = 'no' , iostat = stat , iomsg = msg , size = size ) & & buffer if ( stat > 0 ) exit line = line // buffer (: size ) if ( stat < 0 ) then if ( is_iostat_eor ( stat )) then stat = 0 end if exit end if end do if ( stat /= 0 ) then if ( present ( iomsg )) iomsg = trim ( msg ) end if iostat = stat end subroutine getline","tags":"","loc":"proc/getline.html"},{"title":"io2_error – MCTC-library","text":"public  subroutine io2_error(error, message, source1, source2, token1, token2, filename, line1, line2, label1, label2) Create new IO error Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handler character(len=*), intent(in) :: message Main error message character(len=*), intent(in) :: source1 String representing the offending input character(len=*), intent(in) :: source2 String representing the offending input type( token_type ), intent(in) :: token1 Last processed token type( token_type ), intent(in) :: token2 Last processed token character(len=*), intent(in), optional :: filename Name of the input file integer, intent(in), optional :: line1 Line number integer, intent(in), optional :: line2 Line number character(len=*), intent(in), optional :: label1 Label of the offending statement character(len=*), intent(in), optional :: label2 Label of the offending statement Source Code subroutine io2_error ( error , message , source1 , source2 , token1 , token2 , filename , & & line1 , line2 , label1 , label2 ) !> Error handler type ( error_type ), allocatable , intent ( out ) :: error !> Main error message character ( len =* ), intent ( in ) :: message !> String representing the offending input character ( len =* ), intent ( in ) :: source1 , source2 !> Last processed token type ( token_type ), intent ( in ) :: token1 , token2 !> Name of the input file character ( len =* ), intent ( in ), optional :: filename !> Line number integer , intent ( in ), optional :: line1 , line2 !> Label of the offending statement character ( len =* ), intent ( in ), optional :: label1 , label2 character ( len =* ), parameter :: nl = new_line ( 'a' ) integer :: offset , lnum1 , lnum2 , width1 , width2 character ( len = :), allocatable :: string lnum1 = 1 lnum2 = 1 if ( present ( line1 )) lnum1 = line1 if ( present ( line2 )) lnum2 = line2 offset = integer_width ( max ( lnum1 , lnum2 )) width1 = token1 % last - token1 % first + 1 width2 = token2 % last - token2 % first + 1 string = \"Error: \" // message if ( present ( filename )) then string = string // nl // & repeat ( \" \" , offset ) // \"--> \" // filename string = string // \":\" // to_string ( lnum2 ) if ( token2 % first > 0 . and . token2 % last >= token2 % first ) then string = string // & \":\" // to_string ( token2 % first ) if ( token2 % last > token2 % first ) string = string // \"-\" // to_string ( token2 % last ) end if end if string = string // nl // & repeat ( \" \" , offset + 1 ) // \"|\" // nl // & to_string ( lnum1 , offset ) // \" | \" // source1 // nl // & repeat ( \" \" , offset + 1 ) // \"|\" // repeat ( \" \" , token1 % first ) // repeat ( \"-\" , width1 ) if ( present ( label1 )) then string = string // \" \" // label1 end if string = string // nl // & repeat ( \" \" , offset + 1 ) // \":\" // nl // & to_string ( lnum2 ) // \" | \" // source2 // nl // & repeat ( \" \" , offset + 1 ) // \"|\" // repeat ( \" \" , token2 % first ) // repeat ( \"&#94;\" , width2 ) if ( present ( label2 )) then string = string // \" \" // label2 end if string = string // nl // & repeat ( \" \" , offset + 1 ) // \"|\" call fatal_error ( error , string ) end subroutine io2_error","tags":"","loc":"proc/io2_error.html"},{"title":"io_error – MCTC-library","text":"public  subroutine io_error(error, message, source, token, filename, line, label) Create new IO error Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handler character(len=*), intent(in) :: message Main error message character(len=*), intent(in) :: source String representing the offending input type( token_type ), intent(in) :: token Last processed token character(len=*), intent(in), optional :: filename Name of the input file integer, intent(in), optional :: line Line number character(len=*), intent(in), optional :: label Label of the offending statement Source Code subroutine io_error ( error , message , source , token , filename , line , label ) !> Error handler type ( error_type ), allocatable , intent ( out ) :: error !> Main error message character ( len =* ), intent ( in ) :: message !> String representing the offending input character ( len =* ), intent ( in ) :: source !> Last processed token type ( token_type ), intent ( in ) :: token !> Name of the input file character ( len =* ), intent ( in ), optional :: filename !> Line number integer , intent ( in ), optional :: line !> Label of the offending statement character ( len =* ), intent ( in ), optional :: label character ( len =* ), parameter :: nl = new_line ( 'a' ) integer :: offset , lnum , width character ( len = :), allocatable :: string lnum = 1 if ( present ( line )) lnum = line offset = integer_width ( lnum ) width = token % last - token % first + 1 string = \"Error: \" // message if ( present ( filename )) then string = string // nl // & repeat ( \" \" , offset ) // \"--> \" // filename string = string // \":\" // to_string ( lnum ) if ( token % first > 0 . and . token % last >= token % first ) then string = string // & \":\" // to_string ( token % first ) if ( token % last > token % first ) string = string // \"-\" // to_string ( token % last ) end if end if string = string // nl // & repeat ( \" \" , offset + 1 ) // \"|\" // nl // & to_string ( lnum ) // \" | \" // source // nl // & repeat ( \" \" , offset + 1 ) // \"|\" // repeat ( \" \" , token % first ) // repeat ( \"&#94;\" , width ) if ( present ( label )) then string = string // \" \" // label end if string = string // nl // & repeat ( \" \" , offset + 1 ) // \"|\" call fatal_error ( error , string ) end subroutine io_error","tags":"","loc":"proc/io_error.html"},{"title":"next_line – MCTC-library","text":"public  subroutine next_line(unit, line, pos, lnum, iostat, iomsg) Convenience function to read a line and update associated descriptors Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Formatted IO unit character(len=:), intent(out), allocatable :: line Line to read integer, intent(out) :: pos Current position in line integer, intent(inout) :: lnum Current line number integer, intent(out) :: iostat Status of operation character(len=:), optional, allocatable :: iomsg Error message Source Code subroutine next_line ( unit , line , pos , lnum , iostat , iomsg ) !> Formatted IO unit integer , intent ( in ) :: unit !> Line to read character ( len = :), allocatable , intent ( out ) :: line !> Current position in line integer , intent ( out ) :: pos !> Current line number integer , intent ( inout ) :: lnum !> Status of operation integer , intent ( out ) :: iostat !> Error message character ( len = :), allocatable , optional :: iomsg pos = 0 call getline ( unit , line , iostat , iomsg ) if ( iostat == 0 ) lnum = lnum + 1 end subroutine next_line","tags":"","loc":"proc/next_line.html"},{"title":"next_token – MCTC-library","text":"public  subroutine next_token(string, pos, token) Advance pointer to next text token Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to check integer, intent(inout) :: pos Current position in string type( token_type ), intent(out) :: token Token found Source Code subroutine next_token ( string , pos , token ) !> String to check character ( len =* ), intent ( in ) :: string !> Current position in string integer , intent ( inout ) :: pos !> Token found type ( token_type ), intent ( out ) :: token integer :: start if ( pos >= len ( string )) then token = token_type ( len ( string ) + 1 , len ( string ) + 1 ) return end if do while ( pos < len ( string )) pos = pos + 1 select case ( string ( pos : pos )) case ( \" \" , achar ( 9 ), achar ( 10 ), achar ( 13 )) continue case default exit end select end do start = pos do while ( pos < len ( string )) pos = pos + 1 select case ( string ( pos : pos )) case ( \" \" , achar ( 9 ), achar ( 10 ), achar ( 13 )) pos = pos - 1 exit case default continue end select end do token = token_type ( start , pos ) end subroutine next_token","tags":"","loc":"proc/next_token.html"},{"title":"read_next_token – MCTC-library","text":"public interface read_next_token Module Procedures private  subroutine read_next_token_int(line, pos, token, val, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(inout) :: pos type( token_type ), intent(inout) :: token integer, intent(out) :: val integer, intent(out) :: iostat character(len=:), intent(out), optional, allocatable :: iomsg private  subroutine read_next_token_real(line, pos, token, val, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(inout) :: pos type( token_type ), intent(inout) :: token real(kind=wp), intent(out) :: val integer, intent(out) :: iostat character(len=:), intent(out), optional, allocatable :: iomsg","tags":"","loc":"interface/read_next_token.html"},{"title":"read_token – MCTC-library","text":"public interface read_token Module Procedures private  subroutine read_token_int(line, token, val, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line type( token_type ), intent(in) :: token integer, intent(out) :: val integer, intent(out) :: iostat character(len=:), intent(out), optional, allocatable :: iomsg private  subroutine read_token_real(line, token, val, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line type( token_type ), intent(in) :: token real(kind=wp), intent(out) :: val integer, intent(out) :: iostat character(len=:), intent(out), optional, allocatable :: iomsg","tags":"","loc":"interface/read_token.html"},{"title":"write_structure – MCTC-library","text":"public interface write_structure Module Procedures private  subroutine write_structure_to_file(self, file, error, format) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self Instance of the molecular structure data character(len=*), intent(in) :: file Name of the file to read type( error_type ), intent(out), allocatable :: error Error handling integer, intent(in), optional :: format File type format hint private  subroutine write_structure_to_unit(self, unit, ftype, error) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle integer, intent(in) :: ftype File type to read type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"interface/write_structure.html"},{"title":"write_qcschema – MCTC-library","text":"public  subroutine write_qcschema(mol, unit) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(in) :: mol integer, intent(in) :: unit Source Code subroutine write_qcschema ( mol , unit ) type ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit write ( unit , '(a)' ) json_string ( mol , \"  \" ) end subroutine write_qcschema","tags":"","loc":"proc/write_qcschema.html"},{"title":"read_qchem – MCTC-library","text":"public  subroutine read_qchem(mol, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: mol Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Source Code subroutine read_qchem ( mol , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: mol !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: stat , pos , lnum , izp , iat integer :: charge , multiplicity type ( token_type ) :: token character ( len = :), allocatable :: line real ( wp ) :: x , y , z character ( len = symbol_length ), allocatable :: sym (:) real ( wp ), allocatable :: xyz (:, :), abc (:, :), lattice (:, :) logical :: is_frac , periodic ( 3 ) iat = 0 lnum = 0 stat = 0 do while ( stat == 0 ) call next_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) exit call next_token ( line , pos , token ) if ( token % first > len ( line )) cycle if ( to_lower ( line ( token % first : token % last )) == '$molecule' ) exit end do if ( stat /= 0 ) then call io_error ( error , \"No atoms found\" , & & line , token_type ( 0 , 0 ), filename ( unit ), lnum + 1 , \"expected molecule block\" ) return end if call next_line ( unit , line , pos , lnum , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , charge , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , multiplicity , stat ) if ( stat /= 0 ) then call io_error ( error , \"Failed to read charge and multiplicity\" , & & line , token , filename ( unit ), lnum , \"expected integer value\" ) return end if allocate ( sym ( initial_size ), source = repeat ( ' ' , symbol_length )) allocate ( xyz ( 3 , initial_size ), source = 0.0_wp ) do while ( stat == 0 ) call next_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) exit call next_token ( line , pos , token ) if ( to_lower ( line ( token % first : token % last )) == '$end' ) exit if ( iat >= size ( sym )) call resize ( sym ) if ( iat >= size ( xyz , 2 )) call resize ( xyz ) iat = iat + 1 token % last = min ( token % last , token % first + symbol_length - 1 ) sym ( iat ) = line ( token % first : token % last ) if ( to_number ( sym ( iat )) == 0 ) then call read_token ( line , token , izp , stat ) sym ( iat ) = to_symbol ( izp ) end if if ( stat /= 0 ) then call io_error ( error , \"Cannot map symbol to atomic number\" , & & line , token , filename ( unit ), lnum , \"unknown element\" ) return end if call read_next_token ( line , pos , token , x , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , y , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , z , stat ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read coordinates\" , & & line , token , filename ( unit ), lnum , \"expected real value\" ) return end if xyz (:, iat ) = [ x , y , z ] * aatoau end do if ( stat /= 0 ) then call io_error ( error , \"Failed to read molecule block\" , & & line , token_type ( 0 , 0 ), filename ( unit ), lnum , \"unexpected end of input\" ) return end if call new ( mol , sym (: iat ), xyz , charge = real ( charge , wp ), uhf = multiplicity - 1 ) end subroutine read_qchem","tags":"","loc":"proc/read_qchem.html"},{"title":"fatal_error – MCTC-library","text":"public  subroutine fatal_error(error, message, stat) A fatal error is encountered Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Instance of the error character(len=*), intent(in), optional :: message A detailed message describing the error and (optionally) offering advice integer, intent(in), optional :: stat Overwrite of the error code Source Code subroutine fatal_error ( error , message , stat ) !> Instance of the error type ( error_type ), allocatable , intent ( out ) :: error !> A detailed message describing the error and (optionally) offering advice character ( len =* ), intent ( in ), optional :: message !> Overwrite of the error code integer , intent ( in ), optional :: stat allocate ( error ) if ( present ( stat )) then error % stat = stat else error % stat = mctc_stat % fatal end if if ( present ( message )) then error % message = message else error % message = \"Fatal error\" end if end subroutine fatal_error","tags":"","loc":"proc/fatal_error.html"},{"title":"resize – MCTC-library","text":"public interface resize Overloaded resize interface Module Procedures private pure subroutine resize_char(var, n) Reallocate list of characters Arguments Type Intent Optional Attributes Name character(len=*), intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size private pure subroutine resize_int(var, n) Reallocate list of integers Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size private pure subroutine resize_logical(var, n) Reallocate list of logicals Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size private pure subroutine resize_real(var, n) Reallocate list of reals Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size private pure subroutine resize_real_2d(var, n) Reallocate list of reals Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), allocatable :: var (:,:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size","tags":"","loc":"interface/resize~2.html"},{"title":"write_xyz – MCTC-library","text":"public  subroutine write_xyz(self, unit, comment_line) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: comment_line Source Code subroutine write_xyz ( self , unit , comment_line ) class ( structure_type ), intent ( in ) :: self integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: comment_line integer :: iat logical :: expo write ( unit , '(i0)' ) self % nat if ( present ( comment_line )) then write ( unit , '(a)' ) comment_line else if ( allocated ( self % comment )) then write ( unit , '(a)' ) self % comment else write ( unit , '(a)' ) end if end if expo = maxval ( self % xyz ) > 1.0e+5 . or . minval ( self % xyz ) < - 1.0e+5 if ( expo ) then do iat = 1 , self % nat write ( unit , '(a4, 1x, 3es24.14)' ) & & self % sym ( self % id ( iat )), self % xyz (:, iat ) * autoaa enddo else do iat = 1 , self % nat write ( unit , '(a4, 1x, 3f24.14)' ) & & self % sym ( self % id ( iat )), self % xyz (:, iat ) * autoaa enddo end if end subroutine write_xyz","tags":"","loc":"proc/write_xyz.html"},{"title":"read_qcschema – MCTC-library","text":"public  subroutine read_qcschema(self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Source Code subroutine read_qcschema ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error #if WITH_JSON type ( json_core ) :: json type ( json_value ), pointer :: root , val , child , array integer :: stat , schema_version , charge , multiplicity , ibond character ( len = :), allocatable :: input , line , message , schema_name , comment character ( len = symbol_length ), allocatable :: sym (:) integer , allocatable :: bond (:, :), list (:) real ( wp ), allocatable , target :: geo (:) real ( wp ), pointer :: xyz (:, :) stat = 0 input = \"\" do call getline ( unit , line , stat ) if ( stat /= 0 ) exit input = input // line end do call json % deserialize ( root , input ) if ( json % failed ()) then call json % check_for_errors ( error_msg = message ) call fatal_error ( error , message ) call json % destroy ( root ) return end if val => root call json % get ( val , \"schema_version\" , schema_version , default = 2 ) call json % get ( val , \"schema_name\" , schema_name , default = \"qcschema_molecule\" ) if ( schema_name /= \"qcschema_molecule\" . and . schema_name /= \"qcschema_input\" & & . or . json % failed ()) then call fatal_error ( error , \"Invalid schema name '\" // schema_name // \"'\" ) call json % destroy ( root ) return end if if ( schema_name == \"qcschema_input\" ) then select case ( schema_version ) case ( 1 ) call json % get ( val , \"molecule\" , child ) case default call fatal_error ( error , \"Unsupported schema version for 'qcschema_input'\" ) call json % destroy ( root ) return end select call json % get ( child , \"schema_version\" , schema_version , default = 2 ) call json % get ( child , \"schema_name\" , schema_name , default = \"qcschema_molecule\" ) if ( schema_name /= \"qcschema_molecule\" . or . json % failed ()) then call fatal_error ( error , \"Invalid schema name '\" // schema_name // \"'\" ) call json % destroy ( root ) return end if val => child end if select case ( schema_version ) case ( 1 ) call json % get ( val , \"molecule\" , child ) case ( 2 ) child => val case default call fatal_error ( error , \"Unsupported schema version for 'qcschema_molecule'\" ) call json % destroy ( root ) return end select call json % get ( child , \"symbols\" , sym ) if (. not . allocated ( sym ) . or . json % failed ()) then call fatal_error ( error , \"List of atomic symbols must be provided\" ) call json % destroy ( root ) return end if call json % get ( child , \"geometry\" , geo ) if (. not . allocated ( geo ) . or . json % failed ()) then call fatal_error ( error , \"Cartesian coordinates must be provided\" ) call json % destroy ( root ) return end if if ( 3 * size ( sym ) /= size ( geo )) then call fatal_error ( error , \"Number of symbols and coordinate triples must match\" ) call json % destroy ( root ) return end if call json % get ( child , \"comment\" , comment , default = \"\" ) call json % get ( child , \"molecular_charge\" , charge , default = 0 ) call json % get ( child , \"molecular_multiplicity\" , multiplicity , default = 1 ) if ( json % failed ()) then call json % check_for_errors ( error_msg = message ) call fatal_error ( error , message ) call json % destroy ( root ) return end if call json % get_child ( child , \"connectivity\" , array ) if ( associated ( array )) then allocate ( bond ( 3 , json % count ( array ))) do ibond = 1 , size ( bond , 2 ) call json % get_child ( array , ibond , child ) call json % get ( child , \"\" , list ) if ( allocated ( list )) then bond (:, ibond ) = [ list ( 1 ) + 1 , list ( 2 ) + 1 , list ( 3 )] end if end do if ( json % failed ()) then call json % check_for_errors ( error_msg = message ) call fatal_error ( error , message ) call json % destroy ( root ) return end if end if xyz ( 1 : 3 , 1 : size ( geo ) / 3 ) => geo call new ( self , sym , xyz , charge = real ( charge , wp ), uhf = multiplicity - 1 ) if ( len ( comment ) > 0 ) self % comment = comment if ( allocated ( bond )) then self % nbd = size ( bond , 2 ) call move_alloc ( bond , self % bond ) end if call json % destroy ( root ) #else call fatal_error ( error , \"JSON support not enabled\" ) #endif end subroutine read_qcschema","tags":"","loc":"proc/read_qcschema.html"},{"title":"new_structure – MCTC-library","text":"public  subroutine new_structure(self, num, sym, xyz, charge, uhf, lattice, periodic, info, bond) Constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation integer, intent(in) :: num (:) Atomic numbers character(len=*), intent(in) :: sym (:) Element symbols real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information integer, intent(in), optional :: bond (:,:) Bond topology of the system Source Code subroutine new_structure ( self , num , sym , xyz , charge , uhf , lattice , periodic , & & info , bond ) !> Instance of the structure representation type ( structure_type ), intent ( out ) :: self !> Atomic numbers integer , intent ( in ) :: num (:) !> Element symbols character ( len =* ), intent ( in ) :: sym (:) !> Cartesian coordinates real ( wp ), intent ( in ) :: xyz (:, :) !> Total charge real ( wp ), intent ( in ), optional :: charge !> Number of unpaired electrons integer , intent ( in ), optional :: uhf !> Lattice parameters real ( wp ), intent ( in ), optional :: lattice (:, :) !> Periodic directions logical , intent ( in ), optional :: periodic (:) !> Vendor specific structure information type ( structure_info ), intent ( in ), optional :: info !> Bond topology of the system integer , intent ( in ), optional :: bond (:, :) integer :: ndim , iid integer , allocatable :: map (:) ndim = min ( size ( num , 1 ), size ( xyz , 2 ), size ( sym , 1 )) self % nat = ndim allocate ( self % id ( ndim )) allocate ( self % xyz ( 3 , ndim )) if ( present ( lattice )) then self % lattice = lattice else allocate ( self % lattice ( 0 , 0 )) end if if ( present ( periodic )) then self % periodic = periodic else if ( present ( lattice )) then allocate ( self % periodic ( 3 )) self % periodic (:) = . true . else allocate ( self % periodic ( 1 )) self % periodic (:) = . false . end if end if call get_identity ( self % nid , self % id , sym ) allocate ( map ( self % nid )) call collect_identical ( self % id , map ) allocate ( self % num ( self % nid )) allocate ( self % sym ( self % nid )) do iid = 1 , self % nid self % num ( iid ) = num ( map ( iid )) self % sym ( iid ) = sym ( map ( iid )) end do self % xyz (:, :) = xyz (:, : ndim ) if ( present ( charge )) then self % charge = charge else self % charge = 0.0_wp end if if ( present ( uhf )) then self % uhf = uhf else self % uhf = 0 end if if ( present ( info )) then self % info = info else self % info = structure_info () end if if ( present ( bond )) then self % nbd = size ( bond , 2 ) self % bond = bond end if end subroutine new_structure","tags":"","loc":"proc/new_structure.html"},{"title":"new – MCTC-library","text":"public interface new Module Procedures public  subroutine new_structure (self, num, sym, xyz, charge, uhf, lattice, periodic, info, bond) Constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation integer, intent(in) :: num (:) Atomic numbers character(len=*), intent(in) :: sym (:) Element symbols real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information integer, intent(in), optional :: bond (:,:) Bond topology of the system private  subroutine new_structure_num(self, num, xyz, charge, uhf, lattice, periodic, info, bond) Simplified constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation integer, intent(in) :: num (:) Atomic numbers real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information integer, intent(in), optional :: bond (:,:) Bond topology of the system private  subroutine new_structure_sym(self, sym, xyz, charge, uhf, lattice, periodic, info, bond) Simplified constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation character(len=*), intent(in) :: sym (:) Element symbols real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information integer, intent(in), optional :: bond (:,:) Bond topology of the system","tags":"","loc":"interface/new.html"},{"title":"write_vasp – MCTC-library","text":"public  subroutine write_vasp(self, unit, comment_line) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: comment_line Source Code subroutine write_vasp ( self , unit , comment_line ) class ( structure_type ), intent ( in ) :: self integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: comment_line integer :: i , j , izp integer , allocatable :: kinds (:), species (:) real ( wp ), allocatable :: inv_lat (:, :) real ( wp ), allocatable :: abc (:, :) allocate ( species ( self % nat )) allocate ( kinds ( self % nat ), source = 1 ) j = 0 izp = 0 do i = 1 , self % nat if ( izp . eq . self % id ( i )) then kinds ( j ) = kinds ( j ) + 1 else j = j + 1 izp = self % id ( i ) species ( j ) = self % id ( i ) end if end do ! use vasp 5.x format if ( present ( comment_line )) then write ( unit , '(a)' ) comment_line else if ( allocated ( self % comment )) then write ( unit , '(a)' ) self % comment else write ( unit , '(a)' ) end if end if ! scaling factor for lattice parameters is always one write ( unit , '(f20.14)' ) self % info % scale ! write the lattice parameters if ( any ( self % periodic )) then if ( size ( self % lattice , 2 ) == 3 ) then write ( unit , '(3f20.14)' ) self % lattice else write ( unit , '(3f20.14)' ) spread ( 0.0_wp , 1 , 9 ) end if else write ( unit , '(3f20.14)' ) spread ( 0.0_wp , 1 , 9 ) end if do i = 1 , j write ( unit , '(1x, a)' , advance = 'no' ) self % sym ( species ( i )) end do write ( unit , '(a)' ) ! write the count of the consecutive atom types do i = 1 , j write ( unit , '(1x, i0)' , advance = 'no' ) kinds ( i ) end do write ( unit , '(a)' ) deallocate ( kinds , species ) if ( self % info % selective ) write ( unit , '(\"Selective\")' ) ! we write cartesian coordinates if ( any ( shape ( self % lattice ) /= [ 3 , 3 ]) . or . self % info % cartesian ) then write ( unit , '(\"Cartesian\")' ) ! now write the cartesian coordinates do i = 1 , self % nat write ( unit , '(3f20.14)' ) self % xyz (:, i ) * autoaa / self % info % scale end do else write ( unit , '(\"Direct\")' ) inv_lat = matinv_3x3 ( self % lattice ) abc = matmul ( inv_lat , self % xyz ) ! now write the fractional coordinates do i = 1 , self % nat write ( unit , '(3f20.14)' ) abc (:, i ) end do end if end subroutine write_vasp","tags":"","loc":"proc/write_vasp.html"},{"title":"write_aims – MCTC-library","text":"public  subroutine write_aims(self, unit) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle Source Code subroutine write_aims ( self , unit ) !> Instance of the molecular structure data class ( structure_type ), intent ( in ) :: self !> File handle integer , intent ( in ) :: unit integer :: iat , ilt logical :: expo expo = maxval ( self % xyz ) > 1.0e+5 . or . minval ( self % xyz ) < - 1.0e+5 if ( expo ) then do iat = 1 , self % nat write ( unit , '(a, 1x, 3es24.14, 1x, a)' ) & \"atom\" , self % xyz (:, iat ) * autoaa , trim ( self % sym ( self % id ( iat ))) end do else do iat = 1 , self % nat write ( unit , '(a, 1x, 3f24.14, 1x, a)' ) & \"atom\" , self % xyz (:, iat ) * autoaa , trim ( self % sym ( self % id ( iat ))) end do end if if ( any ( self % periodic )) then if ( size ( self % lattice , 2 ) /= 3 ) return do ilt = 1 , 3 if ( self % periodic ( ilt )) then write ( unit , '(a, 1x, 3f24.14)' ) & \"lattice_vector\" , self % lattice (:, ilt ) * autoaa end if end do end if end subroutine write_aims","tags":"","loc":"proc/write_aims.html"},{"title":"read_coord – MCTC-library","text":"public  subroutine read_coord(mol, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: mol Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Source Code subroutine read_coord ( mol , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: mol !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character , parameter :: flag = '$' integer , parameter :: p_initial_size = 100 integer , parameter :: p_nlv ( 3 ) = [ 1 , 4 , 9 ], p_ncp ( 3 ) = [ 1 , 3 , 6 ] logical :: has_coord , has_periodic , has_lattice , has_cell , has_eht logical :: cartesian , coord_in_bohr , lattice_in_bohr , pbc ( 3 ) integer :: stat , iatom , i , j , natoms , periodic , cell_vectors , icharge , unpaired integer :: lnum , pos , lcell , llattice , lperiodic , lcoord , leht type ( token_type ) :: token , token2 real ( wp ) :: latvec ( 9 ), conv , cellpar ( 6 ), lattice ( 3 , 3 ) real ( wp ), allocatable :: coord (:, :), xyz (:, :), charge character ( len = :), allocatable :: line , cell_string , lattice_string , & & line_cell , line_lattice , line_periodic , line_coord , line_eht character ( len = symbol_length ), allocatable :: sym (:) type ( structure_info ) :: info allocate ( sym ( p_initial_size ), source = repeat ( ' ' , symbol_length )) allocate ( coord ( 3 , p_initial_size ), source = 0.0_wp ) lnum = 0 iatom = 0 periodic = 0 cell_vectors = 0 has_eht = . false . has_coord = . false . has_periodic = . false . has_lattice = . false . has_cell = . false . cartesian = . true . coord_in_bohr = . true . lattice_in_bohr = . true . lattice (:, :) = 0.0_wp pbc (:) = . false . charge = 0.0_wp unpaired = 0 stat = 0 call next_line ( unit , line , pos , lnum , stat ) do while ( stat == 0 ) if ( index ( line , flag ) == 1 ) then call next_token ( line , pos , token ) select case ( line ( token % first : token % last )) case ( '$end' ) exit case ( '$eht' ) if ( has_eht ) then pos = 0 call next_token ( line_eht , pos , token2 ) call io2_error ( error , \"Duplicated eht data group\" , & & line_eht , line , token2 , token , & & filename ( unit ), leht , lnum , & & \"charge/multiplicity first defined here\" , \"duplicated eht data\" ) return end if has_eht = . true . leht = lnum line_eht = line i = index ( line , 'charge=' ) if ( i > 0 ) then pos = i + 6 call read_next_token ( line , pos , token , icharge , stat ) charge = real ( icharge , wp ) end if j = index ( line , 'unpaired=' ) if ( j > 0 . and . stat == 0 ) then pos = j + 8 call read_next_token ( line , pos , token , unpaired , stat ) end if if ( stat /= 0 ) then call io_error ( error , \"Cannot read eht entry\" , & & line , token , filename ( unit ), lnum , \"expected integer value\" ) return end if case ( '$coord' ) if ( has_coord ) then pos = 0 call next_token ( line_coord , pos , token2 ) call io2_error ( error , \"Duplicated coord data group\" , & & line_coord , line , token2 , token , & & filename ( unit ), lcoord , lnum , & & \"coordinates first defined here\" , \"duplicated coordinate group\" ) return end if lcoord = lnum line_coord = line has_coord = . true . ! $coord angs / $coord bohr / $coord frac call select_unit ( line , coord_in_bohr , cartesian ) coord_group : do while ( stat == 0 ) call next_line ( unit , line , pos , lnum , stat ) if ( index ( line , flag ) == 1 ) exit coord_group if ( iatom >= size ( coord , 2 )) call resize ( coord ) if ( iatom >= size ( sym )) call resize ( sym ) iatom = iatom + 1 call read_next_token ( line , pos , token , coord ( 1 , iatom ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 2 , iatom ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 3 , iatom ), stat ) if ( stat == 0 ) & call next_token ( line , pos , token ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read coordinates\" , & & line , token , filename ( unit ), lnum , \"expected real value\" ) return end if token % last = min ( token % last , token % first + symbol_length - 1 ) sym ( iatom ) = line ( token % first : token % last ) if ( to_number ( sym ( iatom )) == 0 ) then call io_error ( error , \"Cannot map symbol to atomic number\" , & & line , token , filename ( unit ), lnum , \"unknown element\" ) return end if end do coord_group cycle case ( '$periodic' ) if ( has_periodic ) then pos = 0 call next_token ( line_periodic , pos , token2 ) call io2_error ( error , \"Duplicated periodic data group\" , & & line_periodic , line , token2 , token , & & filename ( unit ), lperiodic , lnum , & & \"periodicity first defined here\" , \"duplicated periodicity data\" ) return end if lperiodic = lnum line_periodic = line has_periodic = . true . ! $periodic 0/1/2/3 call read_next_token ( line , pos , token , periodic , stat ) if ( stat /= 0 . or . periodic < 0 . or . periodic > 3 ) then call io_error ( error , \"Cannot read periodicity of system\" , & & line , token , filename ( unit ), lnum , \"expected integer (0 to 3)\" ) return end if case ( '$lattice' ) if ( has_lattice ) then pos = 0 call next_token ( line_lattice , pos , token2 ) call io2_error ( error , \"Duplicated lattice data group\" , & & line_lattice , line , token2 , token , & & filename ( unit ), llattice , lnum , & & \"lattice parameters first defined here\" , \"duplicated lattice group\" ) return end if llattice = lnum line_lattice = line has_lattice = . true . ! $lattice bohr / $lattice angs call select_unit ( line , lattice_in_bohr ) cell_vectors = 0 lattice_string = '' lattice_group : do while ( stat == 0 ) call next_line ( unit , line , pos , lnum , stat ) if ( index ( line , flag ) == 1 ) exit lattice_group cell_vectors = cell_vectors + 1 lattice_string = lattice_string // ' ' // line end do lattice_group cycle case ( '$cell' ) if ( has_cell ) then pos = 0 call next_token ( line_cell , pos , token2 ) call io2_error ( error , \"Duplicated cell data group\" , & & line_cell , line , token2 , token , & & filename ( unit ), lcell , lnum , & & \"cell parameters first defined here\" , \"duplicated cell group\" ) return end if lcell = lnum line_cell = line has_cell = . true . ! $cell bohr / $cell angs call select_unit ( line , lattice_in_bohr ) call next_line ( unit , cell_string , pos , lnum , stat ) if ( debug ) print * , cell_string end select end if token = token_type ( 0 , 0 ) call next_line ( unit , line , pos , lnum , stat ) end do if ( allocated ( error )) return if (. not . has_coord . or . iatom == 0 ) then call io_error ( error , \"coordinates not present, cannot work without coordinates\" , & & line , token , filename ( unit ), lnum , \"unexpected end of input\" ) return end if if ( has_cell . and . has_lattice ) then block type ( token_type ) :: tcell , tlattice pos = 0 call next_token ( line_cell , pos , tcell ) pos = 0 call next_token ( line_lattice , pos , tlattice ) tlattice = token_type ( 1 , len ( line_lattice )) if ( lcell > llattice ) then call io2_error ( error , \"Conflicting lattice and cell groups\" , & & line_lattice , line_cell , tlattice , tcell , & & filename ( unit ), llattice , lcell , & & \"lattice first defined here\" , \"conflicting cell group\" ) else call io2_error ( error , \"Conflicting lattice and cell groups\" , & & line_cell , line_lattice , tcell , tlattice , & & filename ( unit ), lcell , llattice , & & \"cell first defined here\" , \"conflicting lattice group\" ) end if end block return end if if (. not . has_periodic . and . ( has_cell . or . has_lattice )) then pos = 0 if ( has_cell ) then call next_token ( line_cell , pos , token ) call io_error ( error , \"Cell parameters defined without periodicity\" , & & line_cell , token , filename ( unit ), & & lcell , \"cell defined here\" ) end if if ( has_lattice ) then call next_token ( line_lattice , pos , token ) call io_error ( error , \"Lattice parameters defined without periodicity\" , & & line_lattice , token , filename ( unit ), & & llattice , \"lattice defined here\" ) end if return end if if ( periodic > 0 . and . . not .( has_cell . or . has_lattice )) then pos = 0 call next_token ( line_periodic , pos , token ) call io_error ( error , \"Missing lattice or cell data\" , & & line_periodic , token , filename ( unit ), & & lperiodic , \"periodic system defined here\" ) return end if if (. not . cartesian . and . periodic == 0 ) then pos = 0 call next_token ( line_coord , pos , token ) call next_token ( line_coord , pos , token ) call io_error ( error , \"Molecular systems cannot have fractional coordinates\" , & & line_coord , token , filename ( unit ), & & lcoord , \"fractional modifier found\" ) return end if natoms = iatom allocate ( xyz ( 3 , natoms )) if ( periodic > 0 ) pbc (: periodic ) = . true . if ( has_cell ) then read ( cell_string , * , iostat = stat ) latvec (: p_ncp ( periodic )) if ( debug ) print * , latvec (: p_ncp ( periodic )) if ( lattice_in_bohr ) then conv = 1.0_wp else conv = aatoau end if select case ( periodic ) case ( 1 ) cellpar = [ latvec ( 1 ) * conv , 1.0_wp , 1.0_wp , & & pi / 2 , pi / 2 , pi / 2 ] case ( 2 ) cellpar = [ latvec ( 1 ) * conv , latvec ( 2 ) * conv , 1.0_wp , & & pi / 2 , pi / 2 , latvec ( 3 ) * pi / 18 0.0_wp ] case ( 3 ) cellpar = [ latvec ( 1 : 3 ) * conv , latvec ( 4 : 6 ) * pi / 18 0.0_wp ] end select call cell_to_dlat ( cellpar , lattice ) end if if ( has_lattice ) then if ( cell_vectors /= periodic ) then pos = 0 call next_token ( line_lattice , pos , token ) pos = len_trim ( line_periodic ) call io2_error ( error , \"Number of lattice vectors does not match periodicity\" , & & line_lattice , line_periodic , token , token_type ( pos , pos ), & & filename ( unit ), llattice , lperiodic , & & \"lattice vectors defined here\" , \"conflicting periodicity\" ) return end if read ( lattice_string , * , iostat = stat ) latvec (: p_nlv ( periodic )) if ( lattice_in_bohr ) then conv = 1.0_wp else conv = aatoau end if j = 0 do i = 1 , periodic lattice (: periodic , i ) = latvec ( j + 1 : j + periodic ) * conv j = j + periodic end do end if if ( cartesian ) then if ( coord_in_bohr ) then conv = 1.0_wp else conv = aatoau end if xyz (:, :) = coord (:, : natoms ) * conv else ! Non-periodic coordinates are in Bohr xyz ( periodic + 1 : 3 , :) = coord ( periodic + 1 : 3 , : natoms ) ! Periodic coordinates must still be transformed with lattice xyz (: periodic , :) = matmul ( lattice (: periodic , : periodic ), coord (: periodic , : natoms )) end if ! save data on input format info = structure_info ( cartesian = cartesian , lattice = has_lattice , & & angs_lattice = . not . lattice_in_bohr , angs_coord = . not . coord_in_bohr ) call new ( mol , sym (: natoms ), xyz , charge = charge , uhf = unpaired , & & lattice = lattice , periodic = pbc , info = info ) contains subroutine select_unit ( line , in_bohr , cartesian ) character ( len =* ), intent ( in ) :: line logical , intent ( out ) :: in_bohr logical , intent ( out ), optional :: cartesian in_bohr = index ( line , ' angs' ) == 0 if ( present ( cartesian )) cartesian = index ( line , ' frac' ) == 0 end subroutine select_unit end subroutine read_coord","tags":"","loc":"proc/read_coord.html"},{"title":"get_mctc_feature – MCTC-library","text":"public pure function get_mctc_feature(feature) result(has_feature) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: feature Feature name Return Value logical Whether the feature is enabled Source Code pure function get_mctc_feature ( feature ) result ( has_feature ) !> Feature name character ( len =* ), intent ( in ) :: feature !> Whether the feature is enabled logical :: has_feature select case ( feature ) case ( \"json\" ) has_feature = mctc_with_json case default has_feature = . false . end select end function get_mctc_feature","tags":"","loc":"proc/get_mctc_feature.html"},{"title":"get_mctc_version – MCTC-library","text":"public pure subroutine get_mctc_version(major, minor, patch, string) Getter function to retrieve mctc-lib version Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: major Major version number of the mctc-lib version integer, intent(out), optional :: minor Minor version number of the mctc-lib version integer, intent(out), optional :: patch Patch version number of the mctc-lib version character(len=:), intent(out), optional, allocatable :: string String representation of the mctc-lib version Source Code pure subroutine get_mctc_version ( major , minor , patch , string ) !> Major version number of the mctc-lib version integer , intent ( out ), optional :: major !> Minor version number of the mctc-lib version integer , intent ( out ), optional :: minor !> Patch version number of the mctc-lib version integer , intent ( out ), optional :: patch !> String representation of the mctc-lib version character ( len = :), allocatable , intent ( out ), optional :: string if ( present ( major )) then major = mctc_version_compact ( 1 ) end if if ( present ( minor )) then minor = mctc_version_compact ( 2 ) end if if ( present ( patch )) then patch = mctc_version_compact ( 3 ) end if if ( present ( string )) then string = mctc_version_string end if end subroutine get_mctc_version","tags":"","loc":"proc/get_mctc_version.html"},{"title":"read_cjson – MCTC-library","text":"public  subroutine read_cjson(self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Source Code subroutine read_cjson ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error #if WITH_JSON type ( json_core ) :: json type ( json_value ), pointer :: root , val , child , array logical :: cartesian , found integer :: stat , schema_version , charge , multiplicity , ibond character ( len = :), allocatable :: input , line , message , comment integer , allocatable :: num (:), bond (:, :), list (:), order (:) real ( wp ) :: cellpar ( 6 ) real ( wp ), allocatable :: lattice (:, :) real ( wp ), allocatable , target :: geo (:) real ( wp ), pointer :: xyz (:, :) stat = 0 input = \"\" do call getline ( unit , line , stat ) if ( stat /= 0 ) exit input = input // line end do call json % deserialize ( root , input ) if ( json % failed ()) then call json % check_for_errors ( error_msg = message ) call fatal_error ( error , message ) call json % destroy ( root ) return end if val => root call cjson_get ( json , val , \"chemicalJson\" , \"chemical json\" , child ) if (. not . associated ( child )) then call fatal_error ( error , \"No 'chemical json' key found\" ) call json % destroy ( root ) return end if call json % get ( child , schema_version ) ! There seems to be no actual difference between version 0 and 1, though if ( all ( schema_version /= [ 0 , 1 ])) then call fatal_error ( error , \"Unsupported schema version for 'chemical json'\" ) call json % destroy ( root ) return end if call json % get ( val , \"atoms.elements.number\" , num ) if (. not . allocated ( num ) . or . json % failed ()) then call fatal_error ( error , \"List of atomic symbols must be provided\" ) call json % destroy ( root ) return end if call cjson_get ( json , val , \"unitCell\" , \"unit cell\" , child ) if ( associated ( child )) then call json % get ( child , \"a\" , cellpar ( 1 )) call json % get ( child , \"b\" , cellpar ( 2 )) call json % get ( child , \"c\" , cellpar ( 3 )) call json % get ( child , \"alpha\" , cellpar ( 4 )) call json % get ( child , \"beta\" , cellpar ( 5 )) call json % get ( child , \"gamma\" , cellpar ( 6 )) if ( json % failed ()) then call json % check_for_errors ( error_msg = message ) call fatal_error ( error , message ) call json % destroy ( root ) return end if cellpar ( 1 : 3 ) = cellpar ( 1 : 3 ) * aatoau cellpar ( 4 : 6 ) = cellpar ( 4 : 6 ) * ( pi / 180 ) allocate ( lattice ( 3 , 3 )) call cell_to_dlat ( cellpar , lattice ) end if call json % get ( val , \"atoms.coords.3d\" , geo , found = cartesian ) if (. not . cartesian . and . allocated ( lattice )) then call cjson_get ( json , val , \"atoms.coords.3dFractional\" , \"atoms.coords.3d fractional\" , & & child ) if ( associated ( child )) call json % get ( child , geo ) end if if (. not . allocated ( geo ) . or . json % failed ()) then call fatal_error ( error , \"Cartesian coordinates must be provided\" ) call json % destroy ( root ) return end if if ( 3 * size ( num ) /= size ( geo )) then call fatal_error ( error , \"Number of atomic numbers and coordinate triples must match\" ) call json % destroy ( root ) return end if call json % get ( val , \"bonds.connections.index\" , list , found = found ) call json % get ( val , \"bonds.order\" , order , found = found ) if (. not . allocated ( order ) . and . allocated ( list )) & allocate ( order ( size ( list ) / 2 ), source = 1 ) if ( json % failed ()) then call fatal_error ( error , \"Cannot read entries from 'bonds'\" ) call json % destroy ( root ) return end if if ( allocated ( list )) then allocate ( bond ( 3 , size ( list ) / 2 )) do ibond = 1 , size ( bond , 2 ) bond (:, ibond ) = [ list ( 2 * ibond - 1 ) + 1 , list ( 2 * ibond ) + 1 , order ( ibond )] end do end if call json % get ( val , \"name\" , comment , default = \"\" ) call json % get ( val , \"properties.totalCharge\" , charge , found = found ) if (. not . found ) then call json % get ( val , \"atoms.formalCharges\" , list , found = found ) charge = 0 if ( allocated ( list )) charge = sum ( list ) end if call json % get ( val , \"properties.totalSpinMultiplicity\" , multiplicity , found = found ) if (. not . found ) multiplicity = 1 if ( json % failed ()) then call json % check_for_errors ( error_msg = message ) call fatal_error ( error , message ) call json % destroy ( root ) return end if xyz ( 1 : 3 , 1 : size ( geo ) / 3 ) => geo xyz (:, :) = xyz * aatoau if (. not . cartesian ) then xyz (:, :) = matmul ( lattice , xyz (:, :)) end if call new ( self , num , xyz , lattice = lattice , charge = real ( charge , wp ), uhf = multiplicity - 1 ) if ( len ( comment ) > 0 ) self % comment = comment if ( allocated ( bond )) then self % nbd = size ( bond , 2 ) call move_alloc ( bond , self % bond ) end if call json % destroy ( root ) contains subroutine cjson_get ( json , val , key1 , key2 , child ) type ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: val type ( json_value ), pointer , intent ( out ) :: child character ( * ), intent ( in ) :: key1 , key2 logical :: found call json % get ( val , key1 , child , found = found ) if (. not . found ) then call json % get ( val , key2 , child , found = found ) end if end subroutine cjson_get #else call fatal_error ( error , \"JSON support not enabled\" ) #endif end subroutine read_cjson","tags":"","loc":"proc/read_cjson.html"},{"title":"to_lcsymbol – MCTC-library","text":"public elemental function to_lcsymbol(number) result(symbol) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name integer, intent(in) :: number Atomic number Return Value character(len=2) Element symbol Source Code elemental function to_lcsymbol ( number ) result ( symbol ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ) :: symbol call number_to_lcsymbol ( symbol , number ) end function to_lcsymbol","tags":"","loc":"proc/to_lcsymbol.html"},{"title":"to_number – MCTC-library","text":"public elemental function to_number(symbol) result(number) Convert element symbol to atomic number Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: symbol Element symbol Return Value integer Atomic number Source Code elemental function to_number ( symbol ) result ( number ) !> Element symbol character ( len =* ), intent ( in ) :: symbol !> Atomic number integer :: number call symbol_to_number ( number , symbol ) end function to_number","tags":"","loc":"proc/to_number.html"},{"title":"to_symbol – MCTC-library","text":"public elemental function to_symbol(number) result(symbol) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name integer, intent(in) :: number Atomic number Return Value character(len=2) Element symbol Source Code elemental function to_symbol ( number ) result ( symbol ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ) :: symbol call number_to_symbol ( symbol , number ) end function to_symbol","tags":"","loc":"proc/to_symbol.html"},{"title":"collect_identical – MCTC-library","text":"public pure subroutine collect_identical(identity, mapping) Establish a mapping between unique atom types and species Arguments Type Intent Optional Attributes Name integer, intent(in) :: identity (:) Chemical identity integer, intent(out) :: mapping (:) Mapping from unique atoms Source Code pure subroutine collect_identical ( identity , mapping ) !> Chemical identity integer , intent ( in ) :: identity (:) !> Mapping from unique atoms integer , intent ( out ) :: mapping (:) integer :: iid , iat do iid = 1 , size ( mapping ) do iat = 1 , size ( identity ) if ( identity ( iat ) == iid ) then mapping ( iid ) = iat exit end if end do end do end subroutine collect_identical","tags":"","loc":"proc/collect_identical.html"},{"title":"number_to_lcsymbol – MCTC-library","text":"public elemental subroutine number_to_lcsymbol(symbol, number) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name character(len=2), intent(out) :: symbol Element symbol integer, intent(in) :: number Atomic number Source Code elemental subroutine number_to_lcsymbol ( symbol , number ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ), intent ( out ) :: symbol if ( number <= 0 . or . number > size ( lcpse )) then symbol = '--' else symbol = lcpse ( number ) endif end subroutine number_to_lcsymbol","tags":"","loc":"proc/number_to_lcsymbol.html"},{"title":"number_to_symbol – MCTC-library","text":"public elemental subroutine number_to_symbol(symbol, number) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name character(len=2), intent(out) :: symbol Element symbol integer, intent(in) :: number Atomic number Source Code elemental subroutine number_to_symbol ( symbol , number ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ), intent ( out ) :: symbol if ( number <= 0 . or . number > size ( pse )) then symbol = '--' else symbol = pse ( number ) endif end subroutine number_to_symbol","tags":"","loc":"proc/number_to_symbol.html"},{"title":"symbol_to_number – MCTC-library","text":"public elemental subroutine symbol_to_number(number, symbol) Convert element symbol to atomic number Arguments Type Intent Optional Attributes Name integer, intent(out) :: number Atomic number character(len=*), intent(in) :: symbol Element symbol Source Code elemental subroutine symbol_to_number ( number , symbol ) !> Element symbol character ( len =* ), intent ( in ) :: symbol !> Atomic number integer , intent ( out ) :: number character ( len = 2 ) :: lcsymbol integer :: i , j , k , l number = 0 lcsymbol = '  ' k = 0 do j = 1 , len_trim ( symbol ) if ( k > 2 ) exit l = iachar ( symbol ( j : j )) if ( k >= 1 . and . l == iachar ( ' ' )) exit if ( k >= 1 . and . l == 9 ) exit if ( l >= iachar ( 'A' ) . and . l <= iachar ( 'Z' )) l = l + offset if ( l >= iachar ( 'a' ) . and . l <= iachar ( 'z' )) then k = k + 1 if ( k > 2 ) exit lcsymbol ( k : k ) = achar ( l ) endif enddo do i = 1 , size ( lcpse ) if ( lcsymbol == lcpse ( i )) then number = i exit endif enddo if ( number == 0 ) then select case ( lcsymbol ) case ( 'd ' , 't ' ) number = 1 end select end if end subroutine symbol_to_number","tags":"","loc":"proc/symbol_to_number.html"},{"title":"get_identity – MCTC-library","text":"public interface get_identity Get chemical identity Module Procedures private pure subroutine get_identity_number(nid, identity, number) Get chemical identity from a list of atomic numbers Arguments Type Intent Optional Attributes Name integer, intent(out) :: nid Number of unique species integer, intent(out) :: identity (:) Chemical identity integer, intent(in) :: number (:) Ordinal numbers private pure subroutine get_identity_symbol(nid, identity, symbol) Get chemical identity from a list of element symbols Arguments Type Intent Optional Attributes Name integer, intent(out) :: nid Number of unique species integer, intent(out) :: identity (:) Chemical identity character(len=*), intent(in) :: symbol (:) Element symbols","tags":"","loc":"interface/get_identity.html"},{"title":"read_vasp – MCTC-library","text":"public  subroutine read_vasp(self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Source Code subroutine read_vasp ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error logical :: selective , cartesian integer :: i , j , k , nn , ntype , natoms , izp , stat , pos , lnum integer , allocatable :: ncount (:) real ( wp ) :: ddum , latvec ( 3 ), scalar , coord ( 3 ), lattice ( 3 , 3 ) real ( wp ), allocatable :: xyz (:, :) type ( token_type ) :: token character ( len = :), allocatable :: line , comment character ( len = 2 * symbol_length ), allocatable :: args (:), args2 (:) character ( len = symbol_length ), allocatable :: sym (:) type ( structure_info ) :: info selective = . false . ! Selective dynamics cartesian = . true . ! Cartesian or direct lattice = 0 stat = 0 lnum = 0 ntype = 0 ! first line contains the symbols of different atom types call next_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if call parse_line ( \" \" // line , args , ntype ) call move_alloc ( line , comment ) ! this line contains the global scaling factor, call next_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if call read_next_token ( line , pos , token , ddum , stat ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read scaling factor\" , & & line , token , filename ( unit ), lnum , \"expected real value\" ) return end if ! the Ang->au conversion is included in the scaling factor scalar = ddum * aatoau ! reading the lattice constants do i = 1 , 3 call next_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of lattice vectors encountered\" ) return end if call read_next_token ( line , pos , token , latvec ( 1 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , latvec ( 2 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , latvec ( 3 ), stat ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read lattice vectors from input\" , & & line , token , filename ( unit ), lnum , \"expected real value\" ) return end if lattice (:, i ) = latvec * scalar end do ! Either here are the numbers of each element, ! or (>vasp.5.1) here are the element symbols call next_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if ! try to verify that first element is actually a number i = max ( verify ( line , ' ' ), 1 ) j = scan ( line ( i :), ' ' ) - 2 + i if ( j < i ) j = len_trim ( line ) ! CONTCAR files have additional Element line here since vasp.5.1 if ( verify ( line ( i : j ), '1234567890' ) /= 0 ) then call parse_line ( \" \" // line , args , ntype ) call next_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if else deallocate ( comment ) end if call parse_line ( \" \" // line , args2 , nn ) if ( nn /= ntype ) then call fatal_error ( error , 'Number of atom types mismatches the number of counts' ) return end if allocate ( ncount ( nn ), source = 0 ) do i = 1 , nn read ( args2 ( i ), * , iostat = stat ) ncount ( i ) izp = to_number ( args ( i )) if ( izp < 1 . or . ncount ( i ) < 1 ) then call fatal_error ( error , \"Unknown element '\" // trim ( args ( i )) // \"' encountered\" ) return end if end do natoms = sum ( ncount ) allocate ( sym ( natoms )) allocate ( xyz ( 3 , natoms )) k = 0 do i = 1 , nn do j = 1 , ncount ( i ) k = k + 1 sym ( k ) = trim ( args ( i )) end do end do call next_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Could not read POSCAR\" ) return end if line = adjustl ( line ) if ( line (: 1 ). eq . 's' . or . line (: 1 ). eq . 'S' ) then selective = . true . call next_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if line = adjustl ( line ) end if cartesian = ( line (: 1 ). eq . 'c' . or . line (: 1 ). eq . 'C' . or . & & line (: 1 ). eq . 'k' . or . line (: 1 ). eq . 'K' ) do i = 1 , natoms call next_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of geometry encountered\" ) return end if call read_next_token ( line , pos , token , coord ( 1 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 2 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 3 ), stat ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read geometry from input\" , & & line , token , filename ( unit ), lnum , \"expected real value\" ) return end if if ( cartesian ) then xyz (:, i ) = coord * scalar else xyz (:, i ) = matmul ( lattice , coord ) end if end do ! save information about this POSCAR for later info = structure_info ( scale = ddum , selective = selective , cartesian = cartesian ) call new ( self , sym , xyz , lattice = lattice , info = info ) if ( allocated ( comment )) self % comment = comment end subroutine read_vasp","tags":"","loc":"proc/read_vasp.html"},{"title":"write_coord – MCTC-library","text":"public  subroutine write_coord(mol, unit) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: mol integer, intent(in) :: unit Source Code subroutine write_coord ( mol , unit ) class ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer :: iat , ilt , npbc logical :: expo real ( wp ) :: conv_fac logical :: angs angs = mol % info % angs_coord conv_fac = 1.0_wp if ( angs ) conv_fac = autoaa if ( angs ) then write ( unit , '(a)' ) \"$coord angs\" else write ( unit , '(a)' ) \"$coord\" end if expo = maxval ( mol % xyz ) > 1.0e+5 . or . minval ( mol % xyz ) < - 1.0e+5 if ( expo ) then do iat = 1 , mol % nat write ( unit , '(3es24.14, 6x, a)' ) mol % xyz (:, iat ) * conv_fac , & trim ( mol % sym ( mol % id ( iat ))) end do else do iat = 1 , mol % nat write ( unit , '(3f24.14, 6x, a)' ) mol % xyz (:, iat ) * conv_fac , & trim ( mol % sym ( mol % id ( iat ))) end do end if if ( any ([ nint ( mol % charge ), mol % uhf ] /= 0 )) then write ( unit , '(a, *(1x, a, \"=\", i0))' ) & \"$eht\" , \"charge\" , nint ( mol % charge ), \"unpaired\" , mol % uhf end if if ( any ( mol % periodic )) then write ( unit , '(a, 1x, i0)' ) \"$periodic\" , count ( mol % periodic ) npbc = count ( mol % periodic ) if ( size ( mol % lattice , 2 ) == 3 ) then if ( angs ) then write ( unit , '(a)' ) \"$lattice angs\" else write ( unit , '(a)' ) \"$lattice bohr\" end if do ilt = 1 , npbc write ( unit , '(3f20.14)' ) mol % lattice (: npbc , ilt ) * conv_fac end do end if end if write ( unit , '(a)' ) \"$end\" end subroutine write_coord","tags":"","loc":"proc/write_coord.html"},{"title":"read_xyz – MCTC-library","text":"public  subroutine read_xyz(self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Source Code subroutine read_xyz ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: ii , n , iat , stat , pos , lnum real ( wp ) :: x , y , z , conv real ( wp ), allocatable :: xyz (:, :) type ( token_type ) :: token , tsym , tnat character ( len = symbol_length ) :: chdum character ( len = symbol_length ), allocatable :: sym (:) character ( len = :), allocatable :: line , comment , fline conv = aatoau lnum = 0 call next_line ( unit , fline , pos , lnum , stat ) call read_next_token ( fline , pos , tnat , n , stat ) if ( stat /= 0 ) then call io_error ( error , \"Could not read number of atoms\" , & & fline , tnat , filename ( unit ), lnum , \"expected integer value\" ) return end if if ( n . lt . 1 ) then call io_error ( error , \"Impossible number of atoms provided\" , & & fline , tnat , filename ( unit ), lnum , \"expected positive integer value\" ) return end if allocate ( sym ( n )) allocate ( xyz ( 3 , n )) ! next record is a comment call next_line ( unit , comment , pos , lnum , stat ) if ( stat /= 0 ) then call io_error ( error , \"Unexpected end of file\" , & & \"\" , token_type ( 0 , 0 ), filename ( unit ), lnum + 1 , \"expected value\" ) return end if ii = 0 do while ( ii < n ) call next_line ( unit , line , pos , lnum , stat ) if ( is_iostat_end ( stat )) exit if ( stat /= 0 ) then call io_error ( error , \"Could not read geometry from xyz file\" , & & \"\" , token_type ( 0 , 0 ), filename ( unit ), lnum + 1 , \"expected value\" ) return end if call next_token ( line , pos , tsym ) if ( stat == 0 ) & call read_next_token ( line , pos , token , x , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , y , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , z , stat ) if ( stat /= 0 ) then call io_error ( error , \"Could not parse coordinates from xyz file\" , & & line , token , filename ( unit ), lnum , \"expected real value\" ) return end if ! Adjust the token length to faithfully report the used chars in case of an error tsym % last = min ( tsym % last , tsym % first + symbol_length - 1 ) chdum = line ( tsym % first : tsym % last ) iat = to_number ( chdum ) if ( iat <= 0 ) then read ( chdum , * , iostat = stat ) iat if ( stat == 0 ) then chdum = to_symbol ( iat ) else iat = 0 end if end if if ( iat > 0 ) then ii = ii + 1 sym ( ii ) = trim ( chdum ) xyz (:, ii ) = [ x , y , z ] * conv else call io_error ( error , \"Cannot map symbol to atomic number\" , & & line , tsym , filename ( unit ), lnum , \"unknown element\" ) return end if end do if ( ii /= n ) then call io_error ( error , \"Atom number missmatch in xyz file\" , & & fline , tnat , filename ( unit ), 1 , \"found \" // to_string ( ii ) // \" atoms in input\" ) return end if call new ( self , sym , xyz ) if ( len ( comment ) > 0 ) self % comment = comment end subroutine read_xyz","tags":"","loc":"proc/read_xyz.html"},{"title":"write_qchem – MCTC-library","text":"public  subroutine write_qchem(self, unit) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle Source Code subroutine write_qchem ( self , unit ) !> Instance of the molecular structure data class ( structure_type ), intent ( in ) :: self !> File handle integer , intent ( in ) :: unit integer :: iat logical :: expo write ( unit , '(a)' ) \"$molecule\" write ( unit , '(*(1x, i0))' ) nint ( self % charge ), self % uhf + 1 expo = maxval ( self % xyz ) > 1.0e+5 . or . minval ( self % xyz ) < - 1.0e+5 if ( expo ) then do iat = 1 , self % nat write ( unit , '(a, 1x, 3es24.14)' ) & self % sym ( self % id ( iat )), self % xyz (:, iat ) * autoaa end do else do iat = 1 , self % nat write ( unit , '(a, 1x, 3f24.14)' ) & self % sym ( self % id ( iat )), self % xyz (:, iat ) * autoaa end do end if write ( unit , '(a)' ) \"$end\" end subroutine write_qchem","tags":"","loc":"proc/write_qchem.html"},{"title":"write_cjson – MCTC-library","text":"public  subroutine write_cjson(mol, unit) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(in) :: mol integer, intent(in) :: unit Source Code subroutine write_cjson ( mol , unit ) type ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit write ( unit , '(a)' ) json_string ( mol , \"  \" ) end subroutine write_cjson","tags":"","loc":"proc/write_cjson.html"},{"title":"read_gaussian_external – MCTC-library","text":"public  subroutine read_gaussian_external(self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Source Code subroutine read_gaussian_external ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: stat , n , mode , chrg , spin , iat , ii , pos , lnum type ( token_type ) :: token , tnat character ( len = :), allocatable :: line integer , allocatable :: at (:) real ( wp ), allocatable :: xyz (:,:) real ( wp ) :: coord ( 3 ), q lnum = 0 call next_line ( unit , line , pos , lnum , stat ) if ( stat == 0 ) then token = token_type ( 1 , 10 ) tnat = token call read_token ( line , token , n , stat ) end if if ( stat == 0 ) then token = token_type ( 11 , 20 ) call read_token ( line , token , mode , stat ) end if if ( stat == 0 ) then token = token_type ( 21 , 30 ) call read_token ( line , token , chrg , stat ) end if if ( stat == 0 ) then token = token_type ( 31 , 40 ) call read_token ( line , token , spin , stat ) end if if ( stat /= 0 ) then call io_error ( error , \"Could not read number of atoms\" , & & line , token , filename ( unit ), lnum , \"expected integer value\" ) return end if if ( n <= 0 ) then call io_error ( error , \"Found no atoms, cannot work without atoms!\" , & & line , tnat , filename ( unit ), lnum , \"expected positive integer\" ) return end if allocate ( xyz ( 3 , n )) allocate ( at ( n )) ii = 0 do while ( ii < n ) call next_line ( unit , line , pos , lnum , stat ) if ( is_iostat_end ( stat )) exit if ( stat == 0 ) then token = token_type ( 1 , 10 ) tnat = token call read_token ( line , token , iat , stat ) end if if ( stat == 0 ) then token = token_type ( 11 , 30 ) call read_token ( line , token , coord ( 1 ), stat ) end if if ( stat == 0 ) then token = token_type ( 31 , 50 ) call read_token ( line , token , coord ( 2 ), stat ) end if if ( stat == 0 ) then token = token_type ( 51 , 70 ) call read_token ( line , token , coord ( 3 ), stat ) end if if ( stat == 0 ) then token = token_type ( 71 , 90 ) call read_token ( line , token , q , stat ) end if if ( stat /= 0 ) then call io_error ( error , \"Could not read geometry from Gaussian file\" , & & line , token , filename ( unit ), lnum , \"unexpected value\" ) return end if if ( iat > 0 ) then ii = ii + 1 at ( ii ) = iat xyz (:, ii ) = coord else call io_error ( error , \"Invalid atomic number\" , & & line , tnat , filename ( unit ), lnum , \"expected positive integer\" ) return end if end do call new ( self , at , xyz , charge = real ( chrg , wp ), uhf = spin ) if ( ii /= n ) then call fatal_error ( error , \"Atom number missmatch in Gaussian file\" ) return end if end subroutine read_gaussian_external","tags":"","loc":"proc/read_gaussian_external.html"},{"title":"crossprod – MCTC-library","text":"public pure function crossprod(a, b) result(c) Implements the cross/vector product between two 3D vectors Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3) First vector real(kind=wp), intent(in) :: b (3) Second vector Return Value real(kind=wp), (3) Orthogonal vector Source Code pure function crossprod ( a , b ) result ( c ) !> First vector real ( wp ), intent ( in ) :: a ( 3 ) !> Second vector real ( wp ), intent ( in ) :: b ( 3 ) !> Orthogonal vector real ( wp ) :: c ( 3 ) c ( 1 ) = a ( 2 ) * b ( 3 ) - b ( 2 ) * a ( 3 ) c ( 2 ) = a ( 3 ) * b ( 1 ) - b ( 3 ) * a ( 1 ) c ( 3 ) = a ( 1 ) * b ( 2 ) - b ( 1 ) * a ( 2 ) end function crossprod","tags":"","loc":"proc/crossprod.html"},{"title":"matdet_3x3 – MCTC-library","text":"public pure function matdet_3x3(a) result(det) Determinant of 3×3 matrix Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3,3) Matrix Return Value real(kind=wp) Determinant Source Code pure function matdet_3x3 ( a ) result ( det ) !> Matrix real ( wp ), intent ( in ) :: a ( 3 , 3 ) !> Determinant real ( wp ) :: det det = a ( 1 , 1 ) * a ( 2 , 2 ) * a ( 3 , 3 ) & & - a ( 1 , 1 ) * a ( 2 , 3 ) * a ( 3 , 2 ) & & - a ( 1 , 2 ) * a ( 2 , 1 ) * a ( 3 , 3 ) & & + a ( 1 , 2 ) * a ( 2 , 3 ) * a ( 3 , 1 ) & & + a ( 1 , 3 ) * a ( 2 , 1 ) * a ( 3 , 2 ) & & - a ( 1 , 3 ) * a ( 2 , 2 ) * a ( 3 , 1 ) end function matdet_3x3","tags":"","loc":"proc/matdet_3x3.html"},{"title":"matinv_3x3 – MCTC-library","text":"public pure function matinv_3x3(a) result(b) Performs a direct calculation of the inverse of a 3×3 matrix. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3,3) Matrix Return Value real(kind=wp), (3,3) Inverse matrix Source Code pure function matinv_3x3 ( a ) result ( b ) !> Matrix real ( wp ), intent ( in ) :: a ( 3 , 3 ) !> Inverse matrix real ( wp ) :: b ( 3 , 3 ) real ( wp ) :: detinv ! Calculate the inverse determinant of the matrix detinv = 1.0_wp / matdet_3x3 ( a ) ! Calculate the inverse of the matrix b ( 1 , 1 ) = + detinv * ( a ( 2 , 2 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 3 , 2 )) b ( 2 , 1 ) = - detinv * ( a ( 2 , 1 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 3 , 1 )) b ( 3 , 1 ) = + detinv * ( a ( 2 , 1 ) * a ( 3 , 2 ) - a ( 2 , 2 ) * a ( 3 , 1 )) b ( 1 , 2 ) = - detinv * ( a ( 1 , 2 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 3 , 2 )) b ( 2 , 2 ) = + detinv * ( a ( 1 , 1 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 3 , 1 )) b ( 3 , 2 ) = - detinv * ( a ( 1 , 1 ) * a ( 3 , 2 ) - a ( 1 , 2 ) * a ( 3 , 1 )) b ( 1 , 3 ) = + detinv * ( a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 2 )) b ( 2 , 3 ) = - detinv * ( a ( 1 , 1 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 1 )) b ( 3 , 3 ) = + detinv * ( a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 2 , 1 )) end function matinv_3x3","tags":"","loc":"proc/matinv_3x3.html"},{"title":"eigval_3x3 – MCTC-library","text":"public pure subroutine eigval_3x3(a, w) Calculates eigenvalues based on the trigonometric solution of A = pB + qI Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3,3) The symmetric input matrix real(kind=wp), intent(out) :: w (3) Contains eigenvalues on exit Source Code pure subroutine eigval_3x3 ( a , w ) !> The symmetric input matrix real ( wp ), intent ( in ) :: a ( 3 , 3 ) !> Contains eigenvalues on exit real ( wp ), intent ( out ) :: w ( 3 ) real ( wp ) :: q , p , r r = a ( 1 , 2 ) * a ( 1 , 2 ) + a ( 1 , 3 ) * a ( 1 , 3 ) + a ( 2 , 3 ) * a ( 2 , 3 ) q = ( a ( 1 , 1 ) + a ( 2 , 2 ) + a ( 3 , 3 )) / 3.0_wp w ( 1 ) = a ( 1 , 1 ) - q w ( 2 ) = a ( 2 , 2 ) - q w ( 3 ) = a ( 3 , 3 ) - q p = sqrt (( w ( 1 ) * w ( 1 ) + w ( 2 ) * w ( 2 ) + w ( 3 ) * w ( 3 ) + 2 * r ) / 6.0_wp ) r = ( w ( 1 ) * ( w ( 2 ) * w ( 3 ) - a ( 2 , 3 ) * a ( 2 , 3 )) & & - a ( 1 , 2 ) * ( a ( 1 , 2 ) * w ( 3 ) - a ( 2 , 3 ) * a ( 1 , 3 )) & & + a ( 1 , 3 ) * ( a ( 1 , 2 ) * a ( 2 , 3 ) - w ( 2 ) * a ( 1 , 3 ))) / ( p * p * p ) * 0.5_wp if ( r <= - 1.0_wp ) then r = 0.5_wp * twothirdpi else if ( r >= 1.0_wp ) then r = 0.0_wp else r = acos ( r ) / 3.0_wp end if w ( 3 ) = q + 2 * p * cos ( r ) w ( 1 ) = q + 2 * p * cos ( r + twothirdpi ) w ( 2 ) = 3 * q - w ( 1 ) - w ( 3 ) end subroutine eigval_3x3","tags":"","loc":"proc/eigval_3x3.html"},{"title":"eigvec_3x3 – MCTC-library","text":"public pure subroutine eigvec_3x3(a, w, q) Calculates eigenvector using an analytical method based on vector cross Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (3,3) real(kind=wp), intent(out) :: w (3) real(kind=wp), intent(out) :: q (3,3) Source Code pure subroutine eigvec_3x3 ( a , w , q ) real ( wp ), intent ( inout ) :: a ( 3 , 3 ) real ( wp ), intent ( out ) :: w ( 3 ) real ( wp ), intent ( out ) :: q ( 3 , 3 ) real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) real ( wp ) norm , n1 , n2 , n3 , precon integer :: i w ( 1 ) = max ( abs ( a ( 1 , 1 )), abs ( a ( 1 , 2 ))) w ( 2 ) = max ( abs ( a ( 1 , 3 )), abs ( a ( 2 , 2 ))) w ( 3 ) = max ( abs ( a ( 2 , 3 )), abs ( a ( 3 , 3 ))) precon = max ( w ( 1 ), max ( w ( 2 ), w ( 3 ))) ! null matrix if ( precon < eps ) then w ( 1 ) = 0.0_wp w ( 2 ) = 0.0_wp w ( 3 ) = 0.0_wp q ( 1 , 1 ) = 1.0_wp q ( 2 , 2 ) = 1.0_wp q ( 3 , 3 ) = 1.0_wp q ( 1 , 2 ) = 0.0_wp q ( 1 , 3 ) = 0.0_wp q ( 2 , 3 ) = 0.0_wp q ( 2 , 1 ) = 0.0_wp q ( 3 , 1 ) = 0.0_wp q ( 3 , 2 ) = 0.0_wp return end if norm = 1.0_wp / precon a ( 1 , 1 ) = a ( 1 , 1 ) * norm a ( 1 , 2 ) = a ( 1 , 2 ) * norm a ( 2 , 2 ) = a ( 2 , 2 ) * norm a ( 1 , 3 ) = a ( 1 , 3 ) * norm a ( 2 , 3 ) = a ( 2 , 3 ) * norm a ( 3 , 3 ) = a ( 3 , 3 ) * norm ! Calculate eigenvalues call eigval_3x3 ( a , w ) ! Compute first eigenvector a ( 1 , 1 ) = a ( 1 , 1 ) - w ( 1 ) a ( 2 , 2 ) = a ( 2 , 2 ) - w ( 1 ) a ( 3 , 3 ) = a ( 3 , 3 ) - w ( 1 ) q ( 1 , 1 ) = a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 2 ) q ( 2 , 1 ) = a ( 1 , 3 ) * a ( 1 , 2 ) - a ( 1 , 1 ) * a ( 2 , 3 ) q ( 3 , 1 ) = a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 1 , 2 ) q ( 1 , 2 ) = a ( 1 , 2 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 2 , 3 ) q ( 2 , 2 ) = a ( 1 , 3 ) * a ( 1 , 3 ) - a ( 1 , 1 ) * a ( 3 , 3 ) q ( 3 , 2 ) = a ( 1 , 1 ) * a ( 2 , 3 ) - a ( 1 , 2 ) * a ( 1 , 3 ) q ( 1 , 3 ) = a ( 2 , 2 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 2 , 3 ) q ( 2 , 3 ) = a ( 2 , 3 ) * a ( 1 , 3 ) - a ( 1 , 2 ) * a ( 3 , 3 ) q ( 3 , 3 ) = a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 2 , 2 ) * a ( 1 , 3 ) n1 = q ( 1 , 1 ) * q ( 1 , 1 ) + q ( 2 , 1 ) * q ( 2 , 1 ) + q ( 3 , 1 ) * q ( 3 , 1 ) n2 = q ( 1 , 2 ) * q ( 1 , 2 ) + q ( 2 , 2 ) * q ( 2 , 2 ) + q ( 3 , 2 ) * q ( 3 , 2 ) n3 = q ( 1 , 3 ) * q ( 1 , 3 ) + q ( 2 , 3 ) * q ( 2 , 3 ) + q ( 3 , 3 ) * q ( 3 , 3 ) norm = n1 i = 1 if ( n2 > norm ) then i = 2 norm = n1 end if if ( n3 > norm ) then i = 3 end if if ( i == 1 ) then norm = sqrt ( 1.0_wp / n1 ) q ( 1 , 1 ) = q ( 1 , 1 ) * norm q ( 2 , 1 ) = q ( 2 , 1 ) * norm q ( 3 , 1 ) = q ( 3 , 1 ) * norm else if ( i == 2 ) then norm = sqrt ( 1.0_wp / n2 ) q ( 1 , 1 ) = q ( 1 , 2 ) * norm q ( 2 , 1 ) = q ( 2 , 2 ) * norm q ( 3 , 1 ) = q ( 3 , 2 ) * norm else norm = sqrt ( 1.0_wp / n3 ) q ( 1 , 1 ) = q ( 1 , 3 ) * norm q ( 2 , 1 ) = q ( 2 , 3 ) * norm q ( 3 , 1 ) = q ( 3 , 3 ) * norm end if ! Robustly compute a right-hand orthonormal set (ev1, u, v) if ( abs ( q ( 1 , 1 )) > abs ( q ( 2 , 1 ))) then norm = sqrt ( 1.0_wp / ( q ( 1 , 1 ) * q ( 1 , 1 ) + q ( 3 , 1 ) * q ( 3 , 1 ))) q ( 1 , 2 ) = - q ( 3 , 1 ) * norm q ( 2 , 2 ) = 0.0_wp q ( 3 , 2 ) = + q ( 1 , 1 ) * norm else norm = sqrt ( 1.0_wp / ( q ( 2 , 1 ) * q ( 2 , 1 ) + q ( 3 , 1 ) * q ( 3 , 1 ))) q ( 1 , 2 ) = 0.0_wp q ( 2 , 2 ) = + q ( 3 , 1 ) * norm q ( 3 , 2 ) = - q ( 2 , 1 ) * norm end if q ( 1 , 3 ) = q ( 2 , 1 ) * q ( 3 , 2 ) - q ( 3 , 1 ) * q ( 2 , 2 ) q ( 2 , 3 ) = q ( 3 , 1 ) * q ( 1 , 2 ) - q ( 1 , 1 ) * q ( 3 , 2 ) q ( 3 , 3 ) = q ( 1 , 1 ) * q ( 2 , 2 ) - q ( 2 , 1 ) * q ( 1 , 2 ) ! Reset A a ( 1 , 1 ) = a ( 1 , 1 ) + w ( 1 ) a ( 2 , 2 ) = a ( 2 , 2 ) + w ( 1 ) a ( 3 , 3 ) = a ( 3 , 3 ) + w ( 1 ) ! A*U n1 = a ( 1 , 1 ) * q ( 1 , 2 ) + a ( 1 , 2 ) * q ( 2 , 2 ) + a ( 1 , 3 ) * q ( 3 , 2 ) n2 = a ( 1 , 2 ) * q ( 1 , 2 ) + a ( 2 , 2 ) * q ( 2 , 2 ) + a ( 2 , 3 ) * q ( 3 , 2 ) n3 = a ( 1 , 3 ) * q ( 1 , 2 ) + a ( 2 , 3 ) * q ( 2 , 2 ) + a ( 3 , 3 ) * q ( 3 , 2 ) ! A*V, note out of order computation a ( 3 , 3 ) = a ( 1 , 3 ) * q ( 1 , 3 ) + a ( 2 , 3 ) * q ( 2 , 3 ) + a ( 3 , 3 ) * q ( 3 , 3 ) a ( 1 , 3 ) = a ( 1 , 1 ) * q ( 1 , 3 ) + a ( 1 , 2 ) * q ( 2 , 3 ) + a ( 1 , 3 ) * q ( 3 , 3 ) a ( 2 , 3 ) = a ( 1 , 2 ) * q ( 1 , 3 ) + a ( 2 , 2 ) * q ( 2 , 3 ) + a ( 2 , 3 ) * q ( 3 , 3 ) ! UT*(A*U) - l2*E n1 = q ( 1 , 2 ) * n1 + q ( 2 , 2 ) * n2 + q ( 3 , 2 ) * n3 - w ( 2 ) ! UT*(A*V) n2 = q ( 1 , 2 ) * a ( 1 , 3 ) + q ( 2 , 2 ) * a ( 2 , 3 ) + q ( 3 , 2 ) * a ( 3 , 3 ) ! VT*(A*V) - l2*E n3 = q ( 1 , 3 ) * a ( 1 , 3 ) + q ( 2 , 3 ) * a ( 2 , 3 ) + q ( 3 , 3 ) * a ( 3 , 3 ) - w ( 2 ) if ( abs ( n1 ) >= abs ( n3 )) then norm = max ( abs ( n1 ), abs ( n2 )) if ( norm > eps ) then if ( abs ( n1 ) >= abs ( n2 )) then n2 = n2 / n1 n1 = sqrt ( 1.0_wp / ( 1.0_wp + n2 * n2 )) n2 = n2 * n1 else n1 = n1 / n2 n2 = sqrt ( 1.0_wp / ( 1.0_wp + n1 * n1 )) n1 = n1 * n2 end if q ( 1 , 2 ) = n2 * q ( 1 , 2 ) - n1 * q ( 1 , 3 ) q ( 2 , 2 ) = n2 * q ( 2 , 2 ) - n1 * q ( 2 , 3 ) q ( 3 , 2 ) = n2 * q ( 3 , 2 ) - n1 * q ( 3 , 3 ) end if else norm = max ( abs ( n3 ), abs ( n2 )) if ( norm > eps ) then if ( abs ( n3 ) >= abs ( n2 )) then n2 = n2 / n3 n3 = sqrt ( 1.0_wp / ( 1.0_wp + n2 * n2 )) n2 = n2 * n3 else n3 = n3 / n2 n2 = sqrt ( 1.0_wp / ( 1.0_wp + n3 * n3 )) n3 = n3 * n2 end if q ( 1 , 2 ) = n3 * q ( 1 , 2 ) - n2 * q ( 1 , 3 ) q ( 2 , 2 ) = n3 * q ( 2 , 2 ) - n2 * q ( 2 , 3 ) q ( 3 , 2 ) = n3 * q ( 3 , 2 ) - n2 * q ( 3 , 3 ) end if end if ! Calculate third eigenvector from cross product q ( 1 , 3 ) = q ( 2 , 1 ) * q ( 3 , 2 ) - q ( 3 , 1 ) * q ( 2 , 2 ) q ( 2 , 3 ) = q ( 3 , 1 ) * q ( 1 , 2 ) - q ( 1 , 1 ) * q ( 3 , 2 ) q ( 3 , 3 ) = q ( 1 , 1 ) * q ( 2 , 2 ) - q ( 2 , 1 ) * q ( 1 , 2 ) w ( 1 ) = w ( 1 ) * precon w ( 2 ) = w ( 2 ) * precon w ( 3 ) = w ( 3 ) * precon end subroutine eigvec_3x3","tags":"","loc":"proc/eigvec_3x3.html"},{"title":"read_aims – MCTC-library","text":"public  subroutine read_aims(mol, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: mol Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Source Code subroutine read_aims ( mol , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: mol !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: stat , pos , lnum , ilt , iat type ( token_type ) :: token character ( len = :), allocatable :: line real ( wp ) :: x , y , z character ( len = symbol_length ), allocatable :: sym (:) real ( wp ), allocatable :: xyz (:, :), abc (:, :), lattice (:, :) logical :: is_frac , periodic ( 3 ) logical , allocatable :: frac (:) allocate ( sym ( initial_size ), source = repeat ( ' ' , symbol_length )) allocate ( xyz ( 3 , initial_size ), source = 0.0_wp ) allocate ( abc ( 3 , initial_size ), source = 0.0_wp ) allocate ( frac ( initial_size ), source = . false .) iat = 0 ilt = 0 periodic (:) = . false . lnum = 0 stat = 0 do while ( stat == 0 ) call next_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) exit if ( len ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == \"#\" ) cycle call next_token ( line , pos , token ) select case ( line ( token % first : token % last )) case ( \"atom\" , \"atom_frac\" ) is_frac = token % last - token % first + 1 > 4 call read_next_token ( line , pos , token , x , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , y , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , z , stat ) if ( stat == 0 ) & call next_token ( line , pos , token ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read coordinates\" , & & line , token , filename ( unit ), lnum , \"expected real value\" ) exit end if if ( iat >= size ( sym )) call resize ( sym ) if ( iat >= size ( xyz , 2 )) call resize ( xyz ) if ( iat >= size ( abc , 2 )) call resize ( abc ) if ( iat >= size ( frac )) call resize ( frac ) iat = iat + 1 token % last = min ( token % last , token % first + symbol_length - 1 ) sym ( iat ) = line ( token % first : token % last ) if ( to_number ( sym ( iat )) == 0 ) then call io_error ( error , \"Cannot map symbol to atomic number\" , & & line , token , filename ( unit ), lnum , \"unknown element\" ) exit end if frac ( iat ) = is_frac if ( frac ( iat )) then abc (:, iat ) = [ x , y , z ] xyz (:, iat ) = 0.0_wp else abc (:, iat ) = 0.0_wp xyz (:, iat ) = [ x , y , z ] * aatoau end if case ( \"lattice_vector\" ) ilt = ilt + 1 if ( ilt > 3 ) then call io_error ( error , \"Too many lattice vectors\" , & & line , token , filename ( unit ), lnum , \"forth lattice vector found\" ) exit end if call read_next_token ( line , pos , token , x , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , y , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , z , stat ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read lattice vectors\" , & & line , token , filename ( unit ), lnum , \"expected real value\" ) exit end if if (. not . allocated ( lattice )) allocate ( lattice ( 3 , 3 ), source = 0.0_wp ) lattice (:, ilt ) = [ x , y , z ] * aatoau case default call io_error ( error , \"Unexpected keyword found\" , & & line , token , filename ( unit ), lnum , \"invalid in this context\" ) exit end select end do if ( allocated ( error )) return if ( iat == 0 ) then token = token_type ( 0 , 0 ) call io_error ( error , \"No atoms found\" , & & line , token , filename ( unit ), lnum + 1 , \"expected atom specification\" ) return end if if ( allocated ( lattice )) then xyz ( ilt + 1 : 3 , : iat ) = xyz ( ilt + 1 : 3 , : iat ) + abc ( ilt + 1 : 3 , : iat ) * aatoau xyz (: ilt , : iat ) = xyz (: ilt , : iat ) + matmul ( lattice (: ilt , : ilt ), abc (: ilt , : iat )) periodic (: ilt ) = . true . end if call new ( mol , sym (: iat ), xyz , lattice = lattice , periodic = periodic ) end subroutine read_aims","tags":"","loc":"proc/read_aims.html"},{"title":"is_unix – MCTC-library","text":"public  function is_unix() Try to determine if we run on Unix and probably can rely on POSIX compliance Arguments None Return Value logical Operating system seems to be Unix Source Code function is_unix () !> Operating system seems to be Unix logical :: is_unix character ( len = :), allocatable :: tmp is_unix = . not . is_windows () end function is_unix","tags":"","loc":"proc/is_unix.html"},{"title":"is_windows – MCTC-library","text":"public  function is_windows() Try to determine if we run on Windows and don’t have POSIX compliance around Arguments None Return Value logical Operating system seems to be Windows Source Code function is_windows () !> Operating system seems to be Windows logical :: is_windows character ( len = :), allocatable :: tmp is_windows = . false . call get_variable ( 'OS' , tmp ) if ( allocated ( tmp )) then is_windows = index ( tmp , 'Windows_NT' ) > 0 end if if (. not . is_windows ) then call get_variable ( 'OSTYPE' , tmp ) if ( allocated ( tmp )) then is_windows = index ( tmp , 'win' ) > 0 . or . index ( tmp , 'msys' ) > 0 end if end if end function is_windows","tags":"","loc":"proc/is_windows.html"},{"title":"get_argument – MCTC-library","text":"public  subroutine get_argument(idx, arg) Obtain the command line argument at a given index Arguments Type Intent Optional Attributes Name integer, intent(in) :: idx Index of command line argument, range [0:command_argument_count()] character(len=:), intent(out), allocatable :: arg Command line argument Source Code subroutine get_argument ( idx , arg ) !> Index of command line argument, range [0:command_argument_count()] integer , intent ( in ) :: idx !> Command line argument character ( len = :), allocatable , intent ( out ) :: arg integer :: length , stat call get_command_argument ( idx , length = length , status = stat ) if ( stat /= 0 ) then return endif allocate ( character ( len = length ) :: arg , stat = stat ) if ( stat /= 0 ) then return endif if ( length > 0 ) then call get_command_argument ( idx , arg , status = stat ) if ( stat /= 0 ) then deallocate ( arg ) return end if end if end subroutine get_argument","tags":"","loc":"proc/get_argument.html"},{"title":"get_variable – MCTC-library","text":"public  subroutine get_variable(var, val) Obtain the value of an environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var Name of variable character(len=:), intent(out), allocatable :: val Value of variable Source Code subroutine get_variable ( var , val ) !> Name of variable character ( len =* ), intent ( in ) :: var !> Value of variable character ( len = :), allocatable , intent ( out ) :: val integer :: length , stat call get_environment_variable ( var , length = length , status = stat ) if ( stat /= 0 ) then return endif allocate ( character ( len = length ) :: val , stat = stat ) if ( stat /= 0 ) then return endif if ( length > 0 ) then call get_environment_variable ( var , val , status = stat ) if ( stat /= 0 ) then deallocate ( val ) return end if end if end subroutine get_variable","tags":"","loc":"proc/get_variable.html"},{"title":"read_genformat – MCTC-library","text":"public  subroutine read_genformat(mol, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: mol Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Source Code subroutine read_genformat ( mol , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: mol !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: line integer :: natoms , nspecies , iatom , dummy , isp , ilat , stat , istart , iend logical :: cartesian , periodic ( 3 ) real ( wp ) :: coord ( 3 ), origin ( 3 ) character ( len = 1 ) :: variant type ( token_type ) :: token character ( len = symbol_length ), allocatable :: species (:), sym (:) real ( wp ), allocatable :: xyz (:, :), abc (:, :), lattice (:, :) type ( structure_info ) :: info integer :: pos , lnum lnum = 0 call advance_line ( unit , line , pos , lnum , stat ) call read_next_token ( line , pos , token , natoms , stat ) if ( stat /= 0 . or . natoms < 1 ) then call io_error ( error , \"Could not read number of atoms\" , & & line , token , filename ( unit ), lnum , \"expected integer value\" ) return end if allocate ( species ( natoms )) allocate ( sym ( natoms )) allocate ( xyz ( 3 , natoms )) allocate ( abc ( 3 , natoms )) call next_token ( line , pos , token ) select case ( line ( token % first : token % last )) case ( 'c' , 'C' ) cartesian = . true . periodic = . false . case ( 's' , 'S' ) cartesian = . true . periodic = . true . allocate ( lattice ( 3 , 3 ), source = 0.0_wp ) case ( 'f' , 'F' ) cartesian = . false . periodic = . true . allocate ( lattice ( 3 , 3 ), source = 0.0_wp ) case ( 'h' , 'H' ) cartesian = . true . periodic = [. false ., . false ., . true .] allocate ( lattice ( 3 , 1 ), source = 0.0_wp ) case default call io_error ( error , \"Invalid input version found\" , & & line , token , filename ( unit ), lnum , \"unknown identifier\" ) return end select call advance_line ( unit , line , pos , lnum , stat ) isp = 0 do while ( pos < len ( line )) call next_token ( line , pos , token ) isp = isp + 1 token % last = min ( token % last , token % first + symbol_length - 1 ) species ( isp ) = line ( token % first : token % last ) if ( to_number ( species ( isp )) == 0 ) then call io_error ( error , \"Cannot map symbol to atomic number\" , & & line , token , filename ( unit ), lnum , \"unknown element\" ) return end if end do nspecies = isp do iatom = 1 , natoms token = token_type ( 0 , 0 ) call advance_line ( unit , line , pos , lnum , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , dummy , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , isp , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 1 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 2 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 3 ), stat ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read coordinates\" , & & line , token , filename ( unit ), lnum , \"unexpected value\" ) return end if sym ( iatom ) = species ( isp ) if ( cartesian ) then xyz (:, iatom ) = coord * aatoau else abc (:, iatom ) = coord end if end do if ( any ( periodic )) then call advance_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) then call io_error ( error , \"Unexpected end of file\" , & & line , token_type ( 0 , 0 ), filename ( unit ), lnum , \"missing lattice information\" ) return end if if ( stat == 0 ) & call read_next_token ( line , pos , token , origin ( 1 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , origin ( 2 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , origin ( 3 ), stat ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read origin\" , & & line , token , filename ( unit ), lnum , \"expected real value\" ) return end if end if if ( all ( periodic )) then do ilat = 1 , 3 call advance_line ( unit , line , pos , lnum , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 1 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 2 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 3 ), stat ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read lattice vector\" , & & line , token , filename ( unit ), lnum , \"expected real value\" ) return end if lattice (:, ilat ) = coord * aatoau end do if (. not . cartesian ) then xyz = matmul ( lattice , abc ) end if end if if ( count ( periodic ) == 1 ) then call advance_line ( unit , line , pos , lnum , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 1 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 2 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 3 ), stat ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read lattice vector\" , & & line , token , filename ( unit ), lnum , \"expected real value\" ) return end if if ( coord ( 3 ) < 1 ) then call io_error ( error , \"Invalid helical axis rotation order\" , & & line , token , filename ( unit ), lnum , \"expected positive value\" ) return end if ! Store helical axis in *first* lattice vector, however it is not an actual ! lattice vector as on would expect but a screw axis lattice (:, 1 ) = [ coord ( 1 ) * aatoau , coord ( 2 ) * pi / 18 0.0_wp , coord ( 3 )] end if if ( any ( periodic )) then xyz (:, :) = xyz - spread ( origin , 2 , natoms ) end if info = structure_info ( cartesian = cartesian ) call new ( mol , sym , xyz , lattice = lattice , periodic = periodic , info = info ) contains subroutine advance_line ( unit , line , pos , num , stat ) integer , intent ( in ) :: unit integer , intent ( out ) :: pos integer , intent ( inout ) :: num character ( len = :), allocatable , intent ( out ) :: line integer , intent ( out ) :: stat integer :: ihash stat = 0 do while ( stat == 0 ) call next_line ( unit , line , pos , num , stat ) ihash = index ( line , '#' ) if ( ihash > 0 ) line = line (: ihash - 1 ) if ( len_trim ( line ) > 0 ) exit end do line = trim ( adjustl ( line )) end subroutine advance_line end subroutine read_genformat","tags":"","loc":"proc/read_genformat.html"},{"title":"write_genformat – MCTC-library","text":"public  subroutine write_genformat(mol, unit) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: mol integer, intent(in) :: unit Source Code subroutine write_genformat ( mol , unit ) class ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer :: iat , izp real ( wp ), parameter :: zero3 ( 3 ) = 0.0_wp real ( wp ), allocatable :: inv_lat (:, :) real ( wp ), allocatable :: abc (:, :) logical :: helical helical = . false . write ( unit , '(i0, 1x)' , advance = 'no' ) mol % nat if (. not . any ( mol % periodic )) then write ( unit , '(\"C\")' ) ! cluster else helical = count ( mol % periodic ) == 1 . and . mol % periodic ( 3 ) . and . size ( mol % lattice , 2 ) == 1 if ( helical ) then write ( unit , '(\"H\")' ) ! helical else if ( mol % info % cartesian ) then write ( unit , '(\"S\")' ) ! supercell else write ( unit , '(\"F\")' ) ! fractional endif end if endif do izp = 1 , mol % nid write ( unit , '(1x, a)' , advance = 'no' ) trim ( mol % sym ( izp )) enddo write ( unit , '(a)' ) if (. not . any ( mol % periodic ) . or . mol % info % cartesian ) then ! now write the cartesian coordinates do iat = 1 , mol % nat write ( unit , '(2i5, 3es24.14)' ) iat , mol % id ( iat ), mol % xyz (:, iat ) * autoaa enddo else inv_lat = matinv_3x3 ( mol % lattice ) abc = matmul ( inv_lat , mol % xyz ) ! now write the fractional coordinates do iat = 1 , mol % nat write ( unit , '(2i5, 3es24.15)' ) iat , mol % id ( iat ), abc (:, iat ) enddo endif if ( any ( mol % periodic )) then write ( unit , '(3f20.14)' ) zero3 ! write the lattice parameters if ( helical ) then write ( unit , '(2f20.14,1x,i0)' ) & & mol % lattice ( 1 , 1 ) * autoaa , mol % lattice ( 2 , 1 ) * 18 0.0_wp / pi , nint ( mol % lattice ( 3 , 1 )) else write ( unit , '(3f20.14)' ) mol % lattice (:, :) * autoaa end if endif end subroutine write_genformat","tags":"","loc":"proc/write_genformat.html"},{"title":"get_filetype – MCTC-library","text":"public elemental function get_filetype(file) result(ftype) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file Name of the file Return Value integer File type from extension Source Code elemental function get_filetype ( file ) result ( ftype ) !> Name of the file character ( len =* ), intent ( in ) :: file !> File type from extension integer :: ftype integer :: iext , isep ftype = filetype % unknown iext = index ( file , '.' , back = . true .) isep = scan ( file , '\\/' , back = . true .) if ( iext > isep . and . iext > 0 ) then select case ( to_lower ( file ( iext + 1 :))) case ( 'coord' , 'tmol' ) ftype = filetype % tmol case ( 'xyz' , 'log' ) ftype = filetype % xyz case ( 'mol' ) ftype = filetype % molfile case ( 'sdf' ) ftype = filetype % sdf case ( 'poscar' , 'contcar' , 'vasp' ) ftype = filetype % vasp case ( 'pdb' ) ftype = filetype % pdb case ( 'gen' ) ftype = filetype % gen case ( 'ein' ) ftype = filetype % gaussian case ( 'json' ) ftype = filetype % qcschema case ( 'cjson' ) ftype = filetype % cjson case ( 'qchem' ) ftype = filetype % qchem end select if ( ftype /= filetype % unknown ) return else iext = len ( file ) + 1 end if if ( iext > isep ) then if ( file ( isep + 1 :) == 'geometry.in' ) then ftype = filetype % aims end if select case ( to_lower ( file ( isep + 1 : iext - 1 ))) case ( 'geometry.in' ) ftype = filetype % aims case ( 'coord' ) ftype = filetype % tmol case ( 'poscar' , 'contcar' ) ftype = filetype % vasp end select end if end function get_filetype","tags":"","loc":"proc/get_filetype.html"},{"title":"write_pdb – MCTC-library","text":"public  subroutine write_pdb(mol, unit, number) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(in) :: mol integer, intent(in) :: unit integer, intent(in), optional :: number Source Code subroutine write_pdb ( mol , unit , number ) type ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer , intent ( in ), optional :: number character ( len = 6 ) :: w1 character ( len = 4 ) :: sym character ( len = 2 ) :: a_charge character ( len = 1 ) :: last_chain logical :: last_het integer :: offset , iat , jat real ( wp ) :: xyz ( 3 ) character ( len =* ), parameter :: pdb_format = & & '(a6,i5,1x,a4,a1,a3,1x,a1,i4,a1,3x,3f8.3,2f6.2,6x,a4,a2,a2)' if ( present ( number )) write ( unit , '(\"MODEL \",4x,i4)' ) number if ( allocated ( mol % pdb )) then offset = 0 last_chain = mol % pdb ( 1 )% chains last_het = mol % pdb ( 1 )% het do iat = 1 , mol % nat ! handle the terminator if ( mol % pdb ( iat )% het . neqv . last_het ) then write ( unit , '(\"TER   \",i5,6x,a3,1x,a1,i4)' ) iat + offset , & & mol % pdb ( iat - 1 )% residue , last_chain , mol % pdb ( iat )% residue_number last_het = . not . last_het last_chain = mol % pdb ( iat )% chains offset = offset + 1 else if ( mol % pdb ( iat )% chains /= last_chain ) then write ( unit , '(\"TER   \",i5,6x,a3,1x,a1,i4)' ) iat + offset , & & mol % pdb ( iat - 1 )% residue , last_chain , mol % pdb ( iat )% residue_number last_chain = mol % pdb ( iat )% chains offset = offset + 1 endif jat = iat + offset if ( mol % pdb ( iat )% het ) then w1 = \"HETATM\" else w1 = \"ATOM  \" endif sym = adjustr ( mol % sym ( mol % id ( iat ))( 1 : 2 )) xyz = mol % xyz (:, iat ) * autoaa if ( mol % pdb ( iat )% charge < 0 ) then write ( a_charge , '(i1,\"-\")' ) abs ( mol % pdb ( iat )% charge ) else if ( mol % pdb ( iat )% charge > 0 ) then write ( a_charge , '(i1,\"+\")' ) abs ( mol % pdb ( iat )% charge ) else a_charge = '  ' endif write ( unit , pdb_format ) & & w1 , jat , mol % pdb ( iat )% name , mol % pdb ( iat )% loc , & & mol % pdb ( iat )% residue , mol % pdb ( iat )% chains , mol % pdb ( iat )% residue_number , & & mol % pdb ( iat )% code , xyz , 1.0_wp , 0.0_wp , mol % pdb ( iat )% segid , & & sym , a_charge enddo else do iat = 1 , mol % nat w1 = \"HETATM\" sym = adjustr ( mol % sym ( mol % id ( iat ))( 1 : 2 )) xyz = mol % xyz (:, iat ) * autoaa a_charge = '  ' write ( unit , pdb_format ) & & w1 , iat , sym , \" \" , & & \"UNK\" , \"A\" , 1 , \" \" , xyz , 1.0_wp , 0.0_wp , \"    \" , & & sym , \"  \" enddo end if if ( present ( number )) then write ( unit , '(\"ENDMDL\")' ) else write ( unit , '(\"END\")' ) endif end subroutine write_pdb","tags":"","loc":"proc/write_pdb.html"},{"title":"read_pdb – MCTC-library","text":"public  subroutine read_pdb(self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Source Code subroutine read_pdb ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer , parameter :: p_initial_size = 1000 ! this is going to be a protein integer :: iatom , jatom , iresidue , try , stat , atom_type , pos , lnum real ( wp ) :: occ , temp , coords ( 3 ) real ( wp ), allocatable :: xyz (:,:) type ( token_type ) :: token character ( len = 4 ) :: a_charge character ( len = :), allocatable :: line character ( len = symbol_length ), allocatable :: sym (:) type ( pdb_data ), allocatable :: pdb (:) allocate ( sym ( p_initial_size ), source = repeat ( ' ' , symbol_length )) allocate ( xyz ( 3 , p_initial_size ), source = 0.0_wp ) allocate ( pdb ( p_initial_size ), source = pdb_data ()) iatom = 0 iresidue = 0 stat = 0 do while ( stat == 0 ) call next_line ( unit , line , pos , lnum , stat ) if ( index ( line , 'END' ) == 1 ) exit if ( index ( line , 'ATOM' ) == 1 . or . index ( line , 'HETATM' ) == 1 ) then if ( iatom >= size ( xyz , 2 )) call resize ( xyz ) if ( iatom >= size ( sym )) call resize ( sym ) if ( iatom >= size ( pdb )) call resize ( pdb ) iatom = iatom + 1 pdb ( iatom )% het = index ( line , 'HETATM' ) == 1 if ( len ( line ) >= 78 ) then ! a4: 13:16, a1: 17:17, a3: 18:20, a1: 22:22 ! a1: 27:27, a4: 73:76, a2: 77:78, a2: 79:80 pdb ( iatom )% name = line ( 13 : 16 ) pdb ( iatom )% loc = line ( 17 : 17 ) pdb ( iatom )% residue = line ( 18 : 20 ) pdb ( iatom )% chains = line ( 22 : 22 ) pdb ( iatom )% code = line ( 27 : 27 ) pdb ( iatom )% segid = line ( 72 : 74 ) sym ( iatom ) = line ( 77 : 78 ) else token = token_type ( len ( line ) + 1 , len ( line ) + 1 ) call io_error ( error , \"Too few entries provided in record\" , & & line , token , filename ( unit ), lnum , \"record too short\" ) return end if if ( len ( line ) >= 80 ) then a_charge = line ( 79 : 80 ) else a_charge = \"\" end if if ( stat == 0 ) then ! i5: 7-11 token = token_type ( 7 , 11 ) call read_token ( line , token , jatom , stat ) end if if ( stat == 0 ) then ! i4: 23-26 token = token_type ( 23 , 26 ) call read_token ( line , token , pdb ( iatom )% residue_number , stat ) end if if ( stat == 0 ) then ! f8: 31-38 token = token_type ( 31 , 38 ) call read_token ( line , token , coords ( 1 ), stat ) end if if ( stat == 0 ) then ! f8: 39-46 token = token_type ( 39 , 46 ) call read_token ( line , token , coords ( 2 ), stat ) end if if ( stat == 0 ) then ! f8: 47-54 token = token_type ( 47 , 54 ) call read_token ( line , token , coords ( 3 ), stat ) end if if ( stat == 0 ) then ! f6: 55-60 token = token_type ( 55 , 60 ) call read_token ( line , token , occ , stat ) end if if ( stat == 0 ) then ! f6: 61-66 token = token_type ( 60 , 66 ) call read_token ( line , token , temp , stat ) end if if ( stat /= 0 ) then call io_error ( error , \"Cannot read coordinates from record\" , & & line , token , filename ( unit ), lnum , \"unexpected value\" ) return end if xyz (:, iatom ) = coords * aatoau atom_type = to_number ( sym ( iatom )) if ( atom_type == 0 ) then try = scan ( pdb ( iatom )% name , 'HCNOSPF' ) if ( try > 0 ) sym ( iatom ) = pdb ( iatom )% name ( try : try ) // ' ' pdb ( iatom )% charge = 0 else read ( a_charge ( 1 : 1 ), * , iostat = stat ) pdb ( iatom )% charge if ( stat /= 0 ) then stat = 0 pdb ( iatom )% charge = 0 else if ( a_charge ( 2 : 2 ) == '-' ) pdb ( iatom )% charge = - pdb ( iatom )% charge end if end if if ( to_number ( sym ( iatom )) == 0 ) then call io_error ( error , \"Cannot map symbol to atomic number\" , & & line , token_type ( 77 , 78 ), filename ( unit ), lnum , \"unknown element\" ) return end if end if end do call new ( self , sym (: iatom ), xyz (:, : iatom )) self % pdb = pdb (: iatom ) self % charge = sum ( pdb (: iatom )% charge ) end subroutine read_pdb","tags":"","loc":"proc/read_pdb.html"},{"title":"write_molfile – MCTC-library","text":"public  subroutine write_molfile(self, unit, comment_line) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: comment_line Source Code subroutine write_molfile ( self , unit , comment_line ) class ( structure_type ), intent ( in ) :: self integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: comment_line integer , parameter :: list4 ( 4 ) = 0 integer :: iatom , ibond , iatoms ( 3 ), list12 ( 12 ) logical :: has_sdf_data integer , parameter :: charge_to_ccc ( - 3 : 3 ) = [ 7 , 6 , 5 , 0 , 3 , 2 , 1 ] character ( len = 8 ) :: date character ( len = 10 ) :: time call date_and_time ( date , time ) if ( present ( comment_line )) then write ( unit , '(a)' ) comment_line else if ( allocated ( self % comment )) then write ( unit , '(a)' ) self % comment else write ( unit , '(a)' ) end if end if write ( unit , '(2x, 3x, 5x, 3a2, a4, \"3D\")' ) & & date ( 5 : 6 ), date ( 7 : 8 ), date ( 3 : 4 ), time (: 4 ) write ( unit , '(a)' ) write ( unit , '(3i3, 3x, 2i3, 12x, i3, 1x, a5)' ) & & self % nat , self % nbd , 0 , 0 , 0 , 999 , 'V2000' has_sdf_data = allocated ( self % sdf ) do iatom = 1 , self % nat if ( has_sdf_data ) then list12 = [ self % sdf ( iatom )% isotope , 0 , 0 , 0 , 0 , self % sdf ( iatom )% valence , & & 0 , 0 , 0 , 0 , 0 , 0 ] else list12 = 0 endif write ( unit , '(3f10.4, 1x, a3, i2, 11i3)' ) & & self % xyz (:, iatom ) * autoaa , self % sym ( self % id ( iatom )), list12 enddo if ( self % nbd > 0 ) then if ( size ( self % bond , 1 ) > 2 ) then do ibond = 1 , self % nbd write ( unit , '(7i3)' ) self % bond (: 3 , ibond ), list4 end do else do ibond = 1 , self % nbd write ( unit , '(7i3)' ) self % bond (: 2 , ibond ), 1 , list4 end do end if end if if ( has_sdf_data ) then if ( sum ( self % sdf % charge ) /= nint ( self % charge )) then write ( unit , '(a, *(i3, 1x, i3, 1x, i3))' ) \"M  CHG\" , 1 , 1 , nint ( self % charge ) else do iatom = 1 , self % nat if ( self % sdf ( iatom )% charge /= 0 ) then write ( unit , '(a, *(i3, 1x, i3, 1x, i3))' ) & & \"M  CHG\" , 1 , iatom , self % sdf ( iatom )% charge end if end do end if else if ( nint ( self % charge ) /= 0 ) then write ( unit , '(a, *(i3, 1x, i3, 1x, i3))' ) \"M  CHG\" , 1 , 1 , nint ( self % charge ) end if end if write ( unit , '(a)' ) \"M  END\" end subroutine write_molfile","tags":"","loc":"proc/write_molfile.html"},{"title":"write_sdf – MCTC-library","text":"public  subroutine write_sdf(self, unit, energy, gnorm) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self integer, intent(in) :: unit real(kind=wp), intent(in), optional :: energy real(kind=wp), intent(in), optional :: gnorm Source Code subroutine write_sdf ( self , unit , energy , gnorm ) class ( structure_type ), intent ( in ) :: self integer , intent ( in ) :: unit real ( wp ), intent ( in ), optional :: energy real ( wp ), intent ( in ), optional :: gnorm !type(tb_buffer) :: sd_values character ( len = :), allocatable :: line character ( len =* ), parameter :: sd_format = & & '(\"> <\", a, \">\", /, f20.12, /)' call write_molfile ( self , unit ) !   sd_values = self%info !   call sd_values%reset !   do while(sd_values%next()) !      call sd_values%getline(line) !      write(unit, '(a)') line !   enddo if ( present ( energy )) then write ( unit , sd_format ) \"total energy / Eh\" , energy endif if ( present ( gnorm )) then write ( unit , sd_format ) \"gradient norm / Eh/a0\" , gnorm endif write ( unit , '(\"\")' ) end subroutine write_sdf","tags":"","loc":"proc/write_sdf.html"},{"title":"read_molfile – MCTC-library","text":"public  subroutine read_molfile(self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Source Code subroutine read_molfile ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: line character ( len = :), allocatable :: comment integer :: stat , lnum , pos integer :: number_of_atoms , number_of_bonds integer :: list7 ( 7 ), list12 ( 12 ) real ( wp ) :: x , y , z character ( len = 2 ) :: sdf_dim logical :: two_dim , v3k type ( token_type ) :: token lnum = 0 two_dim = . false . call next_line ( unit , comment , pos , lnum , stat ) call next_line ( unit , line , pos , lnum , stat ) read ( line , '(20x, a2)' , iostat = stat ) sdf_dim if ( stat == 0 ) then two_dim = sdf_dim == '2D' . or . sdf_dim == '2d' end if call next_line ( unit , line , pos , lnum , stat ) call next_line ( unit , line , pos , lnum , stat ) if ( stat == 0 ) then token = token_type ( 1 , 3 ) call read_token ( line , token , number_of_atoms , stat ) end if if ( stat == 0 ) then token = token_type ( 4 , 6 ) call read_token ( line , token , number_of_bonds , stat ) end if if ( stat /= 0 ) then call io_error ( error , \"Cannot read header of molfile\" , & & line , token , filename ( unit ), lnum , \"expected integer value\" ) return end if token = token_type ( 35 , 39 ) stat = 1 if ( len ( line ) >= 39 ) then v3k = line ( 35 : 39 ) == 'V3000' if ( line ( 35 : 39 ) == 'V2000' . or . v3k ) stat = 0 end if if ( stat /= 0 ) then call io_error ( error , \"Format version not supported\" , & & line , token , filename ( unit ), lnum , \"invalid format version\" ) return end if if (. not . v3k . and . number_of_atoms < 1 ) then call io_error ( error , \"Invalid number of atoms\" , & & line , token_type ( 1 , 3 ), filename ( unit ), lnum , \"expected positive integer\" ) return end if if ( v3k ) then call read_molfile_v3k ( self , unit , error ) else call read_molfile_v2k ( self , unit , number_of_atoms , number_of_bonds , error ) end if if ( allocated ( error )) return ! Attach additional meta data self % info % two_dimensional = two_dim if ( len ( comment ) > 0 ) self % comment = comment end subroutine read_molfile","tags":"","loc":"proc/read_molfile.html"},{"title":"read_sdf – MCTC-library","text":"public  subroutine read_sdf(self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Source Code subroutine read_sdf ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: line integer :: stat , lnum , pos call read_molfile ( self , unit , error ) if ( allocated ( error )) return lnum = 0 stat = 0 do while ( stat == 0 ) call next_line ( unit , line , pos , lnum , stat ) if ( index ( line , '' ) == 1 ) exit end do if ( stat /= 0 ) then call fatal_error ( error , \"Failed while reading SDF key-value pairs\" ) return end if end subroutine read_sdf","tags":"","loc":"proc/read_sdf.html"},{"title":"get_structure_reader – MCTC-library","text":"public  subroutine get_structure_reader(reader, ftype) Retrieve reader for corresponding file type Arguments Type Intent Optional Attributes Name procedure( structure_reader ), intent(out), pointer :: reader Reader for the specified file type integer, intent(in) :: ftype File type to read Source Code subroutine get_structure_reader ( reader , ftype ) !> Reader for the specified file type procedure ( structure_reader ), pointer , intent ( out ) :: reader !> File type to read integer , intent ( in ) :: ftype nullify ( reader ) select case ( ftype ) case ( filetype % xyz ) reader => read_xyz case ( filetype % molfile ) reader => read_molfile case ( filetype % qcschema ) reader => read_qcschema case ( filetype % cjson ) reader => read_cjson case ( filetype % pdb ) reader => read_pdb case ( filetype % gen ) reader => read_genformat case ( filetype % sdf ) reader => read_sdf case ( filetype % vasp ) reader => read_vasp case ( filetype % tmol ) reader => read_coord case ( filetype % gaussian ) reader => read_gaussian_external case ( filetype % aims ) reader => read_aims case ( filetype % qchem ) reader => read_qchem end select end subroutine get_structure_reader","tags":"","loc":"proc/get_structure_reader.html"},{"title":"read_structure – MCTC-library","text":"public interface read_structure Module Procedures private  subroutine read_structure_from_file(self, file, error, format) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data character(len=*), intent(in) :: file Name of the file to read type( error_type ), intent(out), allocatable :: error Error handling integer, intent(in), optional :: format File type format hint private  subroutine read_structure_from_unit(self, unit, ftype, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle integer, intent(in) :: ftype File type to read type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"interface/read_structure.html"},{"title":"dirname – MCTC-library","text":"function dirname(filename) Extract dirname from path Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value character(len=:), allocatable Source Code function dirname ( filename ) character ( len =* ), intent ( in ) :: filename character ( len = :), allocatable :: dirname dirname = filename ( 1 : scan ( filename , \"/\\\", back=.true.)) if (len_trim(dirname) == 0) dirname = \" . \" end function dirname","tags":"","loc":"proc/dirname.html"},{"title":"exists – MCTC-library","text":"function exists(filename) test if pathname already exists Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical Source Code function exists ( filename ) character ( len =* ), intent ( in ) :: filename logical :: exists inquire ( file = filename , exist = exists ) end function exists","tags":"","loc":"proc/exists.html"},{"title":"join – MCTC-library","text":"function join(a1, a2) result(path) Uses mctc_env_system Construct path by joining strings with os file separator Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a1 character(len=*), intent(in) :: a2 Return Value character(len=:), allocatable Source Code function join ( a1 , a2 ) result ( path ) use mctc_env_system , only : is_windows character ( len =* ), intent ( in ) :: a1 , a2 character ( len = :), allocatable :: path character :: filesep if ( is_windows ()) then filesep = '\\' else filesep = ' / ' end if path = a1 // filesep // a2 end function join","tags":"","loc":"proc/join.html"},{"title":"get_arguments – MCTC-library","text":"subroutine get_arguments(input, input_format, output, output_format, normalize, template, template_format, read_dot_files, error) Arguments Type Intent Optional Attributes Name character(len=:), allocatable :: input Input file name integer, intent(out), allocatable :: input_format Input file format character(len=:), allocatable :: output Output file name integer, intent(out), allocatable :: output_format Output file format logical, intent(out) :: normalize Normalize element symbols character(len=:), allocatable :: template Template file name integer, intent(out), allocatable :: template_format Template file format logical, intent(out) :: read_dot_files Read information from .CHRG and .UHF files type( error_type ), intent(out), allocatable :: error Error handling Source Code subroutine get_arguments ( input , input_format , output , output_format , normalize , & & template , template_format , read_dot_files , error ) !> Input file name character ( len = :), allocatable :: input !> Input file format integer , allocatable , intent ( out ) :: input_format !> Output file name character ( len = :), allocatable :: output !> Output file format integer , allocatable , intent ( out ) :: output_format !> Template file name character ( len = :), allocatable :: template !> Template file format integer , allocatable , intent ( out ) :: template_format !> Normalize element symbols logical , intent ( out ) :: normalize !> Read information from .CHRG and .UHF files logical , intent ( out ) :: read_dot_files !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: iarg , narg character ( len = :), allocatable :: arg normalize = . false . read_dot_files = . true . iarg = 0 narg = command_argument_count () do while ( iarg < narg ) iarg = iarg + 1 call get_argument ( iarg , arg ) select case ( arg ) case ( \"--help\" ) call help ( output_unit ) stop case ( \"--version\" ) call version ( output_unit ) stop case default if (. not . allocated ( input )) then call move_alloc ( arg , input ) cycle end if if (. not . allocated ( output )) then call move_alloc ( arg , output ) cycle end if call fatal_error ( error , \"Too many positional arguments present\" ) exit case ( \"-i\" , \"--input\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for input format\" ) exit end if if ( index ( arg , \".\" ) == 0 ) arg = \".\" // arg input_format = get_filetype ( arg ) case ( \"-o\" , \"--output\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for output format\" ) exit end if output_format = get_filetype ( \".\" // arg ) case ( \"--normalize\" ) normalize = . true . case ( \"--template\" ) iarg = iarg + 1 call get_argument ( iarg , template ) if (. not . allocated ( template )) then call fatal_error ( error , \"Missing argument for template file\" ) exit end if case ( \"--template-format\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for template format\" ) exit end if template_format = get_filetype ( \".\" // arg ) case ( \"--ignore-dot-files\" ) read_dot_files = . false . end select end do if (. not .( allocated ( input ). and .( allocated ( output )))) then if (. not . allocated ( error )) then call help ( output_unit ) error stop end if end if end subroutine get_arguments","tags":"","loc":"proc/get_arguments.html"},{"title":"help – MCTC-library","text":"subroutine help(unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Source Code subroutine help ( unit ) integer , intent ( in ) :: unit write ( unit , '(a, *(1x, a))' ) & \"Usage: \" // prog_name // \" [options] <input> <output>\" write ( unit , '(a)' ) & \"\" , & \"Read structure from input file and writes it to output file.\" , & \"The format is determined by the file extension or the format hint\" , & \"\" write ( unit , '(2x, a, t25, a)' ) & \"-i, --input <format>\" , \"Hint for the format of the input file\" , & \"-o, --output <format>\" , \"Hint for the format of the output file\" , & \"--normalize\" , \"Normalize all element symbols to capitalized format\" , & \"--template <file>\" , \"File to use as template to fill in meta data\" , & \"\" , \"(useful to add back SDF or PDB annotions)\" , & \"--template-format <format>\" , \"\" , \"\" , \"Hint for the format of the template file\" , & \"--ignore-dot-files\" , \"Do not read charge and spin from .CHRG and .UHF files\" , & \"--version\" , \"Print program version and exit\" , & \"--help\" , \"Show this help message\" write ( unit , '(a)' ) end subroutine help","tags":"","loc":"proc/help.html"},{"title":"read_file – MCTC-library","text":"subroutine read_file(filename, val, error) Uses mctc_io_utils Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer, intent(out) :: val type( error_type ), intent(out), allocatable :: error Source Code subroutine read_file ( filename , val , error ) use mctc_io_utils , only : next_line , read_next_token , io_error , token_type character ( len =* ), intent ( in ) :: filename integer , intent ( out ) :: val type ( error_type ), allocatable , intent ( out ) :: error integer :: io , stat , lnum , pos type ( token_type ) :: token character ( len = :), allocatable :: line lnum = 0 open ( file = filename , newunit = io , status = 'old' , iostat = stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Error: Could not open file '\" // filename // \"'\" ) return end if call next_line ( io , line , pos , lnum , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , val , stat ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read value from file\" , line , token , & filename , lnum , \"expected integer value\" ) return end if close ( io , iostat = stat ) end subroutine read_file","tags":"","loc":"proc/read_file.html"},{"title":"version – MCTC-library","text":"subroutine version(unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Source Code subroutine version ( unit ) integer , intent ( in ) :: unit character ( len = :), allocatable :: version_string call get_mctc_version ( string = version_string ) write ( unit , '(a, *(1x, a))' ) & & prog_name , \"version\" , version_string end subroutine version","tags":"","loc":"proc/version.html"},{"title":"mctc_env_testing – MCTC-library","text":"Provides a light-weight testing framework for usage in projects depending on\n the tool chain library. Testsuites are defined by a collect_interface returning a set of unittest_type objects. To create a new test use the new_unittest constructor, which requires a test identifier and a procedure with a test_interface compatible signature. The error status is communicated\n by the allocation status of an error_type . The necessary boilerplate code to setup the test entry point is just program tester use , intrinsic :: iso_fortran_env , only : error_unit use mctc_env_testing , only : run_testsuite , new_testsuite , testsuite_type use test_suite1 , only : collect_suite1 use test_suite2 , only : collect_suite2 implicit none integer :: stat , ii type ( testsuite_type ), allocatable :: testsuites (:) character ( len =* ), parameter :: fmt = '(\"#\", *(1x, a))' stat = 0 testsuites = [ & & new_testsuite ( \"suite1\" , collect_suite1 ), & & new_testsuite ( \"suite2\" , collect_suite2 ) & & ] do ii = 1 , size ( testsuites ) write ( error_unit , fmt ) \"Testing:\" , testsuites ( ii )% name call run_testsuite ( testsuites ( ii )% collect , error_unit , stat ) end do if ( stat > 0 ) then write ( error_unit , '(i0, 1x, a)' ) stat , \"test(s) failed!\" error stop end if end program tester Every test is defined in a separate module using a collect function, which\n is exported and added to the testsuites array in the test runner.\n All test have a simple interface with just an allocatable error_type as\n output to provide the test results. module test_suite1 use mctc_env_testing , only : new_unittest , unittest_type , error_type , check implicit none private public :: collect_suite1 contains !> Collect all exported unit tests subroutine collect_suite1 ( testsuite ) !> Collection of tests type ( unittest_type ), allocatable , intent ( out ) :: testsuite (:) testsuite = [ & & new_unittest ( \"valid\" , test_valid ), & & new_unittest ( \"invalid\" , test_invalid , should_fail = . true .) & & ] end subroutine collect_suite1 subroutine test_valid ( error ) type ( error_type ), allocatable , intent ( out ) :: error ! ... end subroutine test_valid subroutine test_invalid ( error ) type ( error_type ), allocatable , intent ( out ) :: error ! ... end subroutine test_invalid end module test_suite1 For an example setup checkout the test/ directory in this project. Uses mctc_env_accuracy mctc_env_error Interfaces public        interface check private  subroutine check_stat(error, stat, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer, intent(in) :: stat Status of operation character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private  subroutine check_logical(error, expression, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling logical, intent(in) :: expression Result of logical operator character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private  subroutine check_float_sp(error, actual, expected, message, more, thr, rel) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling real(kind=sp), intent(in) :: actual Found floating point value real(kind=sp), intent(in) :: expected Expected floating point value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message real(kind=sp), intent(in), optional :: thr Allowed threshold for matching floating point values logical, intent(in), optional :: rel Check for relative errors instead private  subroutine check_float_dp(error, actual, expected, message, more, thr, rel) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling real(kind=dp), intent(in) :: actual Found floating point value real(kind=dp), intent(in) :: expected Expected floating point value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message real(kind=dp), intent(in), optional :: thr Allowed threshold for matching floating point values logical, intent(in), optional :: rel Check for relative errors instead private  subroutine check_int_i1(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i1), intent(in) :: actual Found integer value integer(kind=i1), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private  subroutine check_int_i2(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i2), intent(in) :: actual Found integer value integer(kind=i2), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private  subroutine check_int_i4(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i4), intent(in) :: actual Found integer value integer(kind=i4), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private  subroutine check_int_i8(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i8), intent(in) :: actual Found integer value integer(kind=i8), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private  subroutine check_bool(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling logical, intent(in) :: actual Found boolean value logical, intent(in) :: expected Expected boolean value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private  subroutine check_string(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling character(len=*), intent(in) :: actual Found boolean value character(len=*), intent(in) :: expected Expected boolean value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message Abstract Interfaces abstract interface public  subroutine collect_interface(testsuite) Collect all tests Arguments Type Intent Optional Attributes Name type( unittest_type ), intent(out), allocatable :: testsuite (:) Collection of tests abstract interface public  subroutine test_interface(error) Entry point for tests Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling Derived Types type, public :: testsuite_type Collection of unit tests Components Type Visibility Attributes Name Initial procedure( collect_interface ), public, pointer, nopass :: collect => null() Entry point of the test character(len=:), public, allocatable :: name Name of the testsuite type, public :: unittest_type Declaration of a unit test Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name Name of the test logical, public :: should_fail = .false. Whether test is supposed to fail procedure( test_interface ), public, pointer, nopass :: test => null() Entry point of the test Functions public  function new_testsuite (name, collect) result(self) Register a new testsuite Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of the testsuite procedure( collect_interface ) :: collect Entry point to collect tests Return Value type( testsuite_type ) Newly registered testsuite public  function new_unittest (name, test, should_fail) result(self) Register a new unit test Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of the test procedure( test_interface ) :: test Entry point for the test logical, intent(in), optional :: should_fail Whether test is supposed to error or not Return Value type( unittest_type ) Newly registered test public  function select_suite (suites, name) result(pos) Select a test suite from all available suites Arguments Type Intent Optional Attributes Name type( testsuite_type ) :: suites (:) Available test suites character(len=*), intent(in) :: name Name identifying the test suite Return Value integer Selected test suite public  function select_test (tests, name) result(pos) Select a unit test from all available tests Arguments Type Intent Optional Attributes Name type( unittest_type ) :: tests (:) Available unit tests character(len=*), intent(in) :: name Name identifying the test suite Return Value integer Selected test suite Subroutines public  subroutine run_selected (collect, name, unit, stat) Driver for selective testing Arguments Type Intent Optional Attributes Name procedure( collect_interface ) :: collect Collect tests character(len=*), intent(in) :: name Name of the selected test integer, intent(in) :: unit Unit for IO integer, intent(inout) :: stat Number of failed tests public  subroutine run_testsuite (collect, unit, stat, parallel) Driver for testsuite Arguments Type Intent Optional Attributes Name procedure( collect_interface ) :: collect Collect tests integer, intent(in) :: unit Unit for IO integer, intent(inout) :: stat Number of failed tests logical, intent(in), optional :: parallel Run tests in parallel public  subroutine test_failed (error, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling character(len=*), intent(in) :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message","tags":"","loc":"module/mctc_env_testing.html"},{"title":"mctc_io_structure_info – MCTC-library","text":"Uses mctc_env_accuracy Interfaces public        interface resize private  subroutine resize_pdb_data(var, n) Arguments Type Intent Optional Attributes Name type( pdb_data ), intent(inout), allocatable :: var (:) integer, intent(in), optional :: n Derived Types type, public :: pdb_data Atomic pdb data type. Read more… Components Type Visibility Attributes Name Initial character(len=1), public :: chains = ' ' integer, public :: charge = 0 character(len=1), public :: code = ' ' logical, public :: het = .false. character(len=1), public :: loc = ' ' character(len=4), public :: name = ' ' character(len=3), public :: residue = ' ' integer, public :: residue_number = 0 character(len=4), public :: segid = ' ' type, public :: sdf_data SDF atomic data. Read more… Components Type Visibility Attributes Name Initial integer, public :: charge = 0 c field integer, public :: hydrogens = 0 h field integer, public :: isotope = 0 d field integer, public :: valence = 0 v field type, public :: structure_info structure input info Read more… Components Type Visibility Attributes Name Initial logical, public :: angs_coord = .false. Unit of the atomic coordinates should be in Angstrom if possible logical, public :: angs_lattice = .false. Unit of the lattice vectors should be in Angstrom if possible logical, public :: cartesian = .true. Periodic coordinates should use preferably cartesian coordinates logical, public :: lattice = .true. Lattice information should use preferably lattice vectors logical, public :: missing_hydrogen = .false. SDF hydrogen query present or PDB without hydrogen atoms found real(kind=wp), public :: scale = 1.0_wp Vasp coordinate scaling information logical, public :: selective = .false. Vasp selective dynamics keyword is present logical, public :: two_dimensional = .false. SDF 2D structure present","tags":"","loc":"module/mctc_io_structure_info.html"},{"title":"mctc_io_write_gaussian – MCTC-library","text":"Uses mctc_env_accuracy mctc_io_structure Subroutines public  subroutine write_gaussian_external (mol, unit) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(in) :: mol integer, intent(in) :: unit","tags":"","loc":"module/mctc_io_write_gaussian.html"},{"title":"mctc_io_utils – MCTC-library","text":"Uses mctc_env_accuracy mctc_env_error Interfaces public        interface read_next_token private  subroutine read_next_token_int(line, pos, token, val, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(inout) :: pos type( token_type ), intent(inout) :: token integer, intent(out) :: val integer, intent(out) :: iostat character(len=:), intent(out), optional, allocatable :: iomsg private  subroutine read_next_token_real(line, pos, token, val, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(inout) :: pos type( token_type ), intent(inout) :: token real(kind=wp), intent(out) :: val integer, intent(out) :: iostat character(len=:), intent(out), optional, allocatable :: iomsg public        interface read_token private  subroutine read_token_int(line, token, val, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line type( token_type ), intent(in) :: token integer, intent(out) :: val integer, intent(out) :: iostat character(len=:), intent(out), optional, allocatable :: iomsg private  subroutine read_token_real(line, token, val, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line type( token_type ), intent(in) :: token real(kind=wp), intent(out) :: val integer, intent(out) :: iostat character(len=:), intent(out), optional, allocatable :: iomsg Derived Types type, public :: token_type Text token Components Type Visibility Attributes Name Initial integer, public :: first Begin of sequence integer, public :: last End of sequence Functions public  function filename (unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Return Value character(len=:), allocatable public pure function to_string (val, width) result(string) Represent an integer as character sequence. Arguments Type Intent Optional Attributes Name integer, intent(in) :: val integer, intent(in), optional :: width Return Value character(len=:), allocatable Subroutines public  subroutine getline (unit, line, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Formatted IO unit character(len=:), intent(out), allocatable :: line Line to read integer, intent(out) :: iostat Status of operation character(len=:), optional, allocatable :: iomsg Error message public  subroutine io2_error (error, message, source1, source2, token1, token2, filename, line1, line2, label1, label2) Create new IO error Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handler character(len=*), intent(in) :: message Main error message character(len=*), intent(in) :: source1 String representing the offending input character(len=*), intent(in) :: source2 String representing the offending input type( token_type ), intent(in) :: token1 Last processed token type( token_type ), intent(in) :: token2 Last processed token character(len=*), intent(in), optional :: filename Name of the input file integer, intent(in), optional :: line1 Line number integer, intent(in), optional :: line2 Line number character(len=*), intent(in), optional :: label1 Label of the offending statement character(len=*), intent(in), optional :: label2 Label of the offending statement public  subroutine io_error (error, message, source, token, filename, line, label) Create new IO error Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handler character(len=*), intent(in) :: message Main error message character(len=*), intent(in) :: source String representing the offending input type( token_type ), intent(in) :: token Last processed token character(len=*), intent(in), optional :: filename Name of the input file integer, intent(in), optional :: line Line number character(len=*), intent(in), optional :: label Label of the offending statement public  subroutine next_line (unit, line, pos, lnum, iostat, iomsg) Convenience function to read a line and update associated descriptors Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Formatted IO unit character(len=:), intent(out), allocatable :: line Line to read integer, intent(out) :: pos Current position in line integer, intent(inout) :: lnum Current line number integer, intent(out) :: iostat Status of operation character(len=:), optional, allocatable :: iomsg Error message public  subroutine next_token (string, pos, token) Advance pointer to next text token Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to check integer, intent(inout) :: pos Current position in string type( token_type ), intent(out) :: token Token found","tags":"","loc":"module/mctc_io_utils.html"},{"title":"mctc_io_write – MCTC-library","text":"Uses mctc_io_write_cjson mctc_io_filetype mctc_io_write_pdb mctc_io_write_qchem mctc_io_write_qcschema mctc_io_write_turbomole mctc_io_write_vasp mctc_io_structure mctc_io_write_gaussian mctc_env_error mctc_io_write_aims mctc_io_write_xyz mctc_io_write_genformat mctc_io_write_ctfile Interfaces public        interface write_structure private  subroutine write_structure_to_file(self, file, error, format) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self Instance of the molecular structure data character(len=*), intent(in) :: file Name of the file to read type( error_type ), intent(out), allocatable :: error Error handling integer, intent(in), optional :: format File type format hint private  subroutine write_structure_to_unit(self, unit, ftype, error) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle integer, intent(in) :: ftype File type to read type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_write.html"},{"title":"mctc_io_write_qcschema – MCTC-library","text":"Uses mctc_env_accuracy mctc_version mctc_io_structure Subroutines public  subroutine write_qcschema (mol, unit) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(in) :: mol integer, intent(in) :: unit","tags":"","loc":"module/mctc_io_write_qcschema.html"},{"title":"mctc_io_read_qchem – MCTC-library","text":"Uses mctc_io_resize mctc_io_structure mctc_io_utils mctc_env_error mctc_io_convert mctc_env_accuracy mctc_io_symbols Subroutines public  subroutine read_qchem (mol, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: mol Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_qchem.html"},{"title":"mctc_env_error – MCTC-library","text":"Central registry for error codes Variables Type Visibility Attributes Name Initial type(enum_stat), public, parameter :: mctc_stat = enum_stat() Actual enumerator for return states Derived Types type, public :: error_type Error message Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: message Payload of the error integer, public :: stat Error code Subroutines public  subroutine fatal_error (error, message, stat) A fatal error is encountered Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Instance of the error character(len=*), intent(in), optional :: message A detailed message describing the error and (optionally) offering advice integer, intent(in), optional :: stat Overwrite of the error code","tags":"","loc":"module/mctc_env_error.html"},{"title":"mctc_io_resize – MCTC-library","text":"Reallocation implementation for resizing arrays Uses mctc_env_accuracy Interfaces public        interface resize Overloaded resize interface private pure subroutine resize_char(var, n) Reallocate list of characters Arguments Type Intent Optional Attributes Name character(len=*), intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size private pure subroutine resize_int(var, n) Reallocate list of integers Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size private pure subroutine resize_logical(var, n) Reallocate list of logicals Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size private pure subroutine resize_real(var, n) Reallocate list of reals Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size private pure subroutine resize_real_2d(var, n) Reallocate list of reals Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), allocatable :: var (:,:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size","tags":"","loc":"module/mctc_io_resize.html"},{"title":"mctc_io_write_xyz – MCTC-library","text":"Uses mctc_io_structure mctc_io_convert Subroutines public  subroutine write_xyz (self, unit, comment_line) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: comment_line","tags":"","loc":"module/mctc_io_write_xyz.html"},{"title":"mctc_io_codata2018 – MCTC-library","text":"Automatically generated from 2018 CODATA NIST file:\nhttps://physics.nist.gov/cuu/Constants/Table/allascii.txt Based on https://github.com/vmagnin/fundamental_constants. Uses mctc_env Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: Angstrom_star = 1.00001495e-10_wp Angstrom star (m) real(kind=wp), public, parameter :: Avogadro_constant = 6.02214076e23_wp Avogadro constant (mol&#94;-1) real(kind=wp), public, parameter :: Bohr_magneton = 9.2740100783e-24_wp Bohr magneton (J T&#94;-1) real(kind=wp), public, parameter :: Bohr_magneton_in_Hz_T = 1.39962449361e10_wp Bohr magneton in Hz/T (Hz T&#94;-1) real(kind=wp), public, parameter :: Bohr_magneton_in_K_T = 0.67171381563_wp Bohr magneton in K/T (K T&#94;-1) real(kind=wp), public, parameter :: Bohr_magneton_in_eV_T = 5.7883818060e-5_wp Bohr magneton in eV/T (eV T&#94;-1) real(kind=wp), public, parameter :: Bohr_magneton_in_inverse_meter_per_tesla = 46.686447783_wp Bohr magneton in inverse meter per tesla (m&#94;-1 T&#94;-1) real(kind=wp), public, parameter :: Bohr_radius = 5.29177210903e-11_wp Bohr radius (m) real(kind=wp), public, parameter :: Boltzmann_constant = 1.380649e-23_wp Boltzmann constant (J K&#94;-1) real(kind=wp), public, parameter :: Boltzmann_constant_in_Hz_K = 2.083661912e10_wp Boltzmann constant in Hz/K (Hz K&#94;-1) real(kind=wp), public, parameter :: Boltzmann_constant_in_eV_K = 8.617333262e-5_wp Boltzmann constant in eV/K (eV K&#94;-1) real(kind=wp), public, parameter :: Boltzmann_constant_in_inverse_meter_per_kelvin = 69.50348004_wp Boltzmann constant in inverse meter per kelvin (m&#94;-1 K&#94;-1) real(kind=wp), public, parameter :: Compton_wavelength = 2.42631023867e-12_wp Compton wavelength (m) real(kind=wp), public, parameter :: Copper_x_unit = 1.00207697e-13_wp Copper x unit (m) real(kind=wp), public, parameter :: Faraday_constant = 96485.33212_wp Faraday constant (C mol&#94;-1) real(kind=wp), public, parameter :: Fermi_coupling_constant = 1.1663787e-5_wp Fermi coupling constant (GeV&#94;-2) real(kind=wp), public, parameter :: Hartree_energy = 4.3597447222071e-18_wp Hartree energy (J) real(kind=wp), public, parameter :: Hartree_energy_in_eV = 27.211386245988_wp Hartree energy in eV (eV) real(kind=wp), public, parameter :: Josephson_constant = 483597.8484e9_wp Josephson constant (Hz V&#94;-1) real(kind=wp), public, parameter :: Loschmidt_constant_273_15_K__100_kPa = 2.651645804e25_wp Loschmidt constant (273.15 K, 100 kPa) (m&#94;-3) real(kind=wp), public, parameter :: Loschmidt_constant_273_15_K__101_325_kPa = 2.686780111e25_wp Loschmidt constant (273.15 K, 101.325 kPa) (m&#94;-3) real(kind=wp), public, parameter :: Molybdenum_x_unit = 1.00209952e-13_wp Molybdenum x unit (m) real(kind=wp), public, parameter :: Newtonian_constant_of_gravitation = 6.67430e-11_wp Newtonian constant of gravitation (m&#94;3 kg&#94;-1 s&#94;-2) real(kind=wp), public, parameter :: Newtonian_constant_of_gravitation_over_h_bar_c = 6.70883e-39_wp Newtonian constant of gravitation over h-bar c ((GeV/c&#94;2)&#94;-2) real(kind=wp), public, parameter :: Planck_constant = 6.62607015e-34_wp Planck constant (J Hz&#94;-1) real(kind=wp), public, parameter :: Planck_constant_in_eV_Hz = 4.135667696e-15_wp Planck constant in eV/Hz (eV Hz&#94;-1) real(kind=wp), public, parameter :: Planck_length = 1.616255e-35_wp Planck length (m) real(kind=wp), public, parameter :: Planck_mass = 2.176434e-8_wp Planck mass (kg) real(kind=wp), public, parameter :: Planck_mass_energy_equivalent_in_GeV = 1.220890e19_wp Planck mass energy equivalent in GeV (GeV) real(kind=wp), public, parameter :: Planck_temperature = 1.416784e32_wp Planck temperature (K) real(kind=wp), public, parameter :: Planck_time = 5.391247e-44_wp Planck time (s) real(kind=wp), public, parameter :: Rydberg_constant = 10973731.568160_wp Rydberg constant (m&#94;-1) real(kind=wp), public, parameter :: Rydberg_constant_times_c_in_Hz = 3.2898419602508e15_wp Rydberg constant times c in Hz (Hz) real(kind=wp), public, parameter :: Rydberg_constant_times_hc_in_J = 2.1798723611035e-18_wp Rydberg constant times hc in J (J) real(kind=wp), public, parameter :: Rydberg_constant_times_hc_in_eV = 13.605693122994_wp Rydberg constant times hc in eV (eV) real(kind=wp), public, parameter :: Sackur_Tetrode_constant_1_K__100_kPa = -1.15170753706_wp Sackur-Tetrode constant (1 K, 100 kPa) (dimensionless) real(kind=wp), public, parameter :: Sackur_Tetrode_constant_1_K__101_325_kPa = -1.16487052358_wp Sackur-Tetrode constant (1 K, 101.325 kPa) (dimensionless) real(kind=wp), public, parameter :: Stefan_Boltzmann_constant = 5.670374419e-8_wp Stefan-Boltzmann constant (W m&#94;-2 K&#94;-4) real(kind=wp), public, parameter :: Thomson_cross_section = 6.6524587321e-29_wp Thomson cross section (m&#94;2) real(kind=wp), public, parameter :: W_to_Z_mass_ratio = 0.88153_wp W to Z mass ratio (dimensionless) real(kind=wp), public, parameter :: Wien_frequency_displacement_law_constant = 5.878925757e10_wp Wien frequency displacement law constant (Hz K&#94;-1) real(kind=wp), public, parameter :: Wien_wavelength_displacement_law_constant = 2.897771955e-3_wp Wien wavelength displacement law constant (m K) real(kind=wp), public, parameter :: alpha_particle_electron_mass_ratio = 7294.29954142_wp alpha particle-electron mass ratio (dimensionless) real(kind=wp), public, parameter :: alpha_particle_mass = 6.6446573357e-27_wp alpha particle mass (kg) real(kind=wp), public, parameter :: alpha_particle_mass_energy_equivalent = 5.9719201914e-10_wp alpha particle mass energy equivalent (J) real(kind=wp), public, parameter :: alpha_particle_mass_energy_equivalent_in_MeV = 3727.3794066_wp alpha particle mass energy equivalent in MeV (MeV) real(kind=wp), public, parameter :: alpha_particle_mass_in_u = 4.001506179127_wp alpha particle mass in u (u) real(kind=wp), public, parameter :: alpha_particle_molar_mass = 4.0015061777e-3_wp alpha particle molar mass (kg mol&#94;-1) real(kind=wp), public, parameter :: alpha_particle_proton_mass_ratio = 3.97259969009_wp alpha particle-proton mass ratio (dimensionless) real(kind=wp), public, parameter :: alpha_particle_relative_atomic_mass = 4.001506179127_wp alpha particle relative atomic mass (dimensionless) real(kind=wp), public, parameter :: atomic_mass_constant = 1.66053906660e-27_wp atomic mass constant (kg) real(kind=wp), public, parameter :: atomic_mass_constant_energy_equivalent = 1.49241808560e-10_wp atomic mass constant energy equivalent (J) real(kind=wp), public, parameter :: atomic_mass_constant_energy_equivalent_in_MeV = 931.49410242_wp atomic mass constant energy equivalent in MeV (MeV) real(kind=wp), public, parameter :: atomic_mass_unit_electron_volt_relationship = 9.3149410242e8_wp atomic mass unit-electron volt relationship (eV) real(kind=wp), public, parameter :: atomic_mass_unit_hartree_relationship = 3.4231776874e7_wp atomic mass unit-hartree relationship (E_h) real(kind=wp), public, parameter :: atomic_mass_unit_hertz_relationship = 2.25234271871e23_wp atomic mass unit-hertz relationship (Hz) real(kind=wp), public, parameter :: atomic_mass_unit_inverse_meter_relationship = 7.5130066104e14_wp atomic mass unit-inverse meter relationship (m&#94;-1) real(kind=wp), public, parameter :: atomic_mass_unit_joule_relationship = 1.49241808560e-10_wp atomic mass unit-joule relationship (J) real(kind=wp), public, parameter :: atomic_mass_unit_kelvin_relationship = 1.08095401916e13_wp atomic mass unit-kelvin relationship (K) real(kind=wp), public, parameter :: atomic_mass_unit_kilogram_relationship = 1.66053906660e-27_wp atomic mass unit-kilogram relationship (kg) real(kind=wp), public, parameter :: atomic_unit_of_1st_hyperpolarizability = 3.2063613061e-53_wp atomic unit of 1st hyperpolarizability (C&#94;3 m&#94;3 J&#94;-2) real(kind=wp), public, parameter :: atomic_unit_of_2nd_hyperpolarizability = 6.2353799905e-65_wp atomic unit of 2nd hyperpolarizability (C&#94;4 m&#94;4 J&#94;-3) real(kind=wp), public, parameter :: atomic_unit_of_action = 1.054571817e-34_wp atomic unit of action (J s) real(kind=wp), public, parameter :: atomic_unit_of_charge = 1.602176634e-19_wp atomic unit of charge (C) real(kind=wp), public, parameter :: atomic_unit_of_charge_density = 1.08120238457e12_wp atomic unit of charge density (C m&#94;-3) real(kind=wp), public, parameter :: atomic_unit_of_current = 6.623618237510e-3_wp atomic unit of current (A) real(kind=wp), public, parameter :: atomic_unit_of_electric_dipole_mom_ = 8.4783536255e-30_wp atomic unit of electric dipole mom. (C m) real(kind=wp), public, parameter :: atomic_unit_of_electric_field = 5.14220674763e11_wp atomic unit of electric field (V m&#94;-1) real(kind=wp), public, parameter :: atomic_unit_of_electric_field_gradient = 9.7173624292e21_wp atomic unit of electric field gradient (V m&#94;-2) real(kind=wp), public, parameter :: atomic_unit_of_electric_polarizability = 1.64877727436e-41_wp atomic unit of electric polarizability (C&#94;2 m&#94;2 J&#94;-1) real(kind=wp), public, parameter :: atomic_unit_of_electric_potential = 27.211386245988_wp atomic unit of electric potential (V) real(kind=wp), public, parameter :: atomic_unit_of_electric_quadrupole_mom_ = 4.4865515246e-40_wp atomic unit of electric quadrupole mom. (C m&#94;2) real(kind=wp), public, parameter :: atomic_unit_of_energy = 4.3597447222071e-18_wp atomic unit of energy (J) real(kind=wp), public, parameter :: atomic_unit_of_force = 8.2387234983e-8_wp atomic unit of force (N) real(kind=wp), public, parameter :: atomic_unit_of_length = 5.29177210903e-11_wp atomic unit of length (m) real(kind=wp), public, parameter :: atomic_unit_of_mag__dipole_mom_ = 1.85480201566e-23_wp atomic unit of mag. dipole mom. (J T&#94;-1) real(kind=wp), public, parameter :: atomic_unit_of_mag__flux_density = 2.35051756758e5_wp atomic unit of mag. flux density (T) real(kind=wp), public, parameter :: atomic_unit_of_magnetizability = 7.8910366008e-29_wp atomic unit of magnetizability (J T&#94;-2) real(kind=wp), public, parameter :: atomic_unit_of_mass = 9.1093837015e-31_wp atomic unit of mass (kg) real(kind=wp), public, parameter :: atomic_unit_of_momentum = 1.99285191410e-24_wp atomic unit of momentum (kg m s&#94;-1) real(kind=wp), public, parameter :: atomic_unit_of_permittivity = 1.11265005545e-10_wp atomic unit of permittivity (F m&#94;-1) real(kind=wp), public, parameter :: atomic_unit_of_time = 2.4188843265857e-17_wp atomic unit of time (s) real(kind=wp), public, parameter :: atomic_unit_of_velocity = 2.18769126364e6_wp atomic unit of velocity (m s&#94;-1) real(kind=wp), public, parameter :: characteristic_impedance_of_vacuum = 376.730313668_wp characteristic impedance of vacuum (ohm) real(kind=wp), public, parameter :: classical_electron_radius = 2.8179403262e-15_wp classical electron radius (m) real(kind=wp), public, parameter :: conductance_quantum = 7.748091729e-5_wp conductance quantum (S) real(kind=wp), public, parameter :: conventional_value_of_Josephson_constant = 483597.9e9_wp conventional value of Josephson constant (Hz V&#94;-1) real(kind=wp), public, parameter :: conventional_value_of_ampere_90 = 1.00000008887_wp conventional value of ampere-90 (A) real(kind=wp), public, parameter :: conventional_value_of_coulomb_90 = 1.00000008887_wp conventional value of coulomb-90 (C) real(kind=wp), public, parameter :: conventional_value_of_farad_90 = 0.99999998220_wp conventional value of farad-90 (F) real(kind=wp), public, parameter :: conventional_value_of_henry_90 = 1.00000001779_wp conventional value of henry-90 (H) real(kind=wp), public, parameter :: conventional_value_of_ohm_90 = 1.00000001779_wp conventional value of ohm-90 (ohm) real(kind=wp), public, parameter :: conventional_value_of_volt_90 = 1.00000010666_wp conventional value of volt-90 (V) real(kind=wp), public, parameter :: conventional_value_of_von_Klitzing_constant = 25812.807_wp conventional value of von Klitzing constant (ohm) real(kind=wp), public, parameter :: conventional_value_of_watt_90 = 1.00000019553_wp conventional value of watt-90 (W) real(kind=wp), public, parameter :: deuteron_electron_mag__mom__ratio = -4.664345551e-4_wp deuteron-electron mag. mom. ratio (dimensionless) real(kind=wp), public, parameter :: deuteron_electron_mass_ratio = 3670.48296788_wp deuteron-electron mass ratio (dimensionless) real(kind=wp), public, parameter :: deuteron_g_factor = 0.8574382338_wp deuteron g factor (dimensionless) real(kind=wp), public, parameter :: deuteron_mag__mom_ = 4.330735094e-27_wp deuteron mag. mom. (J T&#94;-1) real(kind=wp), public, parameter :: deuteron_mag__mom__to_Bohr_magneton_ratio = 4.669754570e-4_wp deuteron mag. mom. to Bohr magneton ratio (dimensionless) real(kind=wp), public, parameter :: deuteron_mag__mom__to_nuclear_magneton_ratio = 0.8574382338_wp deuteron mag. mom. to nuclear magneton ratio (dimensionless) real(kind=wp), public, parameter :: deuteron_mass = 3.3435837724e-27_wp deuteron mass (kg) real(kind=wp), public, parameter :: deuteron_mass_energy_equivalent = 3.00506323102e-10_wp deuteron mass energy equivalent (J) real(kind=wp), public, parameter :: deuteron_mass_energy_equivalent_in_MeV = 1875.61294257_wp deuteron mass energy equivalent in MeV (MeV) real(kind=wp), public, parameter :: deuteron_mass_in_u = 2.013553212745_wp deuteron mass in u (u) real(kind=wp), public, parameter :: deuteron_molar_mass = 2.01355321205e-3_wp deuteron molar mass (kg mol&#94;-1) real(kind=wp), public, parameter :: deuteron_neutron_mag__mom__ratio = -0.44820653_wp deuteron-neutron mag. mom. ratio (dimensionless) real(kind=wp), public, parameter :: deuteron_proton_mag__mom__ratio = 0.30701220939_wp deuteron-proton mag. mom. ratio (dimensionless) real(kind=wp), public, parameter :: deuteron_proton_mass_ratio = 1.99900750139_wp deuteron-proton mass ratio (dimensionless) real(kind=wp), public, parameter :: deuteron_relative_atomic_mass = 2.013553212745_wp deuteron relative atomic mass (dimensionless) real(kind=wp), public, parameter :: deuteron_rms_charge_radius = 2.12799e-15_wp deuteron rms charge radius (m) real(kind=wp), public, parameter :: electron_charge_to_mass_quotient = -1.75882001076e11_wp electron charge to mass quotient (C kg&#94;-1) real(kind=wp), public, parameter :: electron_deuteron_mag__mom__ratio = -2143.9234915_wp electron-deuteron mag. mom. ratio (dimensionless) real(kind=wp), public, parameter :: electron_deuteron_mass_ratio = 2.724437107462e-4_wp electron-deuteron mass ratio (dimensionless) real(kind=wp), public, parameter :: electron_g_factor = -2.00231930436256_wp electron g factor (dimensionless) real(kind=wp), public, parameter :: electron_gyromag__ratio = 1.76085963023e11_wp electron gyromag. ratio (s&#94;-1 T&#94;-1) real(kind=wp), public, parameter :: electron_gyromag__ratio_in_MHz_T = 28024.9514242_wp electron gyromag. ratio in MHz/T (MHz T&#94;-1) real(kind=wp), public, parameter :: electron_helion_mass_ratio = 1.819543074573e-4_wp electron-helion mass ratio (dimensionless) real(kind=wp), public, parameter :: electron_mag__mom_ = -9.2847647043e-24_wp electron mag. mom. (J T&#94;-1) real(kind=wp), public, parameter :: electron_mag__mom__anomaly = 1.15965218128e-3_wp electron mag. mom. anomaly (dimensionless) real(kind=wp), public, parameter :: electron_mag__mom__to_Bohr_magneton_ratio = -1.00115965218128_wp electron mag. mom. to Bohr magneton ratio (dimensionless) real(kind=wp), public, parameter :: electron_mag__mom__to_nuclear_magneton_ratio = -1838.28197188_wp electron mag. mom. to nuclear magneton ratio (dimensionless) real(kind=wp), public, parameter :: electron_mass = 9.1093837015e-31_wp electron mass (kg) real(kind=wp), public, parameter :: electron_mass_energy_equivalent = 8.1871057769e-14_wp electron mass energy equivalent (J) real(kind=wp), public, parameter :: electron_mass_energy_equivalent_in_MeV = 0.51099895000_wp electron mass energy equivalent in MeV (MeV) real(kind=wp), public, parameter :: electron_mass_in_u = 5.48579909065e-4_wp electron mass in u (u) real(kind=wp), public, parameter :: electron_molar_mass = 5.4857990888e-7_wp electron molar mass (kg mol&#94;-1) real(kind=wp), public, parameter :: electron_muon_mag__mom__ratio = 206.7669883_wp electron-muon mag. mom. ratio (dimensionless) real(kind=wp), public, parameter :: electron_muon_mass_ratio = 4.83633169e-3_wp electron-muon mass ratio (dimensionless) real(kind=wp), public, parameter :: electron_neutron_mag__mom__ratio = 960.92050_wp electron-neutron mag. mom. ratio (dimensionless) real(kind=wp), public, parameter :: electron_neutron_mass_ratio = 5.4386734424e-4_wp electron-neutron mass ratio (dimensionless) real(kind=wp), public, parameter :: electron_proton_mag__mom__ratio = -658.21068789_wp electron-proton mag. mom. ratio (dimensionless) real(kind=wp), public, parameter :: electron_proton_mass_ratio = 5.44617021487e-4_wp electron-proton mass ratio (dimensionless) real(kind=wp), public, parameter :: electron_relative_atomic_mass = 5.48579909065e-4_wp electron relative atomic mass (dimensionless) real(kind=wp), public, parameter :: electron_tau_mass_ratio = 2.87585e-4_wp electron-tau mass ratio (dimensionless) real(kind=wp), public, parameter :: electron_to_alpha_particle_mass_ratio = 1.370933554787e-4_wp electron to alpha particle mass ratio (dimensionless) real(kind=wp), public, parameter :: electron_to_shielded_helion_mag__mom__ratio = 864.058257_wp electron to shielded helion mag. mom. ratio (dimensionless) real(kind=wp), public, parameter :: electron_to_shielded_proton_mag__mom__ratio = -658.2275971_wp electron to shielded proton mag. mom. ratio (dimensionless) real(kind=wp), public, parameter :: electron_triton_mass_ratio = 1.819200062251e-4_wp electron-triton mass ratio (dimensionless) real(kind=wp), public, parameter :: electron_volt = 1.602176634e-19_wp electron volt (J) real(kind=wp), public, parameter :: electron_volt_atomic_mass_unit_relationship = 1.07354410233e-9_wp electron volt-atomic mass unit relationship (u) real(kind=wp), public, parameter :: electron_volt_hartree_relationship = 3.6749322175655e-2_wp electron volt-hartree relationship (E_h) real(kind=wp), public, parameter :: electron_volt_hertz_relationship = 2.417989242e14_wp electron volt-hertz relationship (Hz) real(kind=wp), public, parameter :: electron_volt_inverse_meter_relationship = 8.065543937e5_wp electron volt-inverse meter relationship (m&#94;-1) real(kind=wp), public, parameter :: electron_volt_joule_relationship = 1.602176634e-19_wp electron volt-joule relationship (J) real(kind=wp), public, parameter :: electron_volt_kelvin_relationship = 1.160451812e4_wp electron volt-kelvin relationship (K) real(kind=wp), public, parameter :: electron_volt_kilogram_relationship = 1.782661921e-36_wp electron volt-kilogram relationship (kg) real(kind=wp), public, parameter :: elementary_charge = 1.602176634e-19_wp elementary charge (C) real(kind=wp), public, parameter :: elementary_charge_over_h_bar = 1.519267447e15_wp elementary charge over h-bar (A J&#94;-1) real(kind=wp), public, parameter :: fine_structure_constant = 7.2973525693e-3_wp fine-structure constant (dimensionless) real(kind=wp), public, parameter :: first_radiation_constant = 3.741771852e-16_wp first radiation constant (W m&#94;2) real(kind=wp), public, parameter :: first_radiation_constant_for_spectral_radiance = 1.191042972e-16_wp first radiation constant for spectral radiance (W m&#94;2 sr&#94;-1) real(kind=wp), public, parameter :: hartree_atomic_mass_unit_relationship = 2.92126232205e-8_wp hartree-atomic mass unit relationship (u) real(kind=wp), public, parameter :: hartree_electron_volt_relationship = 27.211386245988_wp hartree-electron volt relationship (eV) real(kind=wp), public, parameter :: hartree_hertz_relationship = 6.579683920502e15_wp hartree-hertz relationship (Hz) real(kind=wp), public, parameter :: hartree_inverse_meter_relationship = 2.1947463136320e7_wp hartree-inverse meter relationship (m&#94;-1) real(kind=wp), public, parameter :: hartree_joule_relationship = 4.3597447222071e-18_wp hartree-joule relationship (J) real(kind=wp), public, parameter :: hartree_kelvin_relationship = 3.1577502480407e5_wp hartree-kelvin relationship (K) real(kind=wp), public, parameter :: hartree_kilogram_relationship = 4.8508702095432e-35_wp hartree-kilogram relationship (kg) real(kind=wp), public, parameter :: helion_electron_mass_ratio = 5495.88528007_wp helion-electron mass ratio (dimensionless) real(kind=wp), public, parameter :: helion_g_factor = -4.255250615_wp helion g factor (dimensionless) real(kind=wp), public, parameter :: helion_mag__mom_ = -1.074617532e-26_wp helion mag. mom. (J T&#94;-1) real(kind=wp), public, parameter :: helion_mag__mom__to_Bohr_magneton_ratio = -1.158740958e-3_wp helion mag. mom. to Bohr magneton ratio (dimensionless) real(kind=wp), public, parameter :: helion_mag__mom__to_nuclear_magneton_ratio = -2.127625307_wp helion mag. mom. to nuclear magneton ratio (dimensionless) real(kind=wp), public, parameter :: helion_mass = 5.0064127796e-27_wp helion mass (kg) real(kind=wp), public, parameter :: helion_mass_energy_equivalent = 4.4995394125e-10_wp helion mass energy equivalent (J) real(kind=wp), public, parameter :: helion_mass_energy_equivalent_in_MeV = 2808.39160743_wp helion mass energy equivalent in MeV (MeV) real(kind=wp), public, parameter :: helion_mass_in_u = 3.014932247175_wp helion mass in u (u) real(kind=wp), public, parameter :: helion_molar_mass = 3.01493224613e-3_wp helion molar mass (kg mol&#94;-1) real(kind=wp), public, parameter :: helion_proton_mass_ratio = 2.99315267167_wp helion-proton mass ratio (dimensionless) real(kind=wp), public, parameter :: helion_relative_atomic_mass = 3.014932247175_wp helion relative atomic mass (dimensionless) real(kind=wp), public, parameter :: helion_shielding_shift = 5.996743e-5_wp helion shielding shift (dimensionless) real(kind=wp), public, parameter :: hertz_atomic_mass_unit_relationship = 4.4398216652e-24_wp hertz-atomic mass unit relationship (u) real(kind=wp), public, parameter :: hertz_electron_volt_relationship = 4.135667696e-15_wp hertz-electron volt relationship (eV) real(kind=wp), public, parameter :: hertz_hartree_relationship = 1.5198298460570e-16_wp hertz-hartree relationship (E_h) real(kind=wp), public, parameter :: hertz_inverse_meter_relationship = 3.335640951e-9_wp hertz-inverse meter relationship (m&#94;-1) real(kind=wp), public, parameter :: hertz_joule_relationship = 6.62607015e-34_wp hertz-joule relationship (J) real(kind=wp), public, parameter :: hertz_kelvin_relationship = 4.799243073e-11_wp hertz-kelvin relationship (K) real(kind=wp), public, parameter :: hertz_kilogram_relationship = 7.372497323e-51_wp hertz-kilogram relationship (kg) real(kind=wp), public, parameter :: hyperfine_transition_frequency_of_Cs_133 = 9192631770e0_wp hyperfine transition frequency of Cs-133 (Hz) real(kind=wp), public, parameter :: inverse_fine_structure_constant = 137.035999084_wp inverse fine-structure constant (dimensionless) real(kind=wp), public, parameter :: inverse_meter_atomic_mass_unit_relationship = 1.33102505010e-15_wp inverse meter-atomic mass unit relationship (u) real(kind=wp), public, parameter :: inverse_meter_electron_volt_relationship = 1.239841984e-6_wp inverse meter-electron volt relationship (eV) real(kind=wp), public, parameter :: inverse_meter_hartree_relationship = 4.5563352529120e-8_wp inverse meter-hartree relationship (E_h) real(kind=wp), public, parameter :: inverse_meter_hertz_relationship = 299792458e0_wp inverse meter-hertz relationship (Hz) real(kind=wp), public, parameter :: inverse_meter_joule_relationship = 1.986445857e-25_wp inverse meter-joule relationship (J) real(kind=wp), public, parameter :: inverse_meter_kelvin_relationship = 1.438776877e-2_wp inverse meter-kelvin relationship (K) real(kind=wp), public, parameter :: inverse_meter_kilogram_relationship = 2.210219094e-42_wp inverse meter-kilogram relationship (kg) real(kind=wp), public, parameter :: inverse_of_conductance_quantum = 12906.40372_wp inverse of conductance quantum (ohm) real(kind=wp), public, parameter :: joule_atomic_mass_unit_relationship = 6.7005352565e9_wp joule-atomic mass unit relationship (u) real(kind=wp), public, parameter :: joule_electron_volt_relationship = 6.241509074e18_wp joule-electron volt relationship (eV) real(kind=wp), public, parameter :: joule_hartree_relationship = 2.2937122783963e17_wp joule-hartree relationship (E_h) real(kind=wp), public, parameter :: joule_hertz_relationship = 1.509190179e33_wp joule-hertz relationship (Hz) real(kind=wp), public, parameter :: joule_inverse_meter_relationship = 5.034116567e24_wp joule-inverse meter relationship (m&#94;-1) real(kind=wp), public, parameter :: joule_kelvin_relationship = 7.242970516e22_wp joule-kelvin relationship (K) real(kind=wp), public, parameter :: joule_kilogram_relationship = 1.112650056e-17_wp joule-kilogram relationship (kg) real(kind=wp), public, parameter :: kelvin_atomic_mass_unit_relationship = 9.2510873014e-14_wp kelvin-atomic mass unit relationship (u) real(kind=wp), public, parameter :: kelvin_electron_volt_relationship = 8.617333262e-5_wp kelvin-electron volt relationship (eV) real(kind=wp), public, parameter :: kelvin_hartree_relationship = 3.1668115634556e-6_wp kelvin-hartree relationship (E_h) real(kind=wp), public, parameter :: kelvin_hertz_relationship = 2.083661912e10_wp kelvin-hertz relationship (Hz) real(kind=wp), public, parameter :: kelvin_inverse_meter_relationship = 69.50348004_wp kelvin-inverse meter relationship (m&#94;-1) real(kind=wp), public, parameter :: kelvin_joule_relationship = 1.380649e-23_wp kelvin-joule relationship (J) real(kind=wp), public, parameter :: kelvin_kilogram_relationship = 1.536179187e-40_wp kelvin-kilogram relationship (kg) real(kind=wp), public, parameter :: kilogram_atomic_mass_unit_relationship = 6.0221407621e26_wp kilogram-atomic mass unit relationship (u) real(kind=wp), public, parameter :: kilogram_electron_volt_relationship = 5.609588603e35_wp kilogram-electron volt relationship (eV) real(kind=wp), public, parameter :: kilogram_hartree_relationship = 2.0614857887409e34_wp kilogram-hartree relationship (E_h) real(kind=wp), public, parameter :: kilogram_hertz_relationship = 1.356392489e50_wp kilogram-hertz relationship (Hz) real(kind=wp), public, parameter :: kilogram_inverse_meter_relationship = 4.524438335e41_wp kilogram-inverse meter relationship (m&#94;-1) real(kind=wp), public, parameter :: kilogram_joule_relationship = 8.987551787e16_wp kilogram-joule relationship (J) real(kind=wp), public, parameter :: kilogram_kelvin_relationship = 6.509657260e39_wp kilogram-kelvin relationship (K) real(kind=wp), public, parameter :: lattice_parameter_of_silicon = 5.431020511e-10_wp lattice parameter of silicon (m) real(kind=wp), public, parameter :: lattice_spacing_of_ideal_Si_220 = 1.920155716e-10_wp lattice spacing of ideal Si (220) (m) real(kind=wp), public, parameter :: luminous_efficacy = 683e0_wp luminous efficacy (lm W&#94;-1) real(kind=wp), public, parameter :: mag__flux_quantum = 2.067833848e-15_wp mag. flux quantum (Wb) real(kind=wp), public, parameter :: molar_Planck_constant = 3.990312712e-10_wp molar Planck constant (J Hz&#94;-1 mol&#94;-1) real(kind=wp), public, parameter :: molar_gas_constant = 8.314462618_wp molar gas constant (J mol&#94;-1 K&#94;-1) real(kind=wp), public, parameter :: molar_mass_constant = 0.99999999965e-3_wp molar mass constant (kg mol&#94;-1) real(kind=wp), public, parameter :: molar_mass_of_carbon_12 = 11.9999999958e-3_wp molar mass of carbon-12 (kg mol&#94;-1) real(kind=wp), public, parameter :: molar_volume_of_ideal_gas_273_15_K__100_kPa = 22.71095464e-3_wp molar volume of ideal gas (273.15 K, 100 kPa) (m&#94;3 mol&#94;-1) real(kind=wp), public, parameter :: molar_volume_of_ideal_gas_273_15_K__101_325_kPa = 22.41396954e-3_wp molar volume of ideal gas (273.15 K, 101.325 kPa) (m&#94;3 mol&#94;-1) real(kind=wp), public, parameter :: molar_volume_of_silicon = 1.205883199e-5_wp molar volume of silicon (m&#94;3 mol&#94;-1) real(kind=wp), public, parameter :: muon_Compton_wavelength = 1.173444110e-14_wp muon Compton wavelength (m) real(kind=wp), public, parameter :: muon_electron_mass_ratio = 206.7682830_wp muon-electron mass ratio (dimensionless) real(kind=wp), public, parameter :: muon_g_factor = -2.0023318418_wp muon g factor (dimensionless) real(kind=wp), public, parameter :: muon_mag__mom_ = -4.49044830e-26_wp muon mag. mom. (J T&#94;-1) real(kind=wp), public, parameter :: muon_mag__mom__anomaly = 1.16592089e-3_wp muon mag. mom. anomaly (dimensionless) real(kind=wp), public, parameter :: muon_mag__mom__to_Bohr_magneton_ratio = -4.84197047e-3_wp muon mag. mom. to Bohr magneton ratio (dimensionless) real(kind=wp), public, parameter :: muon_mag__mom__to_nuclear_magneton_ratio = -8.89059703_wp muon mag. mom. to nuclear magneton ratio (dimensionless) real(kind=wp), public, parameter :: muon_mass = 1.883531627e-28_wp muon mass (kg) real(kind=wp), public, parameter :: muon_mass_energy_equivalent = 1.692833804e-11_wp muon mass energy equivalent (J) real(kind=wp), public, parameter :: muon_mass_energy_equivalent_in_MeV = 105.6583755_wp muon mass energy equivalent in MeV (MeV) real(kind=wp), public, parameter :: muon_mass_in_u = 0.1134289259_wp muon mass in u (u) real(kind=wp), public, parameter :: muon_molar_mass = 1.134289259e-4_wp muon molar mass (kg mol&#94;-1) real(kind=wp), public, parameter :: muon_neutron_mass_ratio = 0.1124545170_wp muon-neutron mass ratio (dimensionless) real(kind=wp), public, parameter :: muon_proton_mag__mom__ratio = -3.183345142_wp muon-proton mag. mom. ratio (dimensionless) real(kind=wp), public, parameter :: muon_proton_mass_ratio = 0.1126095264_wp muon-proton mass ratio (dimensionless) real(kind=wp), public, parameter :: muon_tau_mass_ratio = 5.94635e-2_wp muon-tau mass ratio (dimensionless) real(kind=wp), public, parameter :: natural_unit_of_action = 1.054571817e-34_wp natural unit of action (J s) real(kind=wp), public, parameter :: natural_unit_of_action_in_eV_s = 6.582119569e-16_wp natural unit of action in eV s (eV s) real(kind=wp), public, parameter :: natural_unit_of_energy = 8.1871057769e-14_wp natural unit of energy (J) real(kind=wp), public, parameter :: natural_unit_of_energy_in_MeV = 0.51099895000_wp natural unit of energy in MeV (MeV) real(kind=wp), public, parameter :: natural_unit_of_length = 3.8615926796e-13_wp natural unit of length (m) real(kind=wp), public, parameter :: natural_unit_of_mass = 9.1093837015e-31_wp natural unit of mass (kg) real(kind=wp), public, parameter :: natural_unit_of_momentum = 2.73092453075e-22_wp natural unit of momentum (kg m s&#94;-1) real(kind=wp), public, parameter :: natural_unit_of_momentum_in_MeV_c = 0.51099895000_wp natural unit of momentum in MeV/c (MeV/c) real(kind=wp), public, parameter :: natural_unit_of_time = 1.28808866819e-21_wp natural unit of time (s) real(kind=wp), public, parameter :: natural_unit_of_velocity = 299792458e0_wp natural unit of velocity (m s&#94;-1) real(kind=wp), public, parameter :: neutron_Compton_wavelength = 1.31959090581e-15_wp neutron Compton wavelength (m) real(kind=wp), public, parameter :: neutron_electron_mag__mom__ratio = 1.04066882e-3_wp neutron-electron mag. mom. ratio (dimensionless) real(kind=wp), public, parameter :: neutron_electron_mass_ratio = 1838.68366173_wp neutron-electron mass ratio (dimensionless) real(kind=wp), public, parameter :: neutron_g_factor = -3.82608545_wp neutron g factor (dimensionless) real(kind=wp), public, parameter :: neutron_gyromag__ratio = 1.83247171e8_wp neutron gyromag. ratio (s&#94;-1 T&#94;-1) real(kind=wp), public, parameter :: neutron_gyromag__ratio_in_MHz_T = 29.1646931_wp neutron gyromag. ratio in MHz/T (MHz T&#94;-1) real(kind=wp), public, parameter :: neutron_mag__mom_ = -9.6623651e-27_wp neutron mag. mom. (J T&#94;-1) real(kind=wp), public, parameter :: neutron_mag__mom__to_Bohr_magneton_ratio = -1.04187563e-3_wp neutron mag. mom. to Bohr magneton ratio (dimensionless) real(kind=wp), public, parameter :: neutron_mag__mom__to_nuclear_magneton_ratio = -1.91304273_wp neutron mag. mom. to nuclear magneton ratio (dimensionless) real(kind=wp), public, parameter :: neutron_mass = 1.67492749804e-27_wp neutron mass (kg) real(kind=wp), public, parameter :: neutron_mass_energy_equivalent = 1.50534976287e-10_wp neutron mass energy equivalent (J) real(kind=wp), public, parameter :: neutron_mass_energy_equivalent_in_MeV = 939.56542052_wp neutron mass energy equivalent in MeV (MeV) real(kind=wp), public, parameter :: neutron_mass_in_u = 1.00866491595_wp neutron mass in u (u) real(kind=wp), public, parameter :: neutron_molar_mass = 1.00866491560e-3_wp neutron molar mass (kg mol&#94;-1) real(kind=wp), public, parameter :: neutron_muon_mass_ratio = 8.89248406_wp neutron-muon mass ratio (dimensionless) real(kind=wp), public, parameter :: neutron_proton_mag__mom__ratio = -0.68497934_wp neutron-proton mag. mom. ratio (dimensionless) real(kind=wp), public, parameter :: neutron_proton_mass_difference = 2.30557435e-30_wp neutron-proton mass difference (kg) real(kind=wp), public, parameter :: neutron_proton_mass_difference_energy_equivalent = 2.07214689e-13_wp neutron-proton mass difference energy equivalent (J) real(kind=wp), public, parameter :: neutron_proton_mass_difference_energy_equivalent_in_MeV = 1.29333236_wp neutron-proton mass difference energy equivalent in MeV (MeV) real(kind=wp), public, parameter :: neutron_proton_mass_difference_in_u = 1.38844933e-3_wp neutron-proton mass difference in u (u) real(kind=wp), public, parameter :: neutron_proton_mass_ratio = 1.00137841931_wp neutron-proton mass ratio (dimensionless) real(kind=wp), public, parameter :: neutron_relative_atomic_mass = 1.00866491595_wp neutron relative atomic mass (dimensionless) real(kind=wp), public, parameter :: neutron_tau_mass_ratio = 0.528779_wp neutron-tau mass ratio (dimensionless) real(kind=wp), public, parameter :: neutron_to_shielded_proton_mag__mom__ratio = -0.68499694_wp neutron to shielded proton mag. mom. ratio (dimensionless) real(kind=wp), public, parameter :: nuclear_magneton = 5.0507837461e-27_wp nuclear magneton (J T&#94;-1) real(kind=wp), public, parameter :: nuclear_magneton_in_K_T = 3.6582677756e-4_wp nuclear magneton in K/T (K T&#94;-1) real(kind=wp), public, parameter :: nuclear_magneton_in_MHz_T = 7.6225932291_wp nuclear magneton in MHz/T (MHz T&#94;-1) real(kind=wp), public, parameter :: nuclear_magneton_in_eV_T = 3.15245125844e-8_wp nuclear magneton in eV/T (eV T&#94;-1) real(kind=wp), public, parameter :: nuclear_magneton_in_inverse_meter_per_tesla = 2.54262341353e-2_wp nuclear magneton in inverse meter per tesla (m&#94;-1 T&#94;-1) real(kind=wp), public, parameter :: proton_Compton_wavelength = 1.32140985539e-15_wp proton Compton wavelength (m) real(kind=wp), public, parameter :: proton_charge_to_mass_quotient = 9.5788331560e7_wp proton charge to mass quotient (C kg&#94;-1) real(kind=wp), public, parameter :: proton_electron_mass_ratio = 1836.15267343_wp proton-electron mass ratio (dimensionless) real(kind=wp), public, parameter :: proton_g_factor = 5.5856946893_wp proton g factor (dimensionless) real(kind=wp), public, parameter :: proton_gyromag__ratio = 2.6752218744e8_wp proton gyromag. ratio (s&#94;-1 T&#94;-1) real(kind=wp), public, parameter :: proton_gyromag__ratio_in_MHz_T = 42.577478518_wp proton gyromag. ratio in MHz/T (MHz T&#94;-1) real(kind=wp), public, parameter :: proton_mag__mom_ = 1.41060679736e-26_wp proton mag. mom. (J T&#94;-1) real(kind=wp), public, parameter :: proton_mag__mom__to_Bohr_magneton_ratio = 1.52103220230e-3_wp proton mag. mom. to Bohr magneton ratio (dimensionless) real(kind=wp), public, parameter :: proton_mag__mom__to_nuclear_magneton_ratio = 2.79284734463_wp proton mag. mom. to nuclear magneton ratio (dimensionless) real(kind=wp), public, parameter :: proton_mag__shielding_correction = 2.5689e-5_wp proton mag. shielding correction (dimensionless) real(kind=wp), public, parameter :: proton_mass = 1.67262192369e-27_wp proton mass (kg) real(kind=wp), public, parameter :: proton_mass_energy_equivalent = 1.50327761598e-10_wp proton mass energy equivalent (J) real(kind=wp), public, parameter :: proton_mass_energy_equivalent_in_MeV = 938.27208816_wp proton mass energy equivalent in MeV (MeV) real(kind=wp), public, parameter :: proton_mass_in_u = 1.007276466621_wp proton mass in u (u) real(kind=wp), public, parameter :: proton_molar_mass = 1.00727646627e-3_wp proton molar mass (kg mol&#94;-1) real(kind=wp), public, parameter :: proton_muon_mass_ratio = 8.88024337_wp proton-muon mass ratio (dimensionless) real(kind=wp), public, parameter :: proton_neutron_mag__mom__ratio = -1.45989805_wp proton-neutron mag. mom. ratio (dimensionless) real(kind=wp), public, parameter :: proton_neutron_mass_ratio = 0.99862347812_wp proton-neutron mass ratio (dimensionless) real(kind=wp), public, parameter :: proton_relative_atomic_mass = 1.007276466621_wp proton relative atomic mass (dimensionless) real(kind=wp), public, parameter :: proton_rms_charge_radius = 8.414e-16_wp proton rms charge radius (m) real(kind=wp), public, parameter :: proton_tau_mass_ratio = 0.528051_wp proton-tau mass ratio (dimensionless) real(kind=wp), public, parameter :: quantum_of_circulation = 3.6369475516e-4_wp quantum of circulation (m&#94;2 s&#94;-1) real(kind=wp), public, parameter :: quantum_of_circulation_times_2 = 7.2738951032e-4_wp quantum of circulation times 2 (m&#94;2 s&#94;-1) real(kind=wp), public, parameter :: reduced_Compton_wavelength = 3.8615926796e-13_wp reduced Compton wavelength (m) real(kind=wp), public, parameter :: reduced_Planck_constant = 1.054571817e-34_wp reduced Planck constant (J s) real(kind=wp), public, parameter :: reduced_Planck_constant_in_eV_s = 6.582119569e-16_wp reduced Planck constant in eV s (eV s) real(kind=wp), public, parameter :: reduced_Planck_constant_times_c_in_MeV_fm = 197.3269804_wp reduced Planck constant times c in MeV fm (MeV fm) real(kind=wp), public, parameter :: reduced_muon_Compton_wavelength = 1.867594306e-15_wp reduced muon Compton wavelength (m) real(kind=wp), public, parameter :: reduced_neutron_Compton_wavelength = 2.1001941552e-16_wp reduced neutron Compton wavelength (m) real(kind=wp), public, parameter :: reduced_proton_Compton_wavelength = 2.10308910336e-16_wp reduced proton Compton wavelength (m) real(kind=wp), public, parameter :: reduced_tau_Compton_wavelength = 1.110538e-16_wp reduced tau Compton wavelength (m) real(kind=wp), public, parameter :: second_radiation_constant = 1.438776877e-2_wp second radiation constant (m K) real(kind=wp), public, parameter :: shielded_helion_gyromag__ratio = 2.037894569e8_wp shielded helion gyromag. ratio (s&#94;-1 T&#94;-1) real(kind=wp), public, parameter :: shielded_helion_gyromag__ratio_in_MHz_T = 32.43409942_wp shielded helion gyromag. ratio in MHz/T (MHz T&#94;-1) real(kind=wp), public, parameter :: shielded_helion_mag__mom_ = -1.074553090e-26_wp shielded helion mag. mom. (J T&#94;-1) real(kind=wp), public, parameter :: shielded_helion_mag__mom__to_Bohr_magneton_ratio = -1.158671471e-3_wp shielded helion mag. mom. to Bohr magneton ratio (dimensionless) real(kind=wp), public, parameter :: shielded_helion_mag__mom__to_nuclear_magneton_ratio = -2.127497719_wp shielded helion mag. mom. to nuclear magneton ratio (dimensionless) real(kind=wp), public, parameter :: shielded_helion_to_proton_mag__mom__ratio = -0.7617665618_wp shielded helion to proton mag. mom. ratio (dimensionless) real(kind=wp), public, parameter :: shielded_helion_to_shielded_proton_mag__mom__ratio = -0.7617861313_wp shielded helion to shielded proton mag. mom. ratio (dimensionless) real(kind=wp), public, parameter :: shielded_proton_gyromag__ratio = 2.675153151e8_wp shielded proton gyromag. ratio (s&#94;-1 T&#94;-1) real(kind=wp), public, parameter :: shielded_proton_gyromag__ratio_in_MHz_T = 42.57638474_wp shielded proton gyromag. ratio in MHz/T (MHz T&#94;-1) real(kind=wp), public, parameter :: shielded_proton_mag__mom_ = 1.410570560e-26_wp shielded proton mag. mom. (J T&#94;-1) real(kind=wp), public, parameter :: shielded_proton_mag__mom__to_Bohr_magneton_ratio = 1.520993128e-3_wp shielded proton mag. mom. to Bohr magneton ratio (dimensionless) real(kind=wp), public, parameter :: shielded_proton_mag__mom__to_nuclear_magneton_ratio = 2.792775599_wp shielded proton mag. mom. to nuclear magneton ratio (dimensionless) real(kind=wp), public, parameter :: shielding_difference_of_d_and_p_in_HD = 2.0200e-8_wp shielding difference of d and p in HD (dimensionless) real(kind=wp), public, parameter :: shielding_difference_of_t_and_p_in_HT = 2.4140e-8_wp shielding difference of t and p in HT (dimensionless) real(kind=wp), public, parameter :: speed_of_light_in_vacuum = 299792458e0_wp speed of light in vacuum (m s&#94;-1) real(kind=wp), public, parameter :: standard_acceleration_of_gravity = 9.80665_wp standard acceleration of gravity (m s&#94;-2) real(kind=wp), public, parameter :: standard_atmosphere = 101325e0_wp standard atmosphere (Pa) real(kind=wp), public, parameter :: standard_state_pressure = 100000e0_wp standard-state pressure (Pa) real(kind=wp), public, parameter :: tau_Compton_wavelength = 6.97771e-16_wp tau Compton wavelength (m) real(kind=wp), public, parameter :: tau_electron_mass_ratio = 3477.23_wp tau-electron mass ratio (dimensionless) real(kind=wp), public, parameter :: tau_energy_equivalent = 1776.86_wp tau energy equivalent (MeV) real(kind=wp), public, parameter :: tau_mass = 3.16754e-27_wp tau mass (kg) real(kind=wp), public, parameter :: tau_mass_energy_equivalent = 2.84684e-10_wp tau mass energy equivalent (J) real(kind=wp), public, parameter :: tau_mass_in_u = 1.90754_wp tau mass in u (u) real(kind=wp), public, parameter :: tau_molar_mass = 1.90754e-3_wp tau molar mass (kg mol&#94;-1) real(kind=wp), public, parameter :: tau_muon_mass_ratio = 16.8170_wp tau-muon mass ratio (dimensionless) real(kind=wp), public, parameter :: tau_neutron_mass_ratio = 1.89115_wp tau-neutron mass ratio (dimensionless) real(kind=wp), public, parameter :: tau_proton_mass_ratio = 1.89376_wp tau-proton mass ratio (dimensionless) real(kind=wp), public, parameter :: triton_electron_mass_ratio = 5496.92153573_wp triton-electron mass ratio (dimensionless) real(kind=wp), public, parameter :: triton_g_factor = 5.957924931_wp triton g factor (dimensionless) real(kind=wp), public, parameter :: triton_mag__mom_ = 1.5046095202e-26_wp triton mag. mom. (J T&#94;-1) real(kind=wp), public, parameter :: triton_mag__mom__to_Bohr_magneton_ratio = 1.6223936651e-3_wp triton mag. mom. to Bohr magneton ratio (dimensionless) real(kind=wp), public, parameter :: triton_mag__mom__to_nuclear_magneton_ratio = 2.9789624656_wp triton mag. mom. to nuclear magneton ratio (dimensionless) real(kind=wp), public, parameter :: triton_mass = 5.0073567446e-27_wp triton mass (kg) real(kind=wp), public, parameter :: triton_mass_energy_equivalent = 4.5003878060e-10_wp triton mass energy equivalent (J) real(kind=wp), public, parameter :: triton_mass_energy_equivalent_in_MeV = 2808.92113298_wp triton mass energy equivalent in MeV (MeV) real(kind=wp), public, parameter :: triton_mass_in_u = 3.01550071621_wp triton mass in u (u) real(kind=wp), public, parameter :: triton_molar_mass = 3.01550071517e-3_wp triton molar mass (kg mol&#94;-1) real(kind=wp), public, parameter :: triton_proton_mass_ratio = 2.99371703414_wp triton-proton mass ratio (dimensionless) real(kind=wp), public, parameter :: triton_relative_atomic_mass = 3.01550071621_wp triton relative atomic mass (dimensionless) real(kind=wp), public, parameter :: triton_to_proton_mag__mom__ratio = 1.0666399191_wp triton to proton mag. mom. ratio (dimensionless) real(kind=wp), public, parameter :: unified_atomic_mass_unit = 1.66053906660e-27_wp unified atomic mass unit (kg) real(kind=wp), public, parameter :: vacuum_electric_permittivity = 8.8541878128e-12_wp vacuum electric permittivity (F m&#94;-1) real(kind=wp), public, parameter :: vacuum_mag__permeability = 1.25663706212e-6_wp vacuum mag. permeability (N A&#94;-2) real(kind=wp), public, parameter :: von_Klitzing_constant = 25812.80745_wp von Klitzing constant (ohm) real(kind=wp), public, parameter :: weak_mixing_angle = 0.22290_wp weak mixing angle (dimensionless)","tags":"","loc":"module/mctc_io_codata2018.html"},{"title":"mctc_io_read_qcschema – MCTC-library","text":"Uses json_value_module mctc_io_structure mctc_io_utils mctc_env_error mctc_env_accuracy mctc_io_symbols Subroutines public  subroutine read_qcschema (self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_qcschema.html"},{"title":"mctc_io – MCTC-library","text":"Input and output module of the tool chain library. This module exports the basic structure_type as well as routines\nto read it from a file or formatted unit ( read_structure ) or write\nit to a formatted unit ( write_structure ). Both read_structure and write_structure take format hints from\nthe filetype enumerator. File names can be translated to the respective\nenumerator by using the get_filetype function. This can be useful in\ncase the caller routine wants to open the formatted unit itself or uses\na non-standard file extension. Uses mctc_io_filetype mctc_io_structure mctc_io_read mctc_io_symbols mctc_io_write","tags":"","loc":"module/mctc_io.html"},{"title":"mctc_io_structure – MCTC-library","text":"Basic structure representation of the system of interest Uses mctc_env_accuracy mctc_io_structure_info mctc_io_symbols Interfaces public        interface new public  subroutine new_structure (self, num, sym, xyz, charge, uhf, lattice, periodic, info, bond) Constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation integer, intent(in) :: num (:) Atomic numbers character(len=*), intent(in) :: sym (:) Element symbols real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information integer, intent(in), optional :: bond (:,:) Bond topology of the system private  subroutine new_structure_num(self, num, xyz, charge, uhf, lattice, periodic, info, bond) Simplified constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation integer, intent(in) :: num (:) Atomic numbers real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information integer, intent(in), optional :: bond (:,:) Bond topology of the system private  subroutine new_structure_sym(self, sym, xyz, charge, uhf, lattice, periodic, info, bond) Simplified constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation character(len=*), intent(in) :: sym (:) Element symbols real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information integer, intent(in), optional :: bond (:,:) Bond topology of the system Derived Types type, public :: structure_type Structure representation Components Type Visibility Attributes Name Initial integer, public, allocatable :: bond (:,:) Bond indices real(kind=wp), public :: charge = 0.0_wp Total charge character(len=:), public, allocatable :: comment Comment, name or identifier for this structure integer, public, allocatable :: id (:) Species identifier type( structure_info ), public :: info = structure_info() Vendor specific structure annotations real(kind=wp), public, allocatable :: lattice (:,:) Lattice parameters integer, public :: nat = 0 Number of atoms integer, public :: nbd = 0 Number of bonds integer, public :: nid = 0 Number of unique species integer, public, allocatable :: num (:) Atomic number for each species type( pdb_data ), public, allocatable :: pdb (:) PDB atomic data annotations logical, public, allocatable :: periodic (:) Periodic directions type( sdf_data ), public, allocatable :: sdf (:) SDF atomic data annotations character(len=symbol_length), public, allocatable :: sym (:) Element symbol for each species integer, public :: uhf = 0 Number of unpaired electrons real(kind=wp), public, allocatable :: xyz (:,:) Cartesian coordinates, in Bohr Subroutines public  subroutine new_structure (self, num, sym, xyz, charge, uhf, lattice, periodic, info, bond) Constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation integer, intent(in) :: num (:) Atomic numbers character(len=*), intent(in) :: sym (:) Element symbols real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information integer, intent(in), optional :: bond (:,:) Bond topology of the system","tags":"","loc":"module/mctc_io_structure.html"},{"title":"mctc_io_write_vasp – MCTC-library","text":"Uses mctc_env_accuracy mctc_io_math mctc_io_structure mctc_io_convert Subroutines public  subroutine write_vasp (self, unit, comment_line) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: comment_line","tags":"","loc":"module/mctc_io_write_vasp.html"},{"title":"mctc_io_write_aims – MCTC-library","text":"Uses mctc_env_accuracy mctc_io_structure mctc_io_convert Subroutines public  subroutine write_aims (self, unit) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle","tags":"","loc":"module/mctc_io_write_aims.html"},{"title":"mctc_env – MCTC-library","text":"Public API reexport of environment library Uses mctc_env_accuracy mctc_env_error mctc_env_system","tags":"","loc":"module/mctc_env.html"},{"title":"mctc_io_read_turbomole – MCTC-library","text":"Uses mctc_io_resize mctc_io_structure mctc_io_structure_info mctc_io_utils mctc_io_constants mctc_env_error mctc_io_convert mctc_env_accuracy mctc_io_symbols Subroutines public  subroutine read_coord (mol, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: mol Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_turbomole.html"},{"title":"mctc_version – MCTC-library","text":"Variables Type Visibility Attributes Name Initial integer, public, parameter :: mctc_version_compact (3) = [0, 3, 2] Numeric representation of the mctc-lib version character(len=*), public, parameter :: mctc_version_string = \"0.3.2\" String representation of the mctc-lib version Functions public pure function get_mctc_feature (feature) result(has_feature) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: feature Feature name Return Value logical Whether the feature is enabled Subroutines public pure subroutine get_mctc_version (major, minor, patch, string) Getter function to retrieve mctc-lib version Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: major Major version number of the mctc-lib version integer, intent(out), optional :: minor Minor version number of the mctc-lib version integer, intent(out), optional :: patch Patch version number of the mctc-lib version character(len=:), intent(out), optional, allocatable :: string String representation of the mctc-lib version","tags":"","loc":"module/mctc_version.html"},{"title":"mctc_io_read_cjson – MCTC-library","text":"Uses json_value_module mctc_io_structure mctc_io_utils mctc_io_constants mctc_env_error mctc_io_convert mctc_env_accuracy mctc_io_symbols Subroutines public  subroutine read_cjson (self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_cjson.html"},{"title":"mctc_io_symbols – MCTC-library","text":"Handle conversion between element symbols and atomic numbers Uses mctc_io_resize Variables Type Visibility Attributes Name Initial integer, public, parameter :: symbol_length = 4 Maximum allowed length of element symbols Interfaces public        interface get_identity Get chemical identity private pure subroutine get_identity_number(nid, identity, number) Get chemical identity from a list of atomic numbers Arguments Type Intent Optional Attributes Name integer, intent(out) :: nid Number of unique species integer, intent(out) :: identity (:) Chemical identity integer, intent(in) :: number (:) Ordinal numbers private pure subroutine get_identity_symbol(nid, identity, symbol) Get chemical identity from a list of element symbols Arguments Type Intent Optional Attributes Name integer, intent(out) :: nid Number of unique species integer, intent(out) :: identity (:) Chemical identity character(len=*), intent(in) :: symbol (:) Element symbols Functions public elemental function to_lcsymbol (number) result(symbol) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name integer, intent(in) :: number Atomic number Return Value character(len=2) Element symbol public elemental function to_number (symbol) result(number) Convert element symbol to atomic number Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: symbol Element symbol Return Value integer Atomic number public elemental function to_symbol (number) result(symbol) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name integer, intent(in) :: number Atomic number Return Value character(len=2) Element symbol Subroutines public pure subroutine collect_identical (identity, mapping) Establish a mapping between unique atom types and species Arguments Type Intent Optional Attributes Name integer, intent(in) :: identity (:) Chemical identity integer, intent(out) :: mapping (:) Mapping from unique atoms public elemental subroutine number_to_lcsymbol (symbol, number) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name character(len=2), intent(out) :: symbol Element symbol integer, intent(in) :: number Atomic number public elemental subroutine number_to_symbol (symbol, number) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name character(len=2), intent(out) :: symbol Element symbol integer, intent(in) :: number Atomic number public elemental subroutine symbol_to_number (number, symbol) Convert element symbol to atomic number Arguments Type Intent Optional Attributes Name integer, intent(out) :: number Atomic number character(len=*), intent(in) :: symbol Element symbol","tags":"","loc":"module/mctc_io_symbols.html"},{"title":"mctc_io_read_vasp – MCTC-library","text":"Uses mctc_io_resize mctc_io_structure mctc_io_structure_info mctc_io_utils mctc_env_error mctc_io_convert mctc_env_accuracy mctc_io_symbols Subroutines public  subroutine read_vasp (self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_vasp.html"},{"title":"mctc_io_write_turbomole – MCTC-library","text":"Uses mctc_env_accuracy mctc_io_structure mctc_io_convert Subroutines public  subroutine write_coord (mol, unit) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: mol integer, intent(in) :: unit","tags":"","loc":"module/mctc_io_write_turbomole.html"},{"title":"mctc_io_read_xyz – MCTC-library","text":"Uses mctc_io_structure mctc_io_utils mctc_env_error mctc_io_convert mctc_env_accuracy mctc_io_symbols Subroutines public  subroutine read_xyz (self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_xyz.html"},{"title":"mctc_io_write_qchem – MCTC-library","text":"Uses mctc_env_accuracy mctc_io_structure mctc_io_convert Subroutines public  subroutine write_qchem (self, unit) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle","tags":"","loc":"module/mctc_io_write_qchem.html"},{"title":"mctc_io_write_cjson – MCTC-library","text":"Uses mctc_io_structure mctc_io_constants mctc_io_math mctc_io_convert mctc_env_accuracy Subroutines public  subroutine write_cjson (mol, unit) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(in) :: mol integer, intent(in) :: unit","tags":"","loc":"module/mctc_io_write_cjson.html"},{"title":"mctc_io_read_gaussian – MCTC-library","text":"Uses mctc_env_accuracy mctc_env_error mctc_io_structure mctc_io_utils Subroutines public  subroutine read_gaussian_external (self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_gaussian.html"},{"title":"mctc_io_math – MCTC-library","text":"Simple algebraic functions Uses mctc_env_accuracy mctc_io_constants Functions public pure function crossprod (a, b) result(c) Implements the cross/vector product between two 3D vectors Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3) First vector real(kind=wp), intent(in) :: b (3) Second vector Return Value real(kind=wp), (3) Orthogonal vector public pure function matdet_3x3 (a) result(det) Determinant of 3×3 matrix Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3,3) Matrix Return Value real(kind=wp) Determinant public pure function matinv_3x3 (a) result(b) Performs a direct calculation of the inverse of a 3×3 matrix. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3,3) Matrix Return Value real(kind=wp), (3,3) Inverse matrix Subroutines public pure subroutine eigval_3x3 (a, w) Calculates eigenvalues based on the trigonometric solution of A = pB + qI Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3,3) The symmetric input matrix real(kind=wp), intent(out) :: w (3) Contains eigenvalues on exit public pure subroutine eigvec_3x3 (a, w, q) Calculates eigenvector using an analytical method based on vector cross Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (3,3) real(kind=wp), intent(out) :: w (3) real(kind=wp), intent(out) :: q (3,3)","tags":"","loc":"module/mctc_io_math.html"},{"title":"mctc_io_read_aims – MCTC-library","text":"Uses mctc_io_resize mctc_io_structure mctc_io_utils mctc_env_error mctc_io_convert mctc_env_accuracy mctc_io_symbols Subroutines public  subroutine read_aims (mol, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: mol Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_aims.html"},{"title":"mctc_env_system – MCTC-library","text":"Module collecting commands to conveniently interface with system commands Functions public  function is_unix () Try to determine if we run on Unix and probably can rely on POSIX compliance Arguments None Return Value logical Operating system seems to be Unix public  function is_windows () Try to determine if we run on Windows and don’t have POSIX compliance around Arguments None Return Value logical Operating system seems to be Windows Subroutines public  subroutine get_argument (idx, arg) Obtain the command line argument at a given index Arguments Type Intent Optional Attributes Name integer, intent(in) :: idx Index of command line argument, range [0:command_argument_count()] character(len=:), intent(out), allocatable :: arg Command line argument public  subroutine get_variable (var, val) Obtain the value of an environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var Name of variable character(len=:), intent(out), allocatable :: val Value of variable","tags":"","loc":"module/mctc_env_system.html"},{"title":"mctc_io_read_genformat – MCTC-library","text":"Uses mctc_io_structure mctc_io_structure_info mctc_io_utils mctc_io_constants mctc_env_error mctc_io_convert mctc_env_accuracy mctc_io_symbols Subroutines public  subroutine read_genformat (mol, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: mol Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_genformat.html"},{"title":"mctc_io_write_genformat – MCTC-library","text":"Uses mctc_io_structure mctc_io_constants mctc_io_math mctc_io_convert mctc_env_accuracy mctc_io_symbols Subroutines public  subroutine write_genformat (mol, unit) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: mol integer, intent(in) :: unit","tags":"","loc":"module/mctc_io_write_genformat.html"},{"title":"mctc_io_filetype – MCTC-library","text":"File type support Variables Type Visibility Attributes Name Initial type(enum_filetype), public, parameter :: filetype = enum_filetype() File type enumerator Functions public elemental function get_filetype (file) result(ftype) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file Name of the file Return Value integer File type from extension","tags":"","loc":"module/mctc_io_filetype.html"},{"title":"mctc_io_constants – MCTC-library","text":"Numerical constants Uses mctc_env_accuracy mctc_io_codata2018 Variables Type Visibility Attributes Name Initial type(enum_codata), public, parameter :: codata = enum_codata() Actual collection of natural constants real(kind=wp), public, parameter :: pi = 3.1415926535897932384626433832795029_wp Ratio between a circles diameter and its circumfence","tags":"","loc":"module/mctc_io_constants.html"},{"title":"mctc_io_write_pdb – MCTC-library","text":"Uses mctc_env_accuracy mctc_io_structure mctc_io_convert Subroutines public  subroutine write_pdb (mol, unit, number) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(in) :: mol integer, intent(in) :: unit integer, intent(in), optional :: number","tags":"","loc":"module/mctc_io_write_pdb.html"},{"title":"mctc_io_read_pdb – MCTC-library","text":"Uses mctc_io_resize mctc_io_structure mctc_io_structure_info mctc_io_utils mctc_env_error mctc_io_convert mctc_env_accuracy mctc_io_symbols Subroutines public  subroutine read_pdb (self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_pdb.html"},{"title":"mctc_io_convert – MCTC-library","text":"Conversion factors Uses mctc_env_accuracy mctc_io_constants Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: aatoau = 1.0_wp/autoaa Conversion factor from Ångström to bohr real(kind=wp), public, parameter :: autoaa = bohr*1e10_wp Conversion factor from bohr to Ångström real(kind=wp), public, parameter :: autoc = codata%e Coulomb to atomic charge units real(kind=wp), public, parameter :: autoeV = hartree/codata%e Conversion factor from hartree to electron volts real(kind=wp), public, parameter :: autogmol = codata%me*codata%na*1e+3_wp Molecular mass per mole (g/mol) to electron mass (a.u.) real(kind=wp), public, parameter :: autokcal = autokJ*Jtocal Conversion from hartree to kcal/mol real(kind=wp), public, parameter :: autokg = codata%me Conversion from electron mass (a.u.) to kg real(kind=wp), public, parameter :: autokj = hartree*codata%na*1e-3_wp Conversion from hartree to kJ/mol real(kind=wp), public, parameter :: autonm = codata%h*codata%c/hartree*1e+9_wp Conversion from hartree to nanometers (wavelength) real(kind=wp), public, parameter :: autorcm = hartree/(codata%h*codata%c)*1e-2_wp Conversion from hartree to reciprocal centimeters real(kind=wp), public, parameter :: caltoj = 4.184_wp Conversion factor between calorie and joule real(kind=wp), public, parameter :: ctoau = 1.0_wp/autoc Atomic charge units to Coulomb real(kind=wp), public, parameter :: evtoau = 1.0_wp/autoev Conversion factor from electron volts to hartree real(kind=wp), public, parameter :: gmoltoau = 1.0_wp/autogmol Electron mass (a.u.) to molecular mass per mole (g/mol) real(kind=wp), public, parameter :: gmoltokg = gmoltoau*autokg Molecular mass per mole (g/mol) to kg real(kind=wp), public, parameter :: jtocal = 1.0_wp/caltoj Conversion factor between joule and calorie real(kind=wp), public, parameter :: kcaltoau = 1.0_wp/autokcal Conversion from kcal/mol to hartree real(kind=wp), public, parameter :: kgtoau = 1.0_wp/autokg Conversion from kg to electron mass (a.u.) real(kind=wp), public, parameter :: kgtogmol = 1.0_wp/gmoltokg kg to molecular mass per mole (g/mol) real(kind=wp), public, parameter :: kjtoau = 1.0_wp/autokj Conversion from kJ/mol to hartree real(kind=wp), public, parameter :: nmtoau = 1.0_wp/autonm Conversion from nanometers (wavelength) to hartree real(kind=wp), public, parameter :: rcmtoau = 1.0_wp/autorcm Conversion from reciprocal centimeters to hartree","tags":"","loc":"module/mctc_io_convert.html"},{"title":"mctc_env_accuracy – MCTC-library","text":"Numerical storage size parameters for real and integer values Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(15) Double precision real numbers integer, public, parameter :: i1 = selected_int_kind(2) Char length for integers integer, public, parameter :: i2 = selected_int_kind(4) Short length for integers integer, public, parameter :: i4 = selected_int_kind(9) Length of default integers integer, public, parameter :: i8 = selected_int_kind(18) Long length for integers integer, public, parameter :: sp = selected_real_kind(6) Single precision real numbers integer, public, parameter :: wp = dp Wanted precision","tags":"","loc":"module/mctc_env_accuracy.html"},{"title":"mctc_io_write_ctfile – MCTC-library","text":"Uses mctc_env_accuracy mctc_io_structure mctc_io_convert Subroutines public  subroutine write_molfile (self, unit, comment_line) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: comment_line public  subroutine write_sdf (self, unit, energy, gnorm) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self integer, intent(in) :: unit real(kind=wp), intent(in), optional :: energy real(kind=wp), intent(in), optional :: gnorm","tags":"","loc":"module/mctc_io_write_ctfile.html"},{"title":"mctc_io_read_ctfile – MCTC-library","text":"Uses mctc_io_structure mctc_io_structure_info mctc_io_utils mctc_env_error mctc_io_convert mctc_env_accuracy mctc_io_symbols Subroutines public  subroutine read_molfile (self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling public  subroutine read_sdf (self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_ctfile.html"},{"title":"mctc_io_read – MCTC-library","text":"Uses mctc_io_filetype mctc_io_read_ctfile mctc_io_structure mctc_io_read_cjson mctc_io_read_qchem mctc_io_read_turbomole mctc_io_read_aims mctc_env_error mctc_io_read_genformat mctc_io_read_qcschema mctc_io_read_xyz mctc_io_read_pdb mctc_io_read_vasp mctc_io_read_gaussian Interfaces public        interface read_structure private  subroutine read_structure_from_file(self, file, error, format) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data character(len=*), intent(in) :: file Name of the file to read type( error_type ), intent(out), allocatable :: error Error handling integer, intent(in), optional :: format File type format hint private  subroutine read_structure_from_unit(self, unit, ftype, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle integer, intent(in) :: ftype File type to read type( error_type ), intent(out), allocatable :: error Error handling Abstract Interfaces abstract interface public  subroutine structure_reader(self, unit, error) Read molecular structure data from formatted unit Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Subroutines public  subroutine get_structure_reader (reader, ftype) Retrieve reader for corresponding file type Arguments Type Intent Optional Attributes Name procedure( structure_reader ), intent(out), pointer :: reader Reader for the specified file type integer, intent(in) :: ftype File type to read","tags":"","loc":"module/mctc_io_read.html"},{"title":"main – MCTC-library","text":"Uses iso_fortran_env mctc_env mctc_io mctc_version Example application using tool chain library. This program uses the read_structure and write_structure procedures\nto implement a structure converter.\nUsually, the input structure can be inferred by the name of the input file.\nTo allow formats with non-standard extensions (because most geometry formats\nare not really standardized) additional hints can be passed by the command\nline to determine the read/write formats. To add support for piping standard input and standard output reading and\nwriting from units is combined with the additional format hints. Additional filters or modifications can also be implemented in an intermediary\nstep, this program implements an element symbol normalization. Other filters\nlike folding back to central cells or removing lattice vector could be added\nin a similar manner. Variables Type Attributes Name Initial integer :: charge type( error_type ), allocatable :: error character(len=:), allocatable :: filename character(len=:), allocatable :: input integer, allocatable :: input_format type( structure_type ) :: mol type( structure_type ), allocatable :: mol_template logical :: normalize character(len=:), allocatable :: output integer, allocatable :: output_format character(len=*), parameter :: prog_name = \"mctc-convert\" logical :: read_dot_files character(len=:), allocatable :: template integer, allocatable :: template_format integer :: unpaired Functions function dirname (filename) Extract dirname from path Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value character(len=:), allocatable function exists (filename) test if pathname already exists Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical function join (a1, a2) result(path) Construct path by joining strings with os file separator Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a1 character(len=*), intent(in) :: a2 Return Value character(len=:), allocatable Subroutines subroutine get_arguments (input, input_format, output, output_format, normalize, template, template_format, read_dot_files, error) Arguments Type Intent Optional Attributes Name character(len=:), allocatable :: input Input file name integer, intent(out), allocatable :: input_format Input file format character(len=:), allocatable :: output Output file name integer, intent(out), allocatable :: output_format Output file format logical, intent(out) :: normalize Normalize element symbols character(len=:), allocatable :: template Template file name integer, intent(out), allocatable :: template_format Template file format logical, intent(out) :: read_dot_files Read information from .CHRG and .UHF files type( error_type ), intent(out), allocatable :: error Error handling subroutine help (unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit subroutine read_file (filename, val, error) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer, intent(out) :: val type( error_type ), intent(out), allocatable :: error subroutine version (unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Source Code program main use , intrinsic :: iso_fortran_env , only : output_unit , error_unit , input_unit use mctc_env , only : error_type , fatal_error , get_argument , wp use mctc_io , only : structure_type , read_structure , write_structure , & & filetype , get_filetype , to_symbol use mctc_version , only : get_mctc_version implicit none character ( len =* ), parameter :: prog_name = \"mctc-convert\" character ( len = :), allocatable :: input , output , template , filename integer , allocatable :: input_format , output_format , template_format type ( structure_type ) :: mol type ( structure_type ), allocatable :: mol_template type ( error_type ), allocatable :: error logical :: normalize , read_dot_files integer :: charge , unpaired call get_arguments ( input , input_format , output , output_format , normalize , & & template , template_format , read_dot_files , error ) if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if if ( allocated ( template )) then allocate ( mol_template ) if ( template == \"-\" ) then if (. not . allocated ( template_format )) then template_format = merge ( output_format , filetype % xyz , allocated ( output_format )) end if call read_structure ( mol_template , input_unit , template_format , error ) else call read_structure ( mol_template , template , error , template_format ) end if if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if end if if ( input == \"-\" ) then if (. not . allocated ( input_format )) input_format = filetype % xyz call read_structure ( mol , input_unit , input_format , error ) else call read_structure ( mol , input , error , input_format ) if ( read_dot_files ) then charge = nint ( mol % charge ) if (. not . allocated ( error )) then filename = join ( dirname ( input ), \".CHRG\" ) if ( exists ( filename )) call read_file ( filename , charge , error ) end if mol % charge = charge unpaired = mol % uhf if (. not . allocated ( error )) then filename = join ( dirname ( input ), \".UHF\" ) if ( exists ( filename )) call read_file ( filename , unpaired , error ) end if mol % uhf = unpaired end if end if if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if if ( allocated ( mol_template )) then if ( mol % nat /= mol_template % nat ) then write ( error_unit , '(*(a, 1x))' ) & \"Number of atoms missmatch in\" , template , \"and\" , input error stop end if ! move_alloc can also move non-allocated objects call move_alloc ( mol_template % lattice , mol % lattice ) call move_alloc ( mol_template % periodic , mol % periodic ) call move_alloc ( mol_template % bond , mol % bond ) call move_alloc ( mol_template % comment , mol % comment ) call move_alloc ( mol_template % pdb , mol % pdb ) call move_alloc ( mol_template % sdf , mol % sdf ) end if if ( normalize ) then mol % sym = to_symbol ( mol % num ) end if if ( output == \"-\" ) then if (. not . allocated ( output_format )) output_format = filetype % xyz call write_structure ( mol , output_unit , output_format , error ) else call write_structure ( mol , output , error , output_format ) end if if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if contains subroutine help ( unit ) integer , intent ( in ) :: unit write ( unit , '(a, *(1x, a))' ) & \"Usage: \" // prog_name // \" [options] <input> <output>\" write ( unit , '(a)' ) & \"\" , & \"Read structure from input file and writes it to output file.\" , & \"The format is determined by the file extension or the format hint\" , & \"\" write ( unit , '(2x, a, t25, a)' ) & \"-i, --input <format>\" , \"Hint for the format of the input file\" , & \"-o, --output <format>\" , \"Hint for the format of the output file\" , & \"--normalize\" , \"Normalize all element symbols to capitalized format\" , & \"--template <file>\" , \"File to use as template to fill in meta data\" , & \"\" , \"(useful to add back SDF or PDB annotions)\" , & \"--template-format <format>\" , \"\" , \"\" , \"Hint for the format of the template file\" , & \"--ignore-dot-files\" , \"Do not read charge and spin from .CHRG and .UHF files\" , & \"--version\" , \"Print program version and exit\" , & \"--help\" , \"Show this help message\" write ( unit , '(a)' ) end subroutine help subroutine version ( unit ) integer , intent ( in ) :: unit character ( len = :), allocatable :: version_string call get_mctc_version ( string = version_string ) write ( unit , '(a, *(1x, a))' ) & & prog_name , \"version\" , version_string end subroutine version subroutine get_arguments ( input , input_format , output , output_format , normalize , & & template , template_format , read_dot_files , error ) !> Input file name character ( len = :), allocatable :: input !> Input file format integer , allocatable , intent ( out ) :: input_format !> Output file name character ( len = :), allocatable :: output !> Output file format integer , allocatable , intent ( out ) :: output_format !> Template file name character ( len = :), allocatable :: template !> Template file format integer , allocatable , intent ( out ) :: template_format !> Normalize element symbols logical , intent ( out ) :: normalize !> Read information from .CHRG and .UHF files logical , intent ( out ) :: read_dot_files !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: iarg , narg character ( len = :), allocatable :: arg normalize = . false . read_dot_files = . true . iarg = 0 narg = command_argument_count () do while ( iarg < narg ) iarg = iarg + 1 call get_argument ( iarg , arg ) select case ( arg ) case ( \"--help\" ) call help ( output_unit ) stop case ( \"--version\" ) call version ( output_unit ) stop case default if (. not . allocated ( input )) then call move_alloc ( arg , input ) cycle end if if (. not . allocated ( output )) then call move_alloc ( arg , output ) cycle end if call fatal_error ( error , \"Too many positional arguments present\" ) exit case ( \"-i\" , \"--input\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for input format\" ) exit end if if ( index ( arg , \".\" ) == 0 ) arg = \".\" // arg input_format = get_filetype ( arg ) case ( \"-o\" , \"--output\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for output format\" ) exit end if output_format = get_filetype ( \".\" // arg ) case ( \"--normalize\" ) normalize = . true . case ( \"--template\" ) iarg = iarg + 1 call get_argument ( iarg , template ) if (. not . allocated ( template )) then call fatal_error ( error , \"Missing argument for template file\" ) exit end if case ( \"--template-format\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for template format\" ) exit end if template_format = get_filetype ( \".\" // arg ) case ( \"--ignore-dot-files\" ) read_dot_files = . false . end select end do if (. not .( allocated ( input ). and .( allocated ( output )))) then if (. not . allocated ( error )) then call help ( output_unit ) error stop end if end if end subroutine get_arguments !> Extract dirname from path function dirname ( filename ) character ( len =* ), intent ( in ) :: filename character ( len = :), allocatable :: dirname dirname = filename ( 1 : scan ( filename , \"/\\\", back=.true.)) if (len_trim(dirname) == 0) dirname = \" . \" end function dirname !> Construct path by joining strings with os file separator function join(a1, a2) result(path) use mctc_env_system, only : is_windows character(len=*), intent(in) :: a1, a2 character(len=:), allocatable :: path character :: filesep if (is_windows()) then filesep = '\\' else filesep = '/' end if path = a1 // filesep // a2 end function join !> test if pathname already exists function exists(filename) character(len=*), intent(in) :: filename logical :: exists inquire(file=filename, exist=exists) end function exists subroutine read_file(filename, val, error) use mctc_io_utils, only : next_line, read_next_token, io_error, token_type character(len=*), intent(in) :: filename integer, intent(out) :: val type(error_type), allocatable, intent(out) :: error integer :: io, stat, lnum, pos type(token_type) :: token character(len=:), allocatable :: line lnum = 0 open(file=filename, newunit=io, status='old', iostat=stat) if (stat /= 0) then call fatal_error(error, \" Error : Could not open file '\"//filename//\"' \") return end if call next_line(io, line, pos, lnum, stat) if (stat == 0) & call read_next_token(line, pos, token, val, stat) if (stat /= 0) then call io_error(error, \" Cannot read value from file \", line, token, & filename, lnum, \" expected integer value \" ) return end if close ( io , iostat = stat ) end subroutine read_file end program main","tags":"","loc":"program/main.html"},{"title":"testing.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Provides a light-weight testing framework for usage in projects depending on !> the tool chain library. !> !> Testsuites are defined by a [[collect_interface]] returning a set of !> [[unittest_type]] objects. To create a new test use the [[new_unittest]] !> constructor, which requires a test identifier and a procedure with a !> [[test_interface]] compatible signature. The error status is communicated !> by the allocation status of an [[error_type]]. !> !> The necessary boilerplate code to setup the test entry point is just !> !>```fortran !>program tester !>   use, intrinsic :: iso_fortran_env, only : error_unit !>   use mctc_env_testing, only : run_testsuite, new_testsuite, testsuite_type !>   use test_suite1, only : collect_suite1 !>   use test_suite2, only : collect_suite2 !>   implicit none !>   integer :: stat, ii !>   type(testsuite_type), allocatable :: testsuites(:) !>   character(len=*), parameter :: fmt = '(\"#\", *(1x, a))' !> !>   stat = 0 !> !>   testsuites = [ & !>      & new_testsuite(\"suite1\", collect_suite1), & !>      & new_testsuite(\"suite2\", collect_suite2) & !>      & ] !> !>   do ii = 1, size(testsuites) !>      write(error_unit, fmt) \"Testing:\", testsuites(ii)%name !>      call run_testsuite(testsuites(ii)%collect, error_unit, stat) !>   end do !> !>   if (stat > 0) then !>      write(error_unit, '(i0, 1x, a)') stat, \"test(s) failed!\" !>      error stop !>   end if !> !>end program tester !>``` !> !> Every test is defined in a separate module using a ``collect`` function, which !> is exported and added to the ``testsuites`` array in the test runner. !> All test have a simple interface with just an allocatable [[error_type]] as !> output to provide the test results. !> !>```fortran !>module test_suite1 !>   use mctc_env_testing, only : new_unittest, unittest_type, error_type, check !>   implicit none !>   private !> !>   public :: collect_suite1 !> !>contains !> !>!> Collect all exported unit tests !>subroutine collect_suite1(testsuite) !>   !> Collection of tests !>   type(unittest_type), allocatable, intent(out) :: testsuite(:) !> !>   testsuite = [ & !>      & new_unittest(\"valid\", test_valid), & !>      & new_unittest(\"invalid\", test_invalid, should_fail=.true.) & !>      & ] !> !>end subroutine collect_suite1 !> !>subroutine test_valid(error) !>   type(error_type), allocatable, intent(out) :: error !>   ! ... !>end subroutine test_valid !> !>subroutine test_invalid(error) !>   type(error_type), allocatable, intent(out) :: error !>   ! ... !>end subroutine test_invalid !> !>end module test_suite1 !>``` !> !> For an example setup checkout the ``test/`` directory in this project. module mctc_env_testing use mctc_env_error , only : error_type , mctc_stat use mctc_env_accuracy , only : sp , dp , i1 , i2 , i4 , i8 implicit none private public :: run_testsuite , run_selected , new_unittest , new_testsuite public :: select_test , select_suite public :: unittest_type , testsuite_type , error_type public :: check , test_failed public :: test_interface , collect_interface interface check module procedure :: check_stat module procedure :: check_logical module procedure :: check_float_sp module procedure :: check_float_dp module procedure :: check_int_i1 module procedure :: check_int_i2 module procedure :: check_int_i4 module procedure :: check_int_i8 module procedure :: check_bool module procedure :: check_string end interface check abstract interface !> Entry point for tests subroutine test_interface ( error ) import :: error_type !> Error handling type ( error_type ), allocatable , intent ( out ) :: error end subroutine test_interface end interface !> Declaration of a unit test type :: unittest_type !> Name of the test character ( len = :), allocatable :: name !> Entry point of the test procedure ( test_interface ), pointer , nopass :: test => null () !> Whether test is supposed to fail logical :: should_fail = . false . end type unittest_type abstract interface !> Collect all tests subroutine collect_interface ( testsuite ) import :: unittest_type !> Collection of tests type ( unittest_type ), allocatable , intent ( out ) :: testsuite (:) end subroutine collect_interface end interface !> Collection of unit tests type :: testsuite_type !> Name of the testsuite character ( len = :), allocatable :: name !> Entry point of the test procedure ( collect_interface ), pointer , nopass :: collect => null () end type testsuite_type character ( len =* ), parameter :: fmt = '(1x, *(1x, a))' character ( len =* ), parameter :: indent = repeat ( \" \" , 5 ) // repeat ( \".\" , 3 ) contains !> Driver for testsuite subroutine run_testsuite ( collect , unit , stat , parallel ) !> Collect tests procedure ( collect_interface ) :: collect !> Unit for IO integer , intent ( in ) :: unit !> Number of failed tests integer , intent ( inout ) :: stat !> Run tests in parallel logical , intent ( in ), optional :: parallel type ( unittest_type ), allocatable :: testsuite (:) logical :: parallelize integer :: ii parallelize = . false . if ( present ( parallel )) parallelize = parallel call collect ( testsuite ) !$omp parallel do shared(testsuite, unit) reduction(+:stat) if(parallelize) do ii = 1 , size ( testsuite ) !$omp critical(mctc_env_testsuite) write ( unit , '(1x, 3(1x, a), 1x, \"(\", i0, \"/\", i0, \")\")' ) & & \"Starting\" , testsuite ( ii )% name , \"...\" , ii , size ( testsuite ) !$omp end critical(mctc_env_testsuite) call run_unittest ( testsuite ( ii ), unit , stat ) end do end subroutine run_testsuite !> Driver for selective testing subroutine run_selected ( collect , name , unit , stat ) !> Collect tests procedure ( collect_interface ) :: collect !> Name of the selected test character ( len =* ), intent ( in ) :: name !> Unit for IO integer , intent ( in ) :: unit !> Number of failed tests integer , intent ( inout ) :: stat type ( unittest_type ), allocatable :: testsuite (:) integer :: ii call collect ( testsuite ) ii = select_test ( testsuite , name ) if ( ii > 0 . and . ii <= size ( testsuite )) then call run_unittest ( testsuite ( ii ), unit , stat ) else write ( unit , fmt ) \"Available tests:\" do ii = 1 , size ( testsuite ) write ( unit , fmt ) \"-\" , testsuite ( ii )% name end do stat = - huge ( ii ) end if end subroutine run_selected !> Run a selected unit test subroutine run_unittest ( test , unit , stat ) !> Unit test type ( unittest_type ), intent ( in ) :: test !> Unit for IO integer , intent ( in ) :: unit !> Number of failed tests integer , intent ( inout ) :: stat type ( error_type ), allocatable :: error call test % test ( error ) !$omp critical(mctc_env_testsuite) if ( allocated ( error ) . neqv . test % should_fail ) then if ( test % should_fail ) then write ( unit , fmt ) indent , test % name , \"[UNEXPECTED PASS]\" else write ( unit , fmt ) indent , test % name , \"[FAILED]\" end if stat = stat + 1 else if ( test % should_fail ) then write ( unit , fmt ) indent , test % name , \"[EXPECTED FAIL]\" else write ( unit , fmt ) indent , test % name , \"[PASSED]\" end if end if if ( allocated ( error )) then write ( unit , fmt ) \"Message:\" , error % message end if !$omp end critical(mctc_env_testsuite) end subroutine run_unittest !> Select a unit test from all available tests function select_test ( tests , name ) result ( pos ) !> Name identifying the test suite character ( len =* ), intent ( in ) :: name !> Available unit tests type ( unittest_type ) :: tests (:) !> Selected test suite integer :: pos integer :: it pos = 0 do it = 1 , size ( tests ) if ( name == tests ( it )% name ) then pos = it exit end if end do end function select_test !> Select a test suite from all available suites function select_suite ( suites , name ) result ( pos ) !> Name identifying the test suite character ( len =* ), intent ( in ) :: name !> Available test suites type ( testsuite_type ) :: suites (:) !> Selected test suite integer :: pos integer :: it pos = 0 do it = 1 , size ( suites ) if ( name == suites ( it )% name ) then pos = it exit end if end do end function select_suite !> Register a new unit test function new_unittest ( name , test , should_fail ) result ( self ) !> Name of the test character ( len =* ), intent ( in ) :: name !> Entry point for the test procedure ( test_interface ) :: test !> Whether test is supposed to error or not logical , intent ( in ), optional :: should_fail !> Newly registered test type ( unittest_type ) :: self self % name = name self % test => test if ( present ( should_fail )) self % should_fail = should_fail end function new_unittest !> Register a new testsuite function new_testsuite ( name , collect ) result ( self ) !> Name of the testsuite character ( len =* ), intent ( in ) :: name !> Entry point to collect tests procedure ( collect_interface ) :: collect !> Newly registered testsuite type ( testsuite_type ) :: self self % name = name self % collect => collect end function new_testsuite subroutine check_stat ( error , stat , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Status of operation integer , intent ( in ) :: stat !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if ( stat /= mctc_stat % success ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Non-zero exit code encountered\" , more ) end if end if end subroutine check_stat subroutine check_logical ( error , expression , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Result of logical operator logical , intent ( in ) :: expression !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if (. not . expression ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Condition not fullfilled\" , more ) end if end if end subroutine check_logical subroutine check_float_dp ( error , actual , expected , message , more , thr , rel ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found floating point value real ( dp ), intent ( in ) :: actual !> Expected floating point value real ( dp ), intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more !> Allowed threshold for matching floating point values real ( dp ), intent ( in ), optional :: thr !> Check for relative errors instead logical , intent ( in ), optional :: rel logical :: relative real ( dp ) :: diff , threshold if ( present ( thr )) then threshold = thr else threshold = epsilon ( expected ) end if if ( present ( rel )) then relative = rel else relative = . false . end if if ( relative ) then diff = abs ( actual - expected ) / expected else diff = abs ( actual - expected ) end if if ( diff > threshold ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Floating point value missmatch\" , more ) end if end if end subroutine check_float_dp subroutine check_float_sp ( error , actual , expected , message , more , thr , rel ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found floating point value real ( sp ), intent ( in ) :: actual !> Expected floating point value real ( sp ), intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more !> Allowed threshold for matching floating point values real ( sp ), intent ( in ), optional :: thr !> Check for relative errors instead logical , intent ( in ), optional :: rel logical :: relative real ( sp ) :: diff , threshold if ( present ( thr )) then threshold = thr else threshold = epsilon ( expected ) end if if ( present ( rel )) then relative = rel else relative = . false . end if if ( relative ) then diff = abs ( actual - expected ) / expected else diff = abs ( actual - expected ) end if if ( diff > threshold ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Floating point value missmatch\" , more ) end if end if end subroutine check_float_sp subroutine check_int_i1 ( error , actual , expected , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found integer value integer ( i1 ), intent ( in ) :: actual !> Expected integer value integer ( i1 ), intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if ( expected /= actual ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Integer value missmatch\" , more ) end if end if end subroutine check_int_i1 subroutine check_int_i2 ( error , actual , expected , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found integer value integer ( i2 ), intent ( in ) :: actual !> Expected integer value integer ( i2 ), intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if ( expected /= actual ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Integer value missmatch\" , more ) end if end if end subroutine check_int_i2 subroutine check_int_i4 ( error , actual , expected , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found integer value integer ( i4 ), intent ( in ) :: actual !> Expected integer value integer ( i4 ), intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if ( expected /= actual ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Integer value missmatch\" , more ) end if end if end subroutine check_int_i4 subroutine check_int_i8 ( error , actual , expected , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found integer value integer ( i8 ), intent ( in ) :: actual !> Expected integer value integer ( i8 ), intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if ( expected /= actual ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Integer value missmatch\" , more ) end if end if end subroutine check_int_i8 subroutine check_bool ( error , actual , expected , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found boolean value logical , intent ( in ) :: actual !> Expected boolean value logical , intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if ( expected . neqv . actual ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Logical value missmatch\" , more ) end if end if end subroutine check_bool subroutine check_string ( error , actual , expected , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found boolean value character ( len =* ), intent ( in ) :: actual !> Expected boolean value character ( len =* ), intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if ( expected /= actual ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Character value missmatch\" , more ) end if end if end subroutine check_string subroutine test_failed ( error , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> A detailed message describing the error character ( len =* ), intent ( in ) :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more allocate ( error ) error % stat = mctc_stat % fatal if ( present ( more )) then error % message = message // new_line ( 'a' ) // more else error % message = message end if end subroutine test_failed end module mctc_env_testing","tags":"","loc":"sourcefile/testing.f90.html"},{"title":"info.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_structure_info use mctc_env_accuracy , only : wp implicit none private public :: pdb_data , sdf_data , structure_info public :: resize !> Atomic pdb data type. !> !> keeps information from PDB input that is currently not used by the !> caller program (like residues or chains) but is needed to write !> the PDB output eventually !> !>     ATOM   2461  HA3 GLY A 153     -10.977  -7.661   2.011  1.00  0.00           H !>     TER    2462      GLY A 153 !>     a6----i5---xa4--aa3-xai4--axxxf8.3----f8.3----f8.3----f6.2--f6.2--xxxxxxa4--a2a2 !>     HETATM 2463  CHA HEM A 154       9.596 -13.100  10.368  1.00  0.00           C type :: pdb_data logical :: het = . false . integer :: charge = 0 integer :: residue_number = 0 character ( len = 4 ) :: name = ' ' character ( len = 1 ) :: loc = ' ' character ( len = 3 ) :: residue = ' ' character ( len = 1 ) :: chains = ' ' character ( len = 1 ) :: code = ' ' character ( len = 4 ) :: segid = ' ' end type pdb_data !> SDF atomic data. !> !> We only support some entries, the rest is simply dropped. !> the format is: ddcccssshhhbbbvvvHHHrrriiimmmnnneee type :: sdf_data integer :: isotope = 0 !< d field integer :: charge = 0 !< c field integer :: hydrogens = 0 !< h field integer :: valence = 0 !< v field end type sdf_data !> structure input info !> !> contains informations from different input file formats type :: structure_info !> Vasp coordinate scaling information real ( wp ) :: scale = 1.0_wp !> Vasp selective dynamics keyword is present logical :: selective = . false . !> SDF 2D structure present logical :: two_dimensional = . false . !> SDF hydrogen query present or PDB without hydrogen atoms found logical :: missing_hydrogen = . false . !> Periodic coordinates should use preferably cartesian coordinates logical :: cartesian = . true . !> Lattice information should use preferably lattice vectors logical :: lattice = . true . !> Unit of the lattice vectors should be in Angstrom if possible logical :: angs_lattice = . false . !> Unit of the atomic coordinates should be in Angstrom if possible logical :: angs_coord = . false . end type structure_info interface resize module procedure resize_pdb_data end interface contains subroutine resize_pdb_data ( var , n ) type ( pdb_data ), allocatable , intent ( inout ) :: var (:) integer , intent ( in ), optional :: n type ( pdb_data ), allocatable :: tmp (:) integer :: length , current_length current_length = size ( var ) if ( current_length > 0 ) then if ( present ( n )) then if ( n <= current_length ) return length = n else length = current_length + current_length / 2 + 1 endif allocate ( tmp ( length ), source = pdb_data ()) tmp (: current_length ) = var (: current_length ) deallocate ( var ) call move_alloc ( tmp , var ) else if ( present ( n )) then length = n else length = 64 endif allocate ( var ( length ), source = pdb_data ()) endif end subroutine resize_pdb_data end module mctc_io_structure_info","tags":"","loc":"sourcefile/info.f90.html"},{"title":"gaussian.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_gaussian use mctc_env_accuracy , only : wp use mctc_io_structure , only : structure_type implicit none private public :: write_gaussian_external contains subroutine write_gaussian_external ( mol , unit ) type ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer :: iat write ( unit , '(4i10)' ) mol % nat , 1 , nint ( mol % charge ), mol % uhf do iat = 1 , mol % nat write ( unit , '(i10,4f20.12)' ) mol % num ( mol % id ( iat )), mol % xyz (:, iat ), 0.0_wp end do end subroutine write_gaussian_external end module mctc_io_write_gaussian","tags":"","loc":"sourcefile/gaussian.f90.html"},{"title":"utils.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_utils use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error implicit none private public :: getline , next_line public :: token_type , next_token , read_token , read_next_token public :: io_error , io2_error public :: filename , to_string !> Text token type :: token_type !> Begin of sequence integer :: first !> End of sequence integer :: last end type token_type interface read_token module procedure :: read_token_int module procedure :: read_token_real end interface read_token interface read_next_token module procedure :: read_next_token_int module procedure :: read_next_token_real end interface read_next_token contains subroutine getline ( unit , line , iostat , iomsg ) !> Formatted IO unit integer , intent ( in ) :: unit !> Line to read character ( len = :), allocatable , intent ( out ) :: line !> Status of operation integer , intent ( out ) :: iostat !> Error message character ( len = :), allocatable , optional :: iomsg integer , parameter :: bufsize = 512 character ( len = bufsize ) :: buffer character ( len = bufsize ) :: msg integer :: size integer :: stat allocate ( character ( len = 0 ) :: line ) do read ( unit , '(a)' , advance = 'no' , iostat = stat , iomsg = msg , size = size ) & & buffer if ( stat > 0 ) exit line = line // buffer (: size ) if ( stat < 0 ) then if ( is_iostat_eor ( stat )) then stat = 0 end if exit end if end do if ( stat /= 0 ) then if ( present ( iomsg )) iomsg = trim ( msg ) end if iostat = stat end subroutine getline !> Convenience function to read a line and update associated descriptors subroutine next_line ( unit , line , pos , lnum , iostat , iomsg ) !> Formatted IO unit integer , intent ( in ) :: unit !> Line to read character ( len = :), allocatable , intent ( out ) :: line !> Current position in line integer , intent ( out ) :: pos !> Current line number integer , intent ( inout ) :: lnum !> Status of operation integer , intent ( out ) :: iostat !> Error message character ( len = :), allocatable , optional :: iomsg pos = 0 call getline ( unit , line , iostat , iomsg ) if ( iostat == 0 ) lnum = lnum + 1 end subroutine next_line !> Advance pointer to next text token subroutine next_token ( string , pos , token ) !> String to check character ( len =* ), intent ( in ) :: string !> Current position in string integer , intent ( inout ) :: pos !> Token found type ( token_type ), intent ( out ) :: token integer :: start if ( pos >= len ( string )) then token = token_type ( len ( string ) + 1 , len ( string ) + 1 ) return end if do while ( pos < len ( string )) pos = pos + 1 select case ( string ( pos : pos )) case ( \" \" , achar ( 9 ), achar ( 10 ), achar ( 13 )) continue case default exit end select end do start = pos do while ( pos < len ( string )) pos = pos + 1 select case ( string ( pos : pos )) case ( \" \" , achar ( 9 ), achar ( 10 ), achar ( 13 )) pos = pos - 1 exit case default continue end select end do token = token_type ( start , pos ) end subroutine next_token function filename ( unit ) integer , intent ( in ) :: unit character ( len = :), allocatable :: filename character ( len = 512 ) :: buffer logical :: opened filename = \"(input)\" if ( unit /= - 1 ) then buffer = \"\" inquire ( unit = unit , opened = opened , name = buffer ) if ( opened . and . len_trim ( buffer ) > 0 ) then filename = trim ( buffer ) end if end if end function !> Create new IO error subroutine io_error ( error , message , source , token , filename , line , label ) !> Error handler type ( error_type ), allocatable , intent ( out ) :: error !> Main error message character ( len =* ), intent ( in ) :: message !> String representing the offending input character ( len =* ), intent ( in ) :: source !> Last processed token type ( token_type ), intent ( in ) :: token !> Name of the input file character ( len =* ), intent ( in ), optional :: filename !> Line number integer , intent ( in ), optional :: line !> Label of the offending statement character ( len =* ), intent ( in ), optional :: label character ( len =* ), parameter :: nl = new_line ( 'a' ) integer :: offset , lnum , width character ( len = :), allocatable :: string lnum = 1 if ( present ( line )) lnum = line offset = integer_width ( lnum ) width = token % last - token % first + 1 string = \"Error: \" // message if ( present ( filename )) then string = string // nl // & repeat ( \" \" , offset ) // \"--> \" // filename string = string // \":\" // to_string ( lnum ) if ( token % first > 0 . and . token % last >= token % first ) then string = string // & \":\" // to_string ( token % first ) if ( token % last > token % first ) string = string // \"-\" // to_string ( token % last ) end if end if string = string // nl // & repeat ( \" \" , offset + 1 ) // \"|\" // nl // & to_string ( lnum ) // \" | \" // source // nl // & repeat ( \" \" , offset + 1 ) // \"|\" // repeat ( \" \" , token % first ) // repeat ( \"&#94;\" , width ) if ( present ( label )) then string = string // \" \" // label end if string = string // nl // & repeat ( \" \" , offset + 1 ) // \"|\" call fatal_error ( error , string ) end subroutine io_error !> Create new IO error subroutine io2_error ( error , message , source1 , source2 , token1 , token2 , filename , & & line1 , line2 , label1 , label2 ) !> Error handler type ( error_type ), allocatable , intent ( out ) :: error !> Main error message character ( len =* ), intent ( in ) :: message !> String representing the offending input character ( len =* ), intent ( in ) :: source1 , source2 !> Last processed token type ( token_type ), intent ( in ) :: token1 , token2 !> Name of the input file character ( len =* ), intent ( in ), optional :: filename !> Line number integer , intent ( in ), optional :: line1 , line2 !> Label of the offending statement character ( len =* ), intent ( in ), optional :: label1 , label2 character ( len =* ), parameter :: nl = new_line ( 'a' ) integer :: offset , lnum1 , lnum2 , width1 , width2 character ( len = :), allocatable :: string lnum1 = 1 lnum2 = 1 if ( present ( line1 )) lnum1 = line1 if ( present ( line2 )) lnum2 = line2 offset = integer_width ( max ( lnum1 , lnum2 )) width1 = token1 % last - token1 % first + 1 width2 = token2 % last - token2 % first + 1 string = \"Error: \" // message if ( present ( filename )) then string = string // nl // & repeat ( \" \" , offset ) // \"--> \" // filename string = string // \":\" // to_string ( lnum2 ) if ( token2 % first > 0 . and . token2 % last >= token2 % first ) then string = string // & \":\" // to_string ( token2 % first ) if ( token2 % last > token2 % first ) string = string // \"-\" // to_string ( token2 % last ) end if end if string = string // nl // & repeat ( \" \" , offset + 1 ) // \"|\" // nl // & to_string ( lnum1 , offset ) // \" | \" // source1 // nl // & repeat ( \" \" , offset + 1 ) // \"|\" // repeat ( \" \" , token1 % first ) // repeat ( \"-\" , width1 ) if ( present ( label1 )) then string = string // \" \" // label1 end if string = string // nl // & repeat ( \" \" , offset + 1 ) // \":\" // nl // & to_string ( lnum2 ) // \" | \" // source2 // nl // & repeat ( \" \" , offset + 1 ) // \"|\" // repeat ( \" \" , token2 % first ) // repeat ( \"&#94;\" , width2 ) if ( present ( label2 )) then string = string // \" \" // label2 end if string = string // nl // & repeat ( \" \" , offset + 1 ) // \"|\" call fatal_error ( error , string ) end subroutine io2_error pure function integer_width ( input ) result ( width ) integer , intent ( in ) :: input integer :: width integer :: val val = input width = 0 do while ( val /= 0 ) val = val / 10 width = width + 1 end do end function integer_width !> Represent an integer as character sequence. pure function to_string ( val , width ) result ( string ) integer , intent ( in ) :: val integer , intent ( in ), optional :: width character ( len = :), allocatable :: string integer , parameter :: buffer_len = range ( val ) + 2 character ( len = buffer_len ) :: buffer integer :: pos integer :: n character ( len = 1 ), parameter :: numbers ( 0 : 9 ) = & [ \"0\" , \"1\" , \"2\" , \"3\" , \"4\" , \"5\" , \"6\" , \"7\" , \"8\" , \"9\" ] if ( val == 0 ) then if ( present ( width )) then string = repeat ( \" \" , width - 1 ) // numbers ( 0 ) else string = numbers ( 0 ) end if return end if n = abs ( val ) buffer = \"\" pos = buffer_len + 1 do while ( n > 0 ) pos = pos - 1 buffer ( pos : pos ) = numbers ( mod ( n , 10 )) n = n / 10 end do if ( val < 0 ) then pos = pos - 1 buffer ( pos : pos ) = '-' end if if ( present ( width )) then string = repeat ( \" \" , max ( width - ( buffer_len + 1 - pos ), 0 )) // buffer ( pos :) else string = buffer ( pos :) end if end function to_string subroutine read_next_token_int ( line , pos , token , val , iostat , iomsg ) character ( len =* ), intent ( in ) :: line integer , intent ( inout ) :: pos type ( token_type ), intent ( inout ) :: token integer , intent ( out ) :: val integer , intent ( out ) :: iostat character ( len = :), allocatable , intent ( out ), optional :: iomsg character ( len = 512 ) :: msg call next_token ( line , pos , token ) call read_token ( line , token , val , iostat , iomsg ) end subroutine read_next_token_int subroutine read_token_int ( line , token , val , iostat , iomsg ) character ( len =* ), intent ( in ) :: line type ( token_type ), intent ( in ) :: token integer , intent ( out ) :: val integer , intent ( out ) :: iostat character ( len = :), allocatable , intent ( out ), optional :: iomsg character ( len = 512 ) :: msg if ( token % first > 0 . and . token % last <= len ( line )) then read ( line ( token % first : token % last ), * , iostat = iostat , iomsg = msg ) val else iostat = 1 msg = \"No input found\" end if if ( present ( iomsg )) iomsg = trim ( msg ) end subroutine read_token_int subroutine read_next_token_real ( line , pos , token , val , iostat , iomsg ) character ( len =* ), intent ( in ) :: line integer , intent ( inout ) :: pos type ( token_type ), intent ( inout ) :: token real ( wp ), intent ( out ) :: val integer , intent ( out ) :: iostat character ( len = :), allocatable , intent ( out ), optional :: iomsg call next_token ( line , pos , token ) call read_token ( line , token , val , iostat , iomsg ) end subroutine read_next_token_real subroutine read_token_real ( line , token , val , iostat , iomsg ) character ( len =* ), intent ( in ) :: line type ( token_type ), intent ( in ) :: token real ( wp ), intent ( out ) :: val integer , intent ( out ) :: iostat character ( len = :), allocatable , intent ( out ), optional :: iomsg character ( len = 512 ) :: msg if ( token % first > 0 . and . token % last <= len ( line )) then read ( line ( token % first : token % last ), * , iostat = iostat , iomsg = msg ) val else iostat = 1 msg = \"No input found\" end if if ( present ( iomsg )) iomsg = trim ( msg ) end subroutine read_token_real end module mctc_io_utils","tags":"","loc":"sourcefile/utils.f90.html"},{"title":"write.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write use mctc_env_error , only : error_type , fatal_error use mctc_io_filetype , only : filetype , get_filetype use mctc_io_write_aims , only : write_aims use mctc_io_write_cjson , only : write_cjson use mctc_io_write_ctfile , only : write_molfile , write_sdf use mctc_io_write_gaussian , only : write_gaussian_external use mctc_io_write_genformat , only : write_genformat use mctc_io_write_pdb , only : write_pdb use mctc_io_write_qchem , only : write_qchem use mctc_io_write_qcschema , only : write_qcschema use mctc_io_write_turbomole , only : write_coord use mctc_io_write_vasp , only : write_vasp use mctc_io_write_xyz , only : write_xyz use mctc_io_structure , only : structure_type , new_structure implicit none private public :: write_structure interface write_structure module procedure :: write_structure_to_file module procedure :: write_structure_to_unit end interface write_structure contains subroutine write_structure_to_file ( self , file , error , format ) !> Instance of the molecular structure data class ( structure_type ), intent ( in ) :: self !> Name of the file to read character ( len =* ), intent ( in ) :: file !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> File type format hint integer , intent ( in ), optional :: format integer :: unit , ftype , stat open ( file = file , newunit = unit , iostat = stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Cannot open '\" // file // \"'\" ) return end if if ( present ( format )) then ftype = format else ftype = get_filetype ( file ) end if ! Unknown file type is unacceptable in this situation, ! try to figure at least something out if ( ftype == filetype % unknown ) then if ( any ( self % periodic )) then ftype = filetype % vasp else if ( allocated ( self % sdf )) then ftype = filetype % sdf else if ( allocated ( self % pdb )) then ftype = filetype % pdb else ftype = filetype % xyz end if end if call write_structure ( self , unit , ftype , error ) close ( unit ) end subroutine write_structure_to_file subroutine write_structure_to_unit ( self , unit , ftype , error ) !> Instance of the molecular structure data class ( structure_type ), intent ( in ) :: self !> File handle integer , intent ( in ) :: unit !> File type to read integer , intent ( in ) :: ftype !> Error handling type ( error_type ), allocatable , intent ( out ) :: error select case ( ftype ) case default call fatal_error ( error , \"Cannot write unknown file format\" ) case ( filetype % xyz ) call write_xyz ( self , unit ) case ( filetype % molfile ) call write_molfile ( self , unit ) case ( filetype % pdb ) call write_pdb ( self , unit ) case ( filetype % gen ) call write_genformat ( self , unit ) case ( filetype % sdf ) call write_sdf ( self , unit ) case ( filetype % vasp ) call write_vasp ( self , unit ) case ( filetype % tmol ) call write_coord ( self , unit ) case ( filetype % gaussian ) call write_gaussian_external ( self , unit ) case ( filetype % cjson ) call write_cjson ( self , unit ) case ( filetype % qcschema ) call write_qcschema ( self , unit ) case ( filetype % aims ) call write_aims ( self , unit ) case ( filetype % qchem ) call write_qchem ( self , unit ) end select end subroutine write_structure_to_unit end module mctc_io_write","tags":"","loc":"sourcefile/write.f90.html"},{"title":"qcschema.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_qcschema use mctc_env_accuracy , only : wp use mctc_io_structure , only : structure_type use mctc_version , only : get_mctc_version implicit none private public :: write_qcschema interface json_value module procedure :: json_value_char module procedure :: json_value_int module procedure :: json_value_real end interface json_value interface json_array module procedure :: json_array_char_1 module procedure :: json_array_int_1 module procedure :: json_array_real_1 end interface json_array character ( len =* ), parameter :: nl = new_line ( 'a' ) contains subroutine write_qcschema ( mol , unit ) type ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit write ( unit , '(a)' ) json_string ( mol , \"  \" ) end subroutine write_qcschema pure function json_string ( mol , indent ) result ( string ) type ( structure_type ), intent ( in ) :: mol character ( len =* ), intent ( in ), optional :: indent character ( len = :), allocatable :: string string = \"{\" if ( present ( indent )) string = string // nl // indent string = string // json_key ( \"schema_version\" , indent ) // json_value ( 2 ) string = string // \",\" if ( present ( indent )) string = string // nl // indent string = string // json_key ( \"schema_name\" , indent ) // json_value ( \"qcschema_molecule\" ) string = string // \",\" block character ( len = :), allocatable :: version call get_mctc_version ( string = version ) if ( present ( indent )) string = string // nl // indent string = string // json_key ( \"provenance\" , indent ) // \"{\" if ( present ( indent )) string = string // nl // indent // indent string = string // json_key ( \"creator\" , indent ) // json_value ( \"mctc-lib\" ) string = string // \",\" if ( present ( indent )) string = string // nl // indent // indent string = string // json_key ( \"version\" , indent ) // json_value ( version ) string = string // \",\" if ( present ( indent )) string = string // nl // indent // indent string = string // json_key ( \"routine\" , indent ) // & & json_value ( \"mctc_io_write_qcschema::write_qcschema\" ) if ( present ( indent )) string = string // nl // indent string = string // \"}\" end block if ( allocated ( mol % comment )) then string = string // \",\" if ( present ( indent )) string = string // nl // indent string = string // json_key ( \"comment\" , indent ) // json_value ( mol % comment ) end if string = string // \",\" if ( present ( indent )) string = string // nl // indent string = string // json_key ( \"symbols\" , indent ) // json_array ( mol % sym ( mol % id ), indent ) string = string // \",\" if ( present ( indent )) string = string // nl // indent string = string // json_key ( \"atomic_numbers\" , indent ) // & & json_array ( mol % num ( mol % id ), indent ) string = string // \",\" if ( present ( indent )) string = string // nl // indent string = string // json_key ( \"geometry\" , indent ) // json_array ([ mol % xyz ], indent ) string = string // \",\" if ( present ( indent )) string = string // nl // indent string = string // json_key ( \"molecular_charge\" , indent ) // json_value ( nint ( mol % charge )) if ( mol % uhf > 0 ) then string = string // \",\" if ( present ( indent )) string = string // nl // indent string = string // json_key ( \"molecular_multiplicity\" , indent ) // json_value ( mol % uhf + 1 ) end if if ( allocated ( mol % bond )) then string = string // \",\" if ( present ( indent )) string = string // nl // indent string = string // json_key ( \"connectivity\" , indent ) // \"[\" block integer :: i do i = 1 , mol % nbd if ( present ( indent )) string = string // nl // indent // indent string = string // \"[\" // json_value ( mol % bond ( 1 , i ) - 1 ) // \",\" // & & json_value ( mol % bond ( 2 , i ) - 1 ) // \",\" if ( size ( mol % bond , 1 ) > 2 ) then string = string // json_value ( mol % bond ( 3 , i )) // \"]\" else string = string // json_value ( 1 ) // \"]\" end if if ( i /= mol % nbd ) string = string // \",\" end do end block if ( present ( indent )) string = string // nl // indent string = string // \"]\" end if if ( present ( indent )) string = string // nl string = string // \"}\" end function json_string pure function json_array_int_1 ( array , indent ) result ( string ) integer , intent ( in ) :: array (:) character ( len =* ), intent ( in ), optional :: indent character ( len = :), allocatable :: string integer :: i , j string = \"[\" do i = 1 , size ( array ) if ( present ( indent )) string = string // nl // indent // indent string = string // json_value ( array ( i )) if ( i /= size ( array )) string = string // \",\" end do if ( present ( indent )) string = string // nl // indent string = string // \"]\" end function json_array_int_1 pure function json_array_real_1 ( array , indent ) result ( string ) real ( wp ), intent ( in ) :: array (:) character ( len =* ), intent ( in ), optional :: indent character ( len = :), allocatable :: string integer :: i , j string = \"[\" do i = 1 , size ( array ) if ( present ( indent )) string = string // nl // indent // indent string = string // json_value ( array ( i ), '(es23.16)' ) if ( i /= size ( array )) string = string // \",\" end do if ( present ( indent )) string = string // nl // indent string = string // \"]\" end function json_array_real_1 pure function json_array_char_1 ( array , indent ) result ( string ) character ( len =* ), intent ( in ) :: array (:) character ( len =* ), intent ( in ), optional :: indent character ( len = :), allocatable :: string integer :: i , j string = \"[\" do i = 1 , size ( array ) if ( present ( indent )) string = string // nl // indent // indent string = string // json_value ( trim ( array ( i ))) if ( i /= size ( array )) string = string // \",\" end do if ( present ( indent )) string = string // nl // indent string = string // \"]\" end function json_array_char_1 pure function json_key ( key , indent ) result ( string ) character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ), optional :: indent character ( len = :), allocatable :: string if ( present ( indent )) then string = json_value ( key ) // \": \" else string = json_value ( key ) // \":\" end if end function json_key pure function json_value_char ( val ) result ( string ) character ( len =* ), intent ( in ) :: val character ( len = :), allocatable :: string string = \"\"\"\" // val // \"\"\"\" end function json_value_char pure function json_value_real ( val , format ) result ( str ) real ( wp ), intent ( in ) :: val character ( len =* ), intent ( in ) :: format character ( len = :), allocatable :: str character ( len = 128 ) :: buffer integer :: stat write ( buffer , format , iostat = stat ) val if ( stat == 0 ) then str = trim ( buffer ) else str = \"\"\"*\"\"\" end if end function json_value_real pure function json_value_int ( val ) result ( string ) integer , intent ( in ) :: val character ( len = :), allocatable :: string integer , parameter :: buffer_len = range ( val ) + 2 character ( len = buffer_len ) :: buffer integer :: pos integer :: n character ( len = 1 ), parameter :: numbers ( 0 : 9 ) = & [ \"0\" , \"1\" , \"2\" , \"3\" , \"4\" , \"5\" , \"6\" , \"7\" , \"8\" , \"9\" ] if ( val == 0 ) then string = numbers ( 0 ) return end if n = abs ( val ) buffer = \"\" pos = buffer_len + 1 do while ( n > 0 ) pos = pos - 1 buffer ( pos : pos ) = numbers ( mod ( n , 10 )) n = n / 10 end do if ( val < 0 ) then pos = pos - 1 buffer ( pos : pos ) = '-' end if string = buffer ( pos :) end function json_value_int end module mctc_io_write_qcschema","tags":"","loc":"sourcefile/qcschema.f90.html"},{"title":"qchem.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_qchem use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type use mctc_io_convert , only : aatoau use mctc_io_resize , only : resize use mctc_io_symbols , only : symbol_length , to_number , to_symbol use mctc_io_structure , only : structure_type , new use mctc_io_utils , only : next_line , token_type , next_token , io_error , filename , & read_next_token , read_token implicit none private public :: read_qchem integer , parameter :: initial_size = 64 contains subroutine read_qchem ( mol , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: mol !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: stat , pos , lnum , izp , iat integer :: charge , multiplicity type ( token_type ) :: token character ( len = :), allocatable :: line real ( wp ) :: x , y , z character ( len = symbol_length ), allocatable :: sym (:) real ( wp ), allocatable :: xyz (:, :), abc (:, :), lattice (:, :) logical :: is_frac , periodic ( 3 ) iat = 0 lnum = 0 stat = 0 do while ( stat == 0 ) call next_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) exit call next_token ( line , pos , token ) if ( token % first > len ( line )) cycle if ( to_lower ( line ( token % first : token % last )) == '$molecule' ) exit end do if ( stat /= 0 ) then call io_error ( error , \"No atoms found\" , & & line , token_type ( 0 , 0 ), filename ( unit ), lnum + 1 , \"expected molecule block\" ) return end if call next_line ( unit , line , pos , lnum , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , charge , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , multiplicity , stat ) if ( stat /= 0 ) then call io_error ( error , \"Failed to read charge and multiplicity\" , & & line , token , filename ( unit ), lnum , \"expected integer value\" ) return end if allocate ( sym ( initial_size ), source = repeat ( ' ' , symbol_length )) allocate ( xyz ( 3 , initial_size ), source = 0.0_wp ) do while ( stat == 0 ) call next_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) exit call next_token ( line , pos , token ) if ( to_lower ( line ( token % first : token % last )) == '$end' ) exit if ( iat >= size ( sym )) call resize ( sym ) if ( iat >= size ( xyz , 2 )) call resize ( xyz ) iat = iat + 1 token % last = min ( token % last , token % first + symbol_length - 1 ) sym ( iat ) = line ( token % first : token % last ) if ( to_number ( sym ( iat )) == 0 ) then call read_token ( line , token , izp , stat ) sym ( iat ) = to_symbol ( izp ) end if if ( stat /= 0 ) then call io_error ( error , \"Cannot map symbol to atomic number\" , & & line , token , filename ( unit ), lnum , \"unknown element\" ) return end if call read_next_token ( line , pos , token , x , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , y , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , z , stat ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read coordinates\" , & & line , token , filename ( unit ), lnum , \"expected real value\" ) return end if xyz (:, iat ) = [ x , y , z ] * aatoau end do if ( stat /= 0 ) then call io_error ( error , \"Failed to read molecule block\" , & & line , token_type ( 0 , 0 ), filename ( unit ), lnum , \"unexpected end of input\" ) return end if call new ( mol , sym (: iat ), xyz , charge = real ( charge , wp ), uhf = multiplicity - 1 ) end subroutine read_qchem !> Convert input string to lowercase elemental function to_lower ( str ) result ( lcstr ) !> Input string character ( len =* ), intent ( in ) :: str !> Lowercase version of string character ( len = len ( str )) :: lcstr integer :: ilen , iquote , i , iav , iqc integer , parameter :: offset = iachar ( 'A' ) - iachar ( 'a' ) ilen = len ( str ) iquote = 0 lcstr = str do i = 1 , ilen iav = iachar ( str ( i : i )) if ( iquote == 0 . and . ( iav == 34 . or . iav == 39 )) then iquote = 1 iqc = iav cycle end if if ( iquote == 1 . and . iav == iqc ) then iquote = 0 cycle end if if ( iquote == 1 ) cycle if ( iav >= iachar ( 'A' ) . and . iav <= iachar ( 'Z' )) then lcstr ( i : i ) = achar ( iav - offset ) else lcstr ( i : i ) = str ( i : i ) end if end do end function to_lower end module mctc_io_read_qchem","tags":"","loc":"sourcefile/qchem.f90.html"},{"title":"error.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Central registry for error codes module mctc_env_error implicit none private public :: mctc_stat , error_type public :: fatal_error !> Possible error codes type :: enum_stat !> Successful run integer :: success = 0 !> Internal error: integer :: fatal = 1 end type enum_stat !> Actual enumerator for return states type ( enum_stat ), parameter :: mctc_stat = enum_stat () !> Error message type :: error_type !> Error code integer :: stat !> Payload of the error character ( len = :), allocatable :: message end type error_type contains !> A fatal error is encountered subroutine fatal_error ( error , message , stat ) !> Instance of the error type ( error_type ), allocatable , intent ( out ) :: error !> A detailed message describing the error and (optionally) offering advice character ( len =* ), intent ( in ), optional :: message !> Overwrite of the error code integer , intent ( in ), optional :: stat allocate ( error ) if ( present ( stat )) then error % stat = stat else error % stat = mctc_stat % fatal end if if ( present ( message )) then error % message = message else error % message = \"Fatal error\" end if end subroutine fatal_error end module mctc_env_error","tags":"","loc":"sourcefile/error.f90.html"},{"title":"resize.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Reallocation implementation for resizing arrays module mctc_io_resize use mctc_env_accuracy , only : wp implicit none private public :: resize !> Overloaded resize interface interface resize module procedure :: resize_char module procedure :: resize_int module procedure :: resize_logical module procedure :: resize_real module procedure :: resize_real_2d end interface resize !> Initial size for dynamic sized arrays integer , parameter :: initial_size = 64 contains !> Reallocate list of integers pure subroutine resize_int ( var , n ) !> Instance of the array to be resized integer , allocatable , intent ( inout ) :: var (:) !> Dimension of the final array size integer , intent ( in ), optional :: n integer , allocatable :: tmp (:) integer :: this_size , new_size if ( allocated ( var )) then this_size = size ( var , 1 ) call move_alloc ( var , tmp ) else this_size = initial_size end if if ( present ( n )) then new_size = n else new_size = this_size + this_size / 2 + 1 end if allocate ( var ( new_size )) if ( allocated ( tmp )) then this_size = min ( size ( tmp , 1 ), size ( var , 1 )) var (: this_size ) = tmp (: this_size ) deallocate ( tmp ) end if end subroutine resize_int !> Reallocate list of characters pure subroutine resize_char ( var , n ) !> Instance of the array to be resized character ( len =* ), allocatable , intent ( inout ) :: var (:) !> Dimension of the final array size integer , intent ( in ), optional :: n character ( len = :), allocatable :: tmp (:) integer :: this_size , new_size if ( allocated ( var )) then this_size = size ( var , 1 ) call move_alloc ( var , tmp ) else this_size = initial_size end if if ( present ( n )) then new_size = n else new_size = this_size + this_size / 2 + 1 end if allocate ( var ( new_size )) if ( allocated ( tmp )) then this_size = min ( size ( tmp , 1 ), size ( var , 1 )) var (: this_size ) = tmp (: this_size ) deallocate ( tmp ) end if end subroutine resize_char !> Reallocate list of logicals pure subroutine resize_logical ( var , n ) !> Instance of the array to be resized logical , allocatable , intent ( inout ) :: var (:) !> Dimension of the final array size integer , intent ( in ), optional :: n logical , allocatable :: tmp (:) integer :: this_size , new_size if ( allocated ( var )) then this_size = size ( var , 1 ) call move_alloc ( var , tmp ) else this_size = initial_size end if if ( present ( n )) then new_size = n else new_size = this_size + this_size / 2 + 1 end if allocate ( var ( new_size )) if ( allocated ( tmp )) then this_size = min ( size ( tmp , 1 ), size ( var , 1 )) var (: this_size ) = tmp (: this_size ) deallocate ( tmp ) end if end subroutine resize_logical !> Reallocate list of reals pure subroutine resize_real ( var , n ) !> Instance of the array to be resized real ( wp ), allocatable , intent ( inout ) :: var (:) !> Dimension of the final array size integer , intent ( in ), optional :: n real ( wp ), allocatable :: tmp (:) integer :: this_size , new_size if ( allocated ( var )) then this_size = size ( var , 1 ) call move_alloc ( var , tmp ) else this_size = initial_size end if if ( present ( n )) then new_size = n else new_size = this_size + this_size / 2 + 1 end if allocate ( var ( new_size )) if ( allocated ( tmp )) then this_size = min ( size ( tmp , 1 ), size ( var , 1 )) var (: this_size ) = tmp (: this_size ) deallocate ( tmp ) end if end subroutine resize_real !> Reallocate list of reals pure subroutine resize_real_2d ( var , n ) !> Instance of the array to be resized real ( wp ), allocatable , intent ( inout ) :: var (:,:) !> Dimension of the final array size integer , intent ( in ), optional :: n real ( wp ), allocatable :: tmp (:,:) integer :: order , this_size , new_size if ( allocated ( var )) then order = size ( var , 1 ) this_size = size ( var , 2 ) call move_alloc ( var , tmp ) else order = 3 this_size = initial_size end if if ( present ( n )) then new_size = n else new_size = this_size + this_size / 2 + 1 end if allocate ( var ( order , new_size )) if ( allocated ( tmp )) then this_size = min ( size ( tmp , 2 ), size ( var , 2 )) var (:, : this_size ) = tmp (:, : this_size ) deallocate ( tmp ) end if end subroutine resize_real_2d end module mctc_io_resize","tags":"","loc":"sourcefile/resize.f90.html"},{"title":"xyz.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_xyz use mctc_io_convert , only : autoaa use mctc_io_structure , only : structure_type implicit none private public :: write_xyz contains subroutine write_xyz ( self , unit , comment_line ) class ( structure_type ), intent ( in ) :: self integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: comment_line integer :: iat logical :: expo write ( unit , '(i0)' ) self % nat if ( present ( comment_line )) then write ( unit , '(a)' ) comment_line else if ( allocated ( self % comment )) then write ( unit , '(a)' ) self % comment else write ( unit , '(a)' ) end if end if expo = maxval ( self % xyz ) > 1.0e+5 . or . minval ( self % xyz ) < - 1.0e+5 if ( expo ) then do iat = 1 , self % nat write ( unit , '(a4, 1x, 3es24.14)' ) & & self % sym ( self % id ( iat )), self % xyz (:, iat ) * autoaa enddo else do iat = 1 , self % nat write ( unit , '(a4, 1x, 3f24.14)' ) & & self % sym ( self % id ( iat )), self % xyz (:, iat ) * autoaa enddo end if end subroutine write_xyz end module mctc_io_write_xyz","tags":"","loc":"sourcefile/xyz.f90.html"},{"title":"codata2018.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Automatically generated from 2018 CODATA NIST file: !> https://physics.nist.gov/cuu/Constants/Table/allascii.txt !> !> Based on https://github.com/vmagnin/fundamental_constants. module mctc_io_codata2018 use mctc_env , only : wp implicit none public !> alpha particle-electron mass ratio (dimensionless) real ( wp ), parameter :: alpha_particle_electron_mass_ratio = 729 4.29954142_wp !> alpha particle mass (kg) real ( wp ), parameter :: alpha_particle_mass = 6.6446573357e-27_wp !> alpha particle mass energy equivalent (J) real ( wp ), parameter :: alpha_particle_mass_energy_equivalent = 5.9719201914e-10_wp !> alpha particle mass energy equivalent in MeV (MeV) real ( wp ), parameter :: alpha_particle_mass_energy_equivalent_in_MeV = 372 7.3794066_wp !> alpha particle mass in u (u) real ( wp ), parameter :: alpha_particle_mass_in_u = 4.001506179127_wp !> alpha particle molar mass (kg mol&#94;-1) real ( wp ), parameter :: alpha_particle_molar_mass = 4.0015061777e-3_wp !> alpha particle-proton mass ratio (dimensionless) real ( wp ), parameter :: alpha_particle_proton_mass_ratio = 3.97259969009_wp !> alpha particle relative atomic mass (dimensionless) real ( wp ), parameter :: alpha_particle_relative_atomic_mass = 4.001506179127_wp !> Angstrom star (m) real ( wp ), parameter :: Angstrom_star = 1.00001495e-10_wp !> atomic mass constant (kg) real ( wp ), parameter :: atomic_mass_constant = 1.66053906660e-27_wp !> atomic mass constant energy equivalent (J) real ( wp ), parameter :: atomic_mass_constant_energy_equivalent = 1.49241808560e-10_wp !> atomic mass constant energy equivalent in MeV (MeV) real ( wp ), parameter :: atomic_mass_constant_energy_equivalent_in_MeV = 93 1.49410242_wp !> atomic mass unit-electron volt relationship (eV) real ( wp ), parameter :: atomic_mass_unit_electron_volt_relationship = 9.3149410242e8_wp !> atomic mass unit-hartree relationship (E_h) real ( wp ), parameter :: atomic_mass_unit_hartree_relationship = 3.4231776874e7_wp !> atomic mass unit-hertz relationship (Hz) real ( wp ), parameter :: atomic_mass_unit_hertz_relationship = 2.25234271871e23_wp !> atomic mass unit-inverse meter relationship (m&#94;-1) real ( wp ), parameter :: atomic_mass_unit_inverse_meter_relationship = 7.5130066104e14_wp !> atomic mass unit-joule relationship (J) real ( wp ), parameter :: atomic_mass_unit_joule_relationship = 1.49241808560e-10_wp !> atomic mass unit-kelvin relationship (K) real ( wp ), parameter :: atomic_mass_unit_kelvin_relationship = 1.08095401916e13_wp !> atomic mass unit-kilogram relationship (kg) real ( wp ), parameter :: atomic_mass_unit_kilogram_relationship = 1.66053906660e-27_wp !> atomic unit of 1st hyperpolarizability (C&#94;3 m&#94;3 J&#94;-2) real ( wp ), parameter :: atomic_unit_of_1st_hyperpolarizability = 3.2063613061e-53_wp !> atomic unit of 2nd hyperpolarizability (C&#94;4 m&#94;4 J&#94;-3) real ( wp ), parameter :: atomic_unit_of_2nd_hyperpolarizability = 6.2353799905e-65_wp !> atomic unit of action (J s) real ( wp ), parameter :: atomic_unit_of_action = 1.054571817e-34_wp !> atomic unit of charge (C) real ( wp ), parameter :: atomic_unit_of_charge = 1.602176634e-19_wp !> atomic unit of charge density (C m&#94;-3) real ( wp ), parameter :: atomic_unit_of_charge_density = 1.08120238457e12_wp !> atomic unit of current (A) real ( wp ), parameter :: atomic_unit_of_current = 6.623618237510e-3_wp !> atomic unit of electric dipole mom. (C m) real ( wp ), parameter :: atomic_unit_of_electric_dipole_mom_ = 8.4783536255e-30_wp !> atomic unit of electric field (V m&#94;-1) real ( wp ), parameter :: atomic_unit_of_electric_field = 5.14220674763e11_wp !> atomic unit of electric field gradient (V m&#94;-2) real ( wp ), parameter :: atomic_unit_of_electric_field_gradient = 9.7173624292e21_wp !> atomic unit of electric polarizability (C&#94;2 m&#94;2 J&#94;-1) real ( wp ), parameter :: atomic_unit_of_electric_polarizability = 1.64877727436e-41_wp !> atomic unit of electric potential (V) real ( wp ), parameter :: atomic_unit_of_electric_potential = 2 7.211386245988_wp !> atomic unit of electric quadrupole mom. (C m&#94;2) real ( wp ), parameter :: atomic_unit_of_electric_quadrupole_mom_ = 4.4865515246e-40_wp !> atomic unit of energy (J) real ( wp ), parameter :: atomic_unit_of_energy = 4.3597447222071e-18_wp !> atomic unit of force (N) real ( wp ), parameter :: atomic_unit_of_force = 8.2387234983e-8_wp !> atomic unit of length (m) real ( wp ), parameter :: atomic_unit_of_length = 5.29177210903e-11_wp !> atomic unit of mag. dipole mom. (J T&#94;-1) real ( wp ), parameter :: atomic_unit_of_mag__dipole_mom_ = 1.85480201566e-23_wp !> atomic unit of mag. flux density (T) real ( wp ), parameter :: atomic_unit_of_mag__flux_density = 2.35051756758e5_wp !> atomic unit of magnetizability (J T&#94;-2) real ( wp ), parameter :: atomic_unit_of_magnetizability = 7.8910366008e-29_wp !> atomic unit of mass (kg) real ( wp ), parameter :: atomic_unit_of_mass = 9.1093837015e-31_wp !> atomic unit of momentum (kg m s&#94;-1) real ( wp ), parameter :: atomic_unit_of_momentum = 1.99285191410e-24_wp !> atomic unit of permittivity (F m&#94;-1) real ( wp ), parameter :: atomic_unit_of_permittivity = 1.11265005545e-10_wp !> atomic unit of time (s) real ( wp ), parameter :: atomic_unit_of_time = 2.4188843265857e-17_wp !> atomic unit of velocity (m s&#94;-1) real ( wp ), parameter :: atomic_unit_of_velocity = 2.18769126364e6_wp !> Avogadro constant (mol&#94;-1) real ( wp ), parameter :: Avogadro_constant = 6.02214076e23_wp !> Bohr magneton (J T&#94;-1) real ( wp ), parameter :: Bohr_magneton = 9.2740100783e-24_wp !> Bohr magneton in eV/T (eV T&#94;-1) real ( wp ), parameter :: Bohr_magneton_in_eV_T = 5.7883818060e-5_wp !> Bohr magneton in Hz/T (Hz T&#94;-1) real ( wp ), parameter :: Bohr_magneton_in_Hz_T = 1.39962449361e10_wp !> Bohr magneton in inverse meter per tesla (m&#94;-1 T&#94;-1) real ( wp ), parameter :: Bohr_magneton_in_inverse_meter_per_tesla = 4 6.686447783_wp !> Bohr magneton in K/T (K T&#94;-1) real ( wp ), parameter :: Bohr_magneton_in_K_T = 0.67171381563_wp !> Bohr radius (m) real ( wp ), parameter :: Bohr_radius = 5.29177210903e-11_wp !> Boltzmann constant (J K&#94;-1) real ( wp ), parameter :: Boltzmann_constant = 1.380649e-23_wp !> Boltzmann constant in eV/K (eV K&#94;-1) real ( wp ), parameter :: Boltzmann_constant_in_eV_K = 8.617333262e-5_wp !> Boltzmann constant in Hz/K (Hz K&#94;-1) real ( wp ), parameter :: Boltzmann_constant_in_Hz_K = 2.083661912e10_wp !> Boltzmann constant in inverse meter per kelvin (m&#94;-1 K&#94;-1) real ( wp ), parameter :: Boltzmann_constant_in_inverse_meter_per_kelvin = 6 9.50348004_wp !> characteristic impedance of vacuum (ohm) real ( wp ), parameter :: characteristic_impedance_of_vacuum = 37 6.730313668_wp !> classical electron radius (m) real ( wp ), parameter :: classical_electron_radius = 2.8179403262e-15_wp !> Compton wavelength (m) real ( wp ), parameter :: Compton_wavelength = 2.42631023867e-12_wp !> conductance quantum (S) real ( wp ), parameter :: conductance_quantum = 7.748091729e-5_wp !> conventional value of ampere-90 (A) real ( wp ), parameter :: conventional_value_of_ampere_90 = 1.00000008887_wp !> conventional value of coulomb-90 (C) real ( wp ), parameter :: conventional_value_of_coulomb_90 = 1.00000008887_wp !> conventional value of farad-90 (F) real ( wp ), parameter :: conventional_value_of_farad_90 = 0.99999998220_wp !> conventional value of henry-90 (H) real ( wp ), parameter :: conventional_value_of_henry_90 = 1.00000001779_wp !> conventional value of Josephson constant (Hz V&#94;-1) real ( wp ), parameter :: conventional_value_of_Josephson_constant = 48359 7.9e9_wp !> conventional value of ohm-90 (ohm) real ( wp ), parameter :: conventional_value_of_ohm_90 = 1.00000001779_wp !> conventional value of volt-90 (V) real ( wp ), parameter :: conventional_value_of_volt_90 = 1.00000010666_wp !> conventional value of von Klitzing constant (ohm) real ( wp ), parameter :: conventional_value_of_von_Klitzing_constant = 2581 2.807_wp !> conventional value of watt-90 (W) real ( wp ), parameter :: conventional_value_of_watt_90 = 1.00000019553_wp !> Copper x unit (m) real ( wp ), parameter :: Copper_x_unit = 1.00207697e-13_wp !> deuteron-electron mag. mom. ratio (dimensionless) real ( wp ), parameter :: deuteron_electron_mag__mom__ratio = - 4.664345551e-4_wp !> deuteron-electron mass ratio (dimensionless) real ( wp ), parameter :: deuteron_electron_mass_ratio = 367 0.48296788_wp !> deuteron g factor (dimensionless) real ( wp ), parameter :: deuteron_g_factor = 0.8574382338_wp !> deuteron mag. mom. (J T&#94;-1) real ( wp ), parameter :: deuteron_mag__mom_ = 4.330735094e-27_wp !> deuteron mag. mom. to Bohr magneton ratio (dimensionless) real ( wp ), parameter :: deuteron_mag__mom__to_Bohr_magneton_ratio = 4.669754570e-4_wp !> deuteron mag. mom. to nuclear magneton ratio (dimensionless) real ( wp ), parameter :: deuteron_mag__mom__to_nuclear_magneton_ratio = 0.8574382338_wp !> deuteron mass (kg) real ( wp ), parameter :: deuteron_mass = 3.3435837724e-27_wp !> deuteron mass energy equivalent (J) real ( wp ), parameter :: deuteron_mass_energy_equivalent = 3.00506323102e-10_wp !> deuteron mass energy equivalent in MeV (MeV) real ( wp ), parameter :: deuteron_mass_energy_equivalent_in_MeV = 187 5.61294257_wp !> deuteron mass in u (u) real ( wp ), parameter :: deuteron_mass_in_u = 2.013553212745_wp !> deuteron molar mass (kg mol&#94;-1) real ( wp ), parameter :: deuteron_molar_mass = 2.01355321205e-3_wp !> deuteron-neutron mag. mom. ratio (dimensionless) real ( wp ), parameter :: deuteron_neutron_mag__mom__ratio = - 0.44820653_wp !> deuteron-proton mag. mom. ratio (dimensionless) real ( wp ), parameter :: deuteron_proton_mag__mom__ratio = 0.30701220939_wp !> deuteron-proton mass ratio (dimensionless) real ( wp ), parameter :: deuteron_proton_mass_ratio = 1.99900750139_wp !> deuteron relative atomic mass (dimensionless) real ( wp ), parameter :: deuteron_relative_atomic_mass = 2.013553212745_wp !> deuteron rms charge radius (m) real ( wp ), parameter :: deuteron_rms_charge_radius = 2.12799e-15_wp !> electron charge to mass quotient (C kg&#94;-1) real ( wp ), parameter :: electron_charge_to_mass_quotient = - 1.75882001076e11_wp !> electron-deuteron mag. mom. ratio (dimensionless) real ( wp ), parameter :: electron_deuteron_mag__mom__ratio = - 214 3.9234915_wp !> electron-deuteron mass ratio (dimensionless) real ( wp ), parameter :: electron_deuteron_mass_ratio = 2.724437107462e-4_wp !> electron g factor (dimensionless) real ( wp ), parameter :: electron_g_factor = - 2.00231930436256_wp !> electron gyromag. ratio (s&#94;-1 T&#94;-1) real ( wp ), parameter :: electron_gyromag__ratio = 1.76085963023e11_wp !> electron gyromag. ratio in MHz/T (MHz T&#94;-1) real ( wp ), parameter :: electron_gyromag__ratio_in_MHz_T = 2802 4.9514242_wp !> electron-helion mass ratio (dimensionless) real ( wp ), parameter :: electron_helion_mass_ratio = 1.819543074573e-4_wp !> electron mag. mom. (J T&#94;-1) real ( wp ), parameter :: electron_mag__mom_ = - 9.2847647043e-24_wp !> electron mag. mom. anomaly (dimensionless) real ( wp ), parameter :: electron_mag__mom__anomaly = 1.15965218128e-3_wp !> electron mag. mom. to Bohr magneton ratio (dimensionless) real ( wp ), parameter :: electron_mag__mom__to_Bohr_magneton_ratio = - 1.00115965218128_wp !> electron mag. mom. to nuclear magneton ratio (dimensionless) real ( wp ), parameter :: electron_mag__mom__to_nuclear_magneton_ratio = - 183 8.28197188_wp !> electron mass (kg) real ( wp ), parameter :: electron_mass = 9.1093837015e-31_wp !> electron mass energy equivalent (J) real ( wp ), parameter :: electron_mass_energy_equivalent = 8.1871057769e-14_wp !> electron mass energy equivalent in MeV (MeV) real ( wp ), parameter :: electron_mass_energy_equivalent_in_MeV = 0.51099895000_wp !> electron mass in u (u) real ( wp ), parameter :: electron_mass_in_u = 5.48579909065e-4_wp !> electron molar mass (kg mol&#94;-1) real ( wp ), parameter :: electron_molar_mass = 5.4857990888e-7_wp !> electron-muon mag. mom. ratio (dimensionless) real ( wp ), parameter :: electron_muon_mag__mom__ratio = 20 6.7669883_wp !> electron-muon mass ratio (dimensionless) real ( wp ), parameter :: electron_muon_mass_ratio = 4.83633169e-3_wp !> electron-neutron mag. mom. ratio (dimensionless) real ( wp ), parameter :: electron_neutron_mag__mom__ratio = 96 0.92050_wp !> electron-neutron mass ratio (dimensionless) real ( wp ), parameter :: electron_neutron_mass_ratio = 5.4386734424e-4_wp !> electron-proton mag. mom. ratio (dimensionless) real ( wp ), parameter :: electron_proton_mag__mom__ratio = - 65 8.21068789_wp !> electron-proton mass ratio (dimensionless) real ( wp ), parameter :: electron_proton_mass_ratio = 5.44617021487e-4_wp !> electron relative atomic mass (dimensionless) real ( wp ), parameter :: electron_relative_atomic_mass = 5.48579909065e-4_wp !> electron-tau mass ratio (dimensionless) real ( wp ), parameter :: electron_tau_mass_ratio = 2.87585e-4_wp !> electron to alpha particle mass ratio (dimensionless) real ( wp ), parameter :: electron_to_alpha_particle_mass_ratio = 1.370933554787e-4_wp !> electron to shielded helion mag. mom. ratio (dimensionless) real ( wp ), parameter :: electron_to_shielded_helion_mag__mom__ratio = 86 4.058257_wp !> electron to shielded proton mag. mom. ratio (dimensionless) real ( wp ), parameter :: electron_to_shielded_proton_mag__mom__ratio = - 65 8.2275971_wp !> electron-triton mass ratio (dimensionless) real ( wp ), parameter :: electron_triton_mass_ratio = 1.819200062251e-4_wp !> electron volt (J) real ( wp ), parameter :: electron_volt = 1.602176634e-19_wp !> electron volt-atomic mass unit relationship (u) real ( wp ), parameter :: electron_volt_atomic_mass_unit_relationship = 1.07354410233e-9_wp !> electron volt-hartree relationship (E_h) real ( wp ), parameter :: electron_volt_hartree_relationship = 3.6749322175655e-2_wp !> electron volt-hertz relationship (Hz) real ( wp ), parameter :: electron_volt_hertz_relationship = 2.417989242e14_wp !> electron volt-inverse meter relationship (m&#94;-1) real ( wp ), parameter :: electron_volt_inverse_meter_relationship = 8.065543937e5_wp !> electron volt-joule relationship (J) real ( wp ), parameter :: electron_volt_joule_relationship = 1.602176634e-19_wp !> electron volt-kelvin relationship (K) real ( wp ), parameter :: electron_volt_kelvin_relationship = 1.160451812e4_wp !> electron volt-kilogram relationship (kg) real ( wp ), parameter :: electron_volt_kilogram_relationship = 1.782661921e-36_wp !> elementary charge (C) real ( wp ), parameter :: elementary_charge = 1.602176634e-19_wp !> elementary charge over h-bar (A J&#94;-1) real ( wp ), parameter :: elementary_charge_over_h_bar = 1.519267447e15_wp !> Faraday constant (C mol&#94;-1) real ( wp ), parameter :: Faraday_constant = 9648 5.33212_wp !> Fermi coupling constant (GeV&#94;-2) real ( wp ), parameter :: Fermi_coupling_constant = 1.1663787e-5_wp !> fine-structure constant (dimensionless) real ( wp ), parameter :: fine_structure_constant = 7.2973525693e-3_wp !> first radiation constant (W m&#94;2) real ( wp ), parameter :: first_radiation_constant = 3.741771852e-16_wp !> first radiation constant for spectral radiance (W m&#94;2 sr&#94;-1) real ( wp ), parameter :: first_radiation_constant_for_spectral_radiance = 1.191042972e-16_wp !> hartree-atomic mass unit relationship (u) real ( wp ), parameter :: hartree_atomic_mass_unit_relationship = 2.92126232205e-8_wp !> hartree-electron volt relationship (eV) real ( wp ), parameter :: hartree_electron_volt_relationship = 2 7.211386245988_wp !> Hartree energy (J) real ( wp ), parameter :: Hartree_energy = 4.3597447222071e-18_wp !> Hartree energy in eV (eV) real ( wp ), parameter :: Hartree_energy_in_eV = 2 7.211386245988_wp !> hartree-hertz relationship (Hz) real ( wp ), parameter :: hartree_hertz_relationship = 6.579683920502e15_wp !> hartree-inverse meter relationship (m&#94;-1) real ( wp ), parameter :: hartree_inverse_meter_relationship = 2.1947463136320e7_wp !> hartree-joule relationship (J) real ( wp ), parameter :: hartree_joule_relationship = 4.3597447222071e-18_wp !> hartree-kelvin relationship (K) real ( wp ), parameter :: hartree_kelvin_relationship = 3.1577502480407e5_wp !> hartree-kilogram relationship (kg) real ( wp ), parameter :: hartree_kilogram_relationship = 4.8508702095432e-35_wp !> helion-electron mass ratio (dimensionless) real ( wp ), parameter :: helion_electron_mass_ratio = 549 5.88528007_wp !> helion g factor (dimensionless) real ( wp ), parameter :: helion_g_factor = - 4.255250615_wp !> helion mag. mom. (J T&#94;-1) real ( wp ), parameter :: helion_mag__mom_ = - 1.074617532e-26_wp !> helion mag. mom. to Bohr magneton ratio (dimensionless) real ( wp ), parameter :: helion_mag__mom__to_Bohr_magneton_ratio = - 1.158740958e-3_wp !> helion mag. mom. to nuclear magneton ratio (dimensionless) real ( wp ), parameter :: helion_mag__mom__to_nuclear_magneton_ratio = - 2.127625307_wp !> helion mass (kg) real ( wp ), parameter :: helion_mass = 5.0064127796e-27_wp !> helion mass energy equivalent (J) real ( wp ), parameter :: helion_mass_energy_equivalent = 4.4995394125e-10_wp !> helion mass energy equivalent in MeV (MeV) real ( wp ), parameter :: helion_mass_energy_equivalent_in_MeV = 280 8.39160743_wp !> helion mass in u (u) real ( wp ), parameter :: helion_mass_in_u = 3.014932247175_wp !> helion molar mass (kg mol&#94;-1) real ( wp ), parameter :: helion_molar_mass = 3.01493224613e-3_wp !> helion-proton mass ratio (dimensionless) real ( wp ), parameter :: helion_proton_mass_ratio = 2.99315267167_wp !> helion relative atomic mass (dimensionless) real ( wp ), parameter :: helion_relative_atomic_mass = 3.014932247175_wp !> helion shielding shift (dimensionless) real ( wp ), parameter :: helion_shielding_shift = 5.996743e-5_wp !> hertz-atomic mass unit relationship (u) real ( wp ), parameter :: hertz_atomic_mass_unit_relationship = 4.4398216652e-24_wp !> hertz-electron volt relationship (eV) real ( wp ), parameter :: hertz_electron_volt_relationship = 4.135667696e-15_wp !> hertz-hartree relationship (E_h) real ( wp ), parameter :: hertz_hartree_relationship = 1.5198298460570e-16_wp !> hertz-inverse meter relationship (m&#94;-1) real ( wp ), parameter :: hertz_inverse_meter_relationship = 3.335640951e-9_wp !> hertz-joule relationship (J) real ( wp ), parameter :: hertz_joule_relationship = 6.62607015e-34_wp !> hertz-kelvin relationship (K) real ( wp ), parameter :: hertz_kelvin_relationship = 4.799243073e-11_wp !> hertz-kilogram relationship (kg) real ( wp ), parameter :: hertz_kilogram_relationship = 7.372497323e-51_wp !> hyperfine transition frequency of Cs-133 (Hz) real ( wp ), parameter :: hyperfine_transition_frequency_of_Cs_133 = 919263177 0e0_wp !> inverse fine-structure constant (dimensionless) real ( wp ), parameter :: inverse_fine_structure_constant = 13 7.035999084_wp !> inverse meter-atomic mass unit relationship (u) real ( wp ), parameter :: inverse_meter_atomic_mass_unit_relationship = 1.33102505010e-15_wp !> inverse meter-electron volt relationship (eV) real ( wp ), parameter :: inverse_meter_electron_volt_relationship = 1.239841984e-6_wp !> inverse meter-hartree relationship (E_h) real ( wp ), parameter :: inverse_meter_hartree_relationship = 4.5563352529120e-8_wp !> inverse meter-hertz relationship (Hz) real ( wp ), parameter :: inverse_meter_hertz_relationship = 29979245 8e0_wp !> inverse meter-joule relationship (J) real ( wp ), parameter :: inverse_meter_joule_relationship = 1.986445857e-25_wp !> inverse meter-kelvin relationship (K) real ( wp ), parameter :: inverse_meter_kelvin_relationship = 1.438776877e-2_wp !> inverse meter-kilogram relationship (kg) real ( wp ), parameter :: inverse_meter_kilogram_relationship = 2.210219094e-42_wp !> inverse of conductance quantum (ohm) real ( wp ), parameter :: inverse_of_conductance_quantum = 1290 6.40372_wp !> Josephson constant (Hz V&#94;-1) real ( wp ), parameter :: Josephson_constant = 48359 7.8484e9_wp !> joule-atomic mass unit relationship (u) real ( wp ), parameter :: joule_atomic_mass_unit_relationship = 6.7005352565e9_wp !> joule-electron volt relationship (eV) real ( wp ), parameter :: joule_electron_volt_relationship = 6.241509074e18_wp !> joule-hartree relationship (E_h) real ( wp ), parameter :: joule_hartree_relationship = 2.2937122783963e17_wp !> joule-hertz relationship (Hz) real ( wp ), parameter :: joule_hertz_relationship = 1.509190179e33_wp !> joule-inverse meter relationship (m&#94;-1) real ( wp ), parameter :: joule_inverse_meter_relationship = 5.034116567e24_wp !> joule-kelvin relationship (K) real ( wp ), parameter :: joule_kelvin_relationship = 7.242970516e22_wp !> joule-kilogram relationship (kg) real ( wp ), parameter :: joule_kilogram_relationship = 1.112650056e-17_wp !> kelvin-atomic mass unit relationship (u) real ( wp ), parameter :: kelvin_atomic_mass_unit_relationship = 9.2510873014e-14_wp !> kelvin-electron volt relationship (eV) real ( wp ), parameter :: kelvin_electron_volt_relationship = 8.617333262e-5_wp !> kelvin-hartree relationship (E_h) real ( wp ), parameter :: kelvin_hartree_relationship = 3.1668115634556e-6_wp !> kelvin-hertz relationship (Hz) real ( wp ), parameter :: kelvin_hertz_relationship = 2.083661912e10_wp !> kelvin-inverse meter relationship (m&#94;-1) real ( wp ), parameter :: kelvin_inverse_meter_relationship = 6 9.50348004_wp !> kelvin-joule relationship (J) real ( wp ), parameter :: kelvin_joule_relationship = 1.380649e-23_wp !> kelvin-kilogram relationship (kg) real ( wp ), parameter :: kelvin_kilogram_relationship = 1.536179187e-40_wp !> kilogram-atomic mass unit relationship (u) real ( wp ), parameter :: kilogram_atomic_mass_unit_relationship = 6.0221407621e26_wp !> kilogram-electron volt relationship (eV) real ( wp ), parameter :: kilogram_electron_volt_relationship = 5.609588603e35_wp !> kilogram-hartree relationship (E_h) real ( wp ), parameter :: kilogram_hartree_relationship = 2.0614857887409e34_wp !> kilogram-hertz relationship (Hz) real ( wp ), parameter :: kilogram_hertz_relationship = 1.356392489e50_wp !> kilogram-inverse meter relationship (m&#94;-1) real ( wp ), parameter :: kilogram_inverse_meter_relationship = 4.524438335e41_wp !> kilogram-joule relationship (J) real ( wp ), parameter :: kilogram_joule_relationship = 8.987551787e16_wp !> kilogram-kelvin relationship (K) real ( wp ), parameter :: kilogram_kelvin_relationship = 6.509657260e39_wp !> lattice parameter of silicon (m) real ( wp ), parameter :: lattice_parameter_of_silicon = 5.431020511e-10_wp !> lattice spacing of ideal Si (220) (m) real ( wp ), parameter :: lattice_spacing_of_ideal_Si_220 = 1.920155716e-10_wp !> Loschmidt constant (273.15 K, 100 kPa) (m&#94;-3) real ( wp ), parameter :: Loschmidt_constant_273_15_K__100_kPa = 2.651645804e25_wp !> Loschmidt constant (273.15 K, 101.325 kPa) (m&#94;-3) real ( wp ), parameter :: Loschmidt_constant_273_15_K__101_325_kPa = 2.686780111e25_wp !> luminous efficacy (lm W&#94;-1) real ( wp ), parameter :: luminous_efficacy = 68 3e0_wp !> mag. flux quantum (Wb) real ( wp ), parameter :: mag__flux_quantum = 2.067833848e-15_wp !> molar gas constant (J mol&#94;-1 K&#94;-1) real ( wp ), parameter :: molar_gas_constant = 8.314462618_wp !> molar mass constant (kg mol&#94;-1) real ( wp ), parameter :: molar_mass_constant = 0.99999999965e-3_wp !> molar mass of carbon-12 (kg mol&#94;-1) real ( wp ), parameter :: molar_mass_of_carbon_12 = 1 1.9999999958e-3_wp !> molar Planck constant (J Hz&#94;-1 mol&#94;-1) real ( wp ), parameter :: molar_Planck_constant = 3.990312712e-10_wp !> molar volume of ideal gas (273.15 K, 100 kPa) (m&#94;3 mol&#94;-1) real ( wp ), parameter :: molar_volume_of_ideal_gas_273_15_K__100_kPa = 2 2.71095464e-3_wp !> molar volume of ideal gas (273.15 K, 101.325 kPa) (m&#94;3 mol&#94;-1) real ( wp ), parameter :: molar_volume_of_ideal_gas_273_15_K__101_325_kPa = 2 2.41396954e-3_wp !> molar volume of silicon (m&#94;3 mol&#94;-1) real ( wp ), parameter :: molar_volume_of_silicon = 1.205883199e-5_wp !> Molybdenum x unit (m) real ( wp ), parameter :: Molybdenum_x_unit = 1.00209952e-13_wp !> muon Compton wavelength (m) real ( wp ), parameter :: muon_Compton_wavelength = 1.173444110e-14_wp !> muon-electron mass ratio (dimensionless) real ( wp ), parameter :: muon_electron_mass_ratio = 20 6.7682830_wp !> muon g factor (dimensionless) real ( wp ), parameter :: muon_g_factor = - 2.0023318418_wp !> muon mag. mom. (J T&#94;-1) real ( wp ), parameter :: muon_mag__mom_ = - 4.49044830e-26_wp !> muon mag. mom. anomaly (dimensionless) real ( wp ), parameter :: muon_mag__mom__anomaly = 1.16592089e-3_wp !> muon mag. mom. to Bohr magneton ratio (dimensionless) real ( wp ), parameter :: muon_mag__mom__to_Bohr_magneton_ratio = - 4.84197047e-3_wp !> muon mag. mom. to nuclear magneton ratio (dimensionless) real ( wp ), parameter :: muon_mag__mom__to_nuclear_magneton_ratio = - 8.89059703_wp !> muon mass (kg) real ( wp ), parameter :: muon_mass = 1.883531627e-28_wp !> muon mass energy equivalent (J) real ( wp ), parameter :: muon_mass_energy_equivalent = 1.692833804e-11_wp !> muon mass energy equivalent in MeV (MeV) real ( wp ), parameter :: muon_mass_energy_equivalent_in_MeV = 10 5.6583755_wp !> muon mass in u (u) real ( wp ), parameter :: muon_mass_in_u = 0.1134289259_wp !> muon molar mass (kg mol&#94;-1) real ( wp ), parameter :: muon_molar_mass = 1.134289259e-4_wp !> muon-neutron mass ratio (dimensionless) real ( wp ), parameter :: muon_neutron_mass_ratio = 0.1124545170_wp !> muon-proton mag. mom. ratio (dimensionless) real ( wp ), parameter :: muon_proton_mag__mom__ratio = - 3.183345142_wp !> muon-proton mass ratio (dimensionless) real ( wp ), parameter :: muon_proton_mass_ratio = 0.1126095264_wp !> muon-tau mass ratio (dimensionless) real ( wp ), parameter :: muon_tau_mass_ratio = 5.94635e-2_wp !> natural unit of action (J s) real ( wp ), parameter :: natural_unit_of_action = 1.054571817e-34_wp !> natural unit of action in eV s (eV s) real ( wp ), parameter :: natural_unit_of_action_in_eV_s = 6.582119569e-16_wp !> natural unit of energy (J) real ( wp ), parameter :: natural_unit_of_energy = 8.1871057769e-14_wp !> natural unit of energy in MeV (MeV) real ( wp ), parameter :: natural_unit_of_energy_in_MeV = 0.51099895000_wp !> natural unit of length (m) real ( wp ), parameter :: natural_unit_of_length = 3.8615926796e-13_wp !> natural unit of mass (kg) real ( wp ), parameter :: natural_unit_of_mass = 9.1093837015e-31_wp !> natural unit of momentum (kg m s&#94;-1) real ( wp ), parameter :: natural_unit_of_momentum = 2.73092453075e-22_wp !> natural unit of momentum in MeV/c (MeV/c) real ( wp ), parameter :: natural_unit_of_momentum_in_MeV_c = 0.51099895000_wp !> natural unit of time (s) real ( wp ), parameter :: natural_unit_of_time = 1.28808866819e-21_wp !> natural unit of velocity (m s&#94;-1) real ( wp ), parameter :: natural_unit_of_velocity = 29979245 8e0_wp !> neutron Compton wavelength (m) real ( wp ), parameter :: neutron_Compton_wavelength = 1.31959090581e-15_wp !> neutron-electron mag. mom. ratio (dimensionless) real ( wp ), parameter :: neutron_electron_mag__mom__ratio = 1.04066882e-3_wp !> neutron-electron mass ratio (dimensionless) real ( wp ), parameter :: neutron_electron_mass_ratio = 183 8.68366173_wp !> neutron g factor (dimensionless) real ( wp ), parameter :: neutron_g_factor = - 3.82608545_wp !> neutron gyromag. ratio (s&#94;-1 T&#94;-1) real ( wp ), parameter :: neutron_gyromag__ratio = 1.83247171e8_wp !> neutron gyromag. ratio in MHz/T (MHz T&#94;-1) real ( wp ), parameter :: neutron_gyromag__ratio_in_MHz_T = 2 9.1646931_wp !> neutron mag. mom. (J T&#94;-1) real ( wp ), parameter :: neutron_mag__mom_ = - 9.6623651e-27_wp !> neutron mag. mom. to Bohr magneton ratio (dimensionless) real ( wp ), parameter :: neutron_mag__mom__to_Bohr_magneton_ratio = - 1.04187563e-3_wp !> neutron mag. mom. to nuclear magneton ratio (dimensionless) real ( wp ), parameter :: neutron_mag__mom__to_nuclear_magneton_ratio = - 1.91304273_wp !> neutron mass (kg) real ( wp ), parameter :: neutron_mass = 1.67492749804e-27_wp !> neutron mass energy equivalent (J) real ( wp ), parameter :: neutron_mass_energy_equivalent = 1.50534976287e-10_wp !> neutron mass energy equivalent in MeV (MeV) real ( wp ), parameter :: neutron_mass_energy_equivalent_in_MeV = 93 9.56542052_wp !> neutron mass in u (u) real ( wp ), parameter :: neutron_mass_in_u = 1.00866491595_wp !> neutron molar mass (kg mol&#94;-1) real ( wp ), parameter :: neutron_molar_mass = 1.00866491560e-3_wp !> neutron-muon mass ratio (dimensionless) real ( wp ), parameter :: neutron_muon_mass_ratio = 8.89248406_wp !> neutron-proton mag. mom. ratio (dimensionless) real ( wp ), parameter :: neutron_proton_mag__mom__ratio = - 0.68497934_wp !> neutron-proton mass difference (kg) real ( wp ), parameter :: neutron_proton_mass_difference = 2.30557435e-30_wp !> neutron-proton mass difference energy equivalent (J) real ( wp ), parameter :: neutron_proton_mass_difference_energy_equivalent = 2.07214689e-13_wp !> neutron-proton mass difference energy equivalent in MeV (MeV) real ( wp ), parameter :: neutron_proton_mass_difference_energy_equivalent_in_MeV = 1.29333236_wp !> neutron-proton mass difference in u (u) real ( wp ), parameter :: neutron_proton_mass_difference_in_u = 1.38844933e-3_wp !> neutron-proton mass ratio (dimensionless) real ( wp ), parameter :: neutron_proton_mass_ratio = 1.00137841931_wp !> neutron relative atomic mass (dimensionless) real ( wp ), parameter :: neutron_relative_atomic_mass = 1.00866491595_wp !> neutron-tau mass ratio (dimensionless) real ( wp ), parameter :: neutron_tau_mass_ratio = 0.528779_wp !> neutron to shielded proton mag. mom. ratio (dimensionless) real ( wp ), parameter :: neutron_to_shielded_proton_mag__mom__ratio = - 0.68499694_wp !> Newtonian constant of gravitation (m&#94;3 kg&#94;-1 s&#94;-2) real ( wp ), parameter :: Newtonian_constant_of_gravitation = 6.67430e-11_wp !> Newtonian constant of gravitation over h-bar c ((GeV/c&#94;2)&#94;-2) real ( wp ), parameter :: Newtonian_constant_of_gravitation_over_h_bar_c = 6.70883e-39_wp !> nuclear magneton (J T&#94;-1) real ( wp ), parameter :: nuclear_magneton = 5.0507837461e-27_wp !> nuclear magneton in eV/T (eV T&#94;-1) real ( wp ), parameter :: nuclear_magneton_in_eV_T = 3.15245125844e-8_wp !> nuclear magneton in inverse meter per tesla (m&#94;-1 T&#94;-1) real ( wp ), parameter :: nuclear_magneton_in_inverse_meter_per_tesla = 2.54262341353e-2_wp !> nuclear magneton in K/T (K T&#94;-1) real ( wp ), parameter :: nuclear_magneton_in_K_T = 3.6582677756e-4_wp !> nuclear magneton in MHz/T (MHz T&#94;-1) real ( wp ), parameter :: nuclear_magneton_in_MHz_T = 7.6225932291_wp !> Planck constant (J Hz&#94;-1) real ( wp ), parameter :: Planck_constant = 6.62607015e-34_wp !> Planck constant in eV/Hz (eV Hz&#94;-1) real ( wp ), parameter :: Planck_constant_in_eV_Hz = 4.135667696e-15_wp !> Planck length (m) real ( wp ), parameter :: Planck_length = 1.616255e-35_wp !> Planck mass (kg) real ( wp ), parameter :: Planck_mass = 2.176434e-8_wp !> Planck mass energy equivalent in GeV (GeV) real ( wp ), parameter :: Planck_mass_energy_equivalent_in_GeV = 1.220890e19_wp !> Planck temperature (K) real ( wp ), parameter :: Planck_temperature = 1.416784e32_wp !> Planck time (s) real ( wp ), parameter :: Planck_time = 5.391247e-44_wp !> proton charge to mass quotient (C kg&#94;-1) real ( wp ), parameter :: proton_charge_to_mass_quotient = 9.5788331560e7_wp !> proton Compton wavelength (m) real ( wp ), parameter :: proton_Compton_wavelength = 1.32140985539e-15_wp !> proton-electron mass ratio (dimensionless) real ( wp ), parameter :: proton_electron_mass_ratio = 183 6.15267343_wp !> proton g factor (dimensionless) real ( wp ), parameter :: proton_g_factor = 5.5856946893_wp !> proton gyromag. ratio (s&#94;-1 T&#94;-1) real ( wp ), parameter :: proton_gyromag__ratio = 2.6752218744e8_wp !> proton gyromag. ratio in MHz/T (MHz T&#94;-1) real ( wp ), parameter :: proton_gyromag__ratio_in_MHz_T = 4 2.577478518_wp !> proton mag. mom. (J T&#94;-1) real ( wp ), parameter :: proton_mag__mom_ = 1.41060679736e-26_wp !> proton mag. mom. to Bohr magneton ratio (dimensionless) real ( wp ), parameter :: proton_mag__mom__to_Bohr_magneton_ratio = 1.52103220230e-3_wp !> proton mag. mom. to nuclear magneton ratio (dimensionless) real ( wp ), parameter :: proton_mag__mom__to_nuclear_magneton_ratio = 2.79284734463_wp !> proton mag. shielding correction (dimensionless) real ( wp ), parameter :: proton_mag__shielding_correction = 2.5689e-5_wp !> proton mass (kg) real ( wp ), parameter :: proton_mass = 1.67262192369e-27_wp !> proton mass energy equivalent (J) real ( wp ), parameter :: proton_mass_energy_equivalent = 1.50327761598e-10_wp !> proton mass energy equivalent in MeV (MeV) real ( wp ), parameter :: proton_mass_energy_equivalent_in_MeV = 93 8.27208816_wp !> proton mass in u (u) real ( wp ), parameter :: proton_mass_in_u = 1.007276466621_wp !> proton molar mass (kg mol&#94;-1) real ( wp ), parameter :: proton_molar_mass = 1.00727646627e-3_wp !> proton-muon mass ratio (dimensionless) real ( wp ), parameter :: proton_muon_mass_ratio = 8.88024337_wp !> proton-neutron mag. mom. ratio (dimensionless) real ( wp ), parameter :: proton_neutron_mag__mom__ratio = - 1.45989805_wp !> proton-neutron mass ratio (dimensionless) real ( wp ), parameter :: proton_neutron_mass_ratio = 0.99862347812_wp !> proton relative atomic mass (dimensionless) real ( wp ), parameter :: proton_relative_atomic_mass = 1.007276466621_wp !> proton rms charge radius (m) real ( wp ), parameter :: proton_rms_charge_radius = 8.414e-16_wp !> proton-tau mass ratio (dimensionless) real ( wp ), parameter :: proton_tau_mass_ratio = 0.528051_wp !> quantum of circulation (m&#94;2 s&#94;-1) real ( wp ), parameter :: quantum_of_circulation = 3.6369475516e-4_wp !> quantum of circulation times 2 (m&#94;2 s&#94;-1) real ( wp ), parameter :: quantum_of_circulation_times_2 = 7.2738951032e-4_wp !> reduced Compton wavelength (m) real ( wp ), parameter :: reduced_Compton_wavelength = 3.8615926796e-13_wp !> reduced muon Compton wavelength (m) real ( wp ), parameter :: reduced_muon_Compton_wavelength = 1.867594306e-15_wp !> reduced neutron Compton wavelength (m) real ( wp ), parameter :: reduced_neutron_Compton_wavelength = 2.1001941552e-16_wp !> reduced Planck constant (J s) real ( wp ), parameter :: reduced_Planck_constant = 1.054571817e-34_wp !> reduced Planck constant in eV s (eV s) real ( wp ), parameter :: reduced_Planck_constant_in_eV_s = 6.582119569e-16_wp !> reduced Planck constant times c in MeV fm (MeV fm) real ( wp ), parameter :: reduced_Planck_constant_times_c_in_MeV_fm = 19 7.3269804_wp !> reduced proton Compton wavelength (m) real ( wp ), parameter :: reduced_proton_Compton_wavelength = 2.10308910336e-16_wp !> reduced tau Compton wavelength (m) real ( wp ), parameter :: reduced_tau_Compton_wavelength = 1.110538e-16_wp !> Rydberg constant (m&#94;-1) real ( wp ), parameter :: Rydberg_constant = 1097373 1.568160_wp !> Rydberg constant times c in Hz (Hz) real ( wp ), parameter :: Rydberg_constant_times_c_in_Hz = 3.2898419602508e15_wp !> Rydberg constant times hc in eV (eV) real ( wp ), parameter :: Rydberg_constant_times_hc_in_eV = 1 3.605693122994_wp !> Rydberg constant times hc in J (J) real ( wp ), parameter :: Rydberg_constant_times_hc_in_J = 2.1798723611035e-18_wp !> Sackur-Tetrode constant (1 K, 100 kPa) (dimensionless) real ( wp ), parameter :: Sackur_Tetrode_constant_1_K__100_kPa = - 1.15170753706_wp !> Sackur-Tetrode constant (1 K, 101.325 kPa) (dimensionless) real ( wp ), parameter :: Sackur_Tetrode_constant_1_K__101_325_kPa = - 1.16487052358_wp !> second radiation constant (m K) real ( wp ), parameter :: second_radiation_constant = 1.438776877e-2_wp !> shielded helion gyromag. ratio (s&#94;-1 T&#94;-1) real ( wp ), parameter :: shielded_helion_gyromag__ratio = 2.037894569e8_wp !> shielded helion gyromag. ratio in MHz/T (MHz T&#94;-1) real ( wp ), parameter :: shielded_helion_gyromag__ratio_in_MHz_T = 3 2.43409942_wp !> shielded helion mag. mom. (J T&#94;-1) real ( wp ), parameter :: shielded_helion_mag__mom_ = - 1.074553090e-26_wp !> shielded helion mag. mom. to Bohr magneton ratio (dimensionless) real ( wp ), parameter :: shielded_helion_mag__mom__to_Bohr_magneton_ratio = - 1.158671471e-3_wp !> shielded helion mag. mom. to nuclear magneton ratio (dimensionless) real ( wp ), parameter :: shielded_helion_mag__mom__to_nuclear_magneton_ratio = - 2.127497719_wp !> shielded helion to proton mag. mom. ratio (dimensionless) real ( wp ), parameter :: shielded_helion_to_proton_mag__mom__ratio = - 0.7617665618_wp !> shielded helion to shielded proton mag. mom. ratio (dimensionless) real ( wp ), parameter :: shielded_helion_to_shielded_proton_mag__mom__ratio = - 0.7617861313_wp !> shielded proton gyromag. ratio (s&#94;-1 T&#94;-1) real ( wp ), parameter :: shielded_proton_gyromag__ratio = 2.675153151e8_wp !> shielded proton gyromag. ratio in MHz/T (MHz T&#94;-1) real ( wp ), parameter :: shielded_proton_gyromag__ratio_in_MHz_T = 4 2.57638474_wp !> shielded proton mag. mom. (J T&#94;-1) real ( wp ), parameter :: shielded_proton_mag__mom_ = 1.410570560e-26_wp !> shielded proton mag. mom. to Bohr magneton ratio (dimensionless) real ( wp ), parameter :: shielded_proton_mag__mom__to_Bohr_magneton_ratio = 1.520993128e-3_wp !> shielded proton mag. mom. to nuclear magneton ratio (dimensionless) real ( wp ), parameter :: shielded_proton_mag__mom__to_nuclear_magneton_ratio = 2.792775599_wp !> shielding difference of d and p in HD (dimensionless) real ( wp ), parameter :: shielding_difference_of_d_and_p_in_HD = 2.0200e-8_wp !> shielding difference of t and p in HT (dimensionless) real ( wp ), parameter :: shielding_difference_of_t_and_p_in_HT = 2.4140e-8_wp !> speed of light in vacuum (m s&#94;-1) real ( wp ), parameter :: speed_of_light_in_vacuum = 29979245 8e0_wp !> standard acceleration of gravity (m s&#94;-2) real ( wp ), parameter :: standard_acceleration_of_gravity = 9.80665_wp !> standard atmosphere (Pa) real ( wp ), parameter :: standard_atmosphere = 10132 5e0_wp !> standard-state pressure (Pa) real ( wp ), parameter :: standard_state_pressure = 10000 0e0_wp !> Stefan-Boltzmann constant (W m&#94;-2 K&#94;-4) real ( wp ), parameter :: Stefan_Boltzmann_constant = 5.670374419e-8_wp !> tau Compton wavelength (m) real ( wp ), parameter :: tau_Compton_wavelength = 6.97771e-16_wp !> tau-electron mass ratio (dimensionless) real ( wp ), parameter :: tau_electron_mass_ratio = 347 7.23_wp !> tau energy equivalent (MeV) real ( wp ), parameter :: tau_energy_equivalent = 177 6.86_wp !> tau mass (kg) real ( wp ), parameter :: tau_mass = 3.16754e-27_wp !> tau mass energy equivalent (J) real ( wp ), parameter :: tau_mass_energy_equivalent = 2.84684e-10_wp !> tau mass in u (u) real ( wp ), parameter :: tau_mass_in_u = 1.90754_wp !> tau molar mass (kg mol&#94;-1) real ( wp ), parameter :: tau_molar_mass = 1.90754e-3_wp !> tau-muon mass ratio (dimensionless) real ( wp ), parameter :: tau_muon_mass_ratio = 1 6.8170_wp !> tau-neutron mass ratio (dimensionless) real ( wp ), parameter :: tau_neutron_mass_ratio = 1.89115_wp !> tau-proton mass ratio (dimensionless) real ( wp ), parameter :: tau_proton_mass_ratio = 1.89376_wp !> Thomson cross section (m&#94;2) real ( wp ), parameter :: Thomson_cross_section = 6.6524587321e-29_wp !> triton-electron mass ratio (dimensionless) real ( wp ), parameter :: triton_electron_mass_ratio = 549 6.92153573_wp !> triton g factor (dimensionless) real ( wp ), parameter :: triton_g_factor = 5.957924931_wp !> triton mag. mom. (J T&#94;-1) real ( wp ), parameter :: triton_mag__mom_ = 1.5046095202e-26_wp !> triton mag. mom. to Bohr magneton ratio (dimensionless) real ( wp ), parameter :: triton_mag__mom__to_Bohr_magneton_ratio = 1.6223936651e-3_wp !> triton mag. mom. to nuclear magneton ratio (dimensionless) real ( wp ), parameter :: triton_mag__mom__to_nuclear_magneton_ratio = 2.9789624656_wp !> triton mass (kg) real ( wp ), parameter :: triton_mass = 5.0073567446e-27_wp !> triton mass energy equivalent (J) real ( wp ), parameter :: triton_mass_energy_equivalent = 4.5003878060e-10_wp !> triton mass energy equivalent in MeV (MeV) real ( wp ), parameter :: triton_mass_energy_equivalent_in_MeV = 280 8.92113298_wp !> triton mass in u (u) real ( wp ), parameter :: triton_mass_in_u = 3.01550071621_wp !> triton molar mass (kg mol&#94;-1) real ( wp ), parameter :: triton_molar_mass = 3.01550071517e-3_wp !> triton-proton mass ratio (dimensionless) real ( wp ), parameter :: triton_proton_mass_ratio = 2.99371703414_wp !> triton relative atomic mass (dimensionless) real ( wp ), parameter :: triton_relative_atomic_mass = 3.01550071621_wp !> triton to proton mag. mom. ratio (dimensionless) real ( wp ), parameter :: triton_to_proton_mag__mom__ratio = 1.0666399191_wp !> unified atomic mass unit (kg) real ( wp ), parameter :: unified_atomic_mass_unit = 1.66053906660e-27_wp !> vacuum electric permittivity (F m&#94;-1) real ( wp ), parameter :: vacuum_electric_permittivity = 8.8541878128e-12_wp !> vacuum mag. permeability (N A&#94;-2) real ( wp ), parameter :: vacuum_mag__permeability = 1.25663706212e-6_wp !> von Klitzing constant (ohm) real ( wp ), parameter :: von_Klitzing_constant = 2581 2.80745_wp !> weak mixing angle (dimensionless) real ( wp ), parameter :: weak_mixing_angle = 0.22290_wp !> Wien frequency displacement law constant (Hz K&#94;-1) real ( wp ), parameter :: Wien_frequency_displacement_law_constant = 5.878925757e10_wp !> Wien wavelength displacement law constant (m K) real ( wp ), parameter :: Wien_wavelength_displacement_law_constant = 2.897771955e-3_wp !> W to Z mass ratio (dimensionless) real ( wp ), parameter :: W_to_Z_mass_ratio = 0.88153_wp end module mctc_io_codata2018","tags":"","loc":"sourcefile/codata2018.f90.html"},{"title":"qcschema.F90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. #include \"mctc/defs.h\" module mctc_io_read_qcschema use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error use mctc_io_structure , only : structure_type , new use mctc_io_symbols , only : to_number , symbol_length use mctc_io_utils , only : getline #if WITH_JSON use json_value_module , only : json_core , json_value #endif implicit none private public :: read_qcschema contains subroutine read_qcschema ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error #if WITH_JSON type ( json_core ) :: json type ( json_value ), pointer :: root , val , child , array integer :: stat , schema_version , charge , multiplicity , ibond character ( len = :), allocatable :: input , line , message , schema_name , comment character ( len = symbol_length ), allocatable :: sym (:) integer , allocatable :: bond (:, :), list (:) real ( wp ), allocatable , target :: geo (:) real ( wp ), pointer :: xyz (:, :) stat = 0 input = \"\" do call getline ( unit , line , stat ) if ( stat /= 0 ) exit input = input // line end do call json % deserialize ( root , input ) if ( json % failed ()) then call json % check_for_errors ( error_msg = message ) call fatal_error ( error , message ) call json % destroy ( root ) return end if val => root call json % get ( val , \"schema_version\" , schema_version , default = 2 ) call json % get ( val , \"schema_name\" , schema_name , default = \"qcschema_molecule\" ) if ( schema_name /= \"qcschema_molecule\" . and . schema_name /= \"qcschema_input\" & & . or . json % failed ()) then call fatal_error ( error , \"Invalid schema name '\" // schema_name // \"'\" ) call json % destroy ( root ) return end if if ( schema_name == \"qcschema_input\" ) then select case ( schema_version ) case ( 1 ) call json % get ( val , \"molecule\" , child ) case default call fatal_error ( error , \"Unsupported schema version for 'qcschema_input'\" ) call json % destroy ( root ) return end select call json % get ( child , \"schema_version\" , schema_version , default = 2 ) call json % get ( child , \"schema_name\" , schema_name , default = \"qcschema_molecule\" ) if ( schema_name /= \"qcschema_molecule\" . or . json % failed ()) then call fatal_error ( error , \"Invalid schema name '\" // schema_name // \"'\" ) call json % destroy ( root ) return end if val => child end if select case ( schema_version ) case ( 1 ) call json % get ( val , \"molecule\" , child ) case ( 2 ) child => val case default call fatal_error ( error , \"Unsupported schema version for 'qcschema_molecule'\" ) call json % destroy ( root ) return end select call json % get ( child , \"symbols\" , sym ) if (. not . allocated ( sym ) . or . json % failed ()) then call fatal_error ( error , \"List of atomic symbols must be provided\" ) call json % destroy ( root ) return end if call json % get ( child , \"geometry\" , geo ) if (. not . allocated ( geo ) . or . json % failed ()) then call fatal_error ( error , \"Cartesian coordinates must be provided\" ) call json % destroy ( root ) return end if if ( 3 * size ( sym ) /= size ( geo )) then call fatal_error ( error , \"Number of symbols and coordinate triples must match\" ) call json % destroy ( root ) return end if call json % get ( child , \"comment\" , comment , default = \"\" ) call json % get ( child , \"molecular_charge\" , charge , default = 0 ) call json % get ( child , \"molecular_multiplicity\" , multiplicity , default = 1 ) if ( json % failed ()) then call json % check_for_errors ( error_msg = message ) call fatal_error ( error , message ) call json % destroy ( root ) return end if call json % get_child ( child , \"connectivity\" , array ) if ( associated ( array )) then allocate ( bond ( 3 , json % count ( array ))) do ibond = 1 , size ( bond , 2 ) call json % get_child ( array , ibond , child ) call json % get ( child , \"\" , list ) if ( allocated ( list )) then bond (:, ibond ) = [ list ( 1 ) + 1 , list ( 2 ) + 1 , list ( 3 )] end if end do if ( json % failed ()) then call json % check_for_errors ( error_msg = message ) call fatal_error ( error , message ) call json % destroy ( root ) return end if end if xyz ( 1 : 3 , 1 : size ( geo ) / 3 ) => geo call new ( self , sym , xyz , charge = real ( charge , wp ), uhf = multiplicity - 1 ) if ( len ( comment ) > 0 ) self % comment = comment if ( allocated ( bond )) then self % nbd = size ( bond , 2 ) call move_alloc ( bond , self % bond ) end if call json % destroy ( root ) #else call fatal_error ( error , \"JSON support not enabled\" ) #endif end subroutine read_qcschema end module mctc_io_read_qcschema","tags":"","loc":"sourcefile/qcschema.f90.html"},{"title":"io.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Input and output module of the tool chain library. !> !> This module exports the basic [[structure_type]] as well as routines !> to read it from a file or formatted unit ([[read_structure]]) or write !> it to a formatted unit ([[write_structure]]). !> !> Both [[read_structure]] and [[write_structure]] take format hints from !> the filetype enumerator. File names can be translated to the respective !> enumerator by using the [[get_filetype]] function. This can be useful in !> case the caller routine wants to open the formatted unit itself or uses !> a non-standard file extension. module mctc_io use mctc_io_filetype , only : filetype , get_filetype use mctc_io_read , only : read_structure use mctc_io_structure , only : structure_type , new_structure , new use mctc_io_symbols , only : to_symbol , to_number use mctc_io_write , only : write_structure implicit none private public :: filetype , get_filetype public :: read_structure , write_structure public :: structure_type , new_structure , new public :: to_symbol , to_number contains end module mctc_io","tags":"","loc":"sourcefile/io.f90.html"},{"title":"structure.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Basic structure representation of the system of interest module mctc_io_structure use mctc_env_accuracy , only : wp use mctc_io_symbols , only : to_number , to_symbol , symbol_length , get_identity , & & collect_identical use mctc_io_structure_info , only : structure_info , pdb_data , sdf_data implicit none private public :: structure_type , new_structure , new !> Structure representation type :: structure_type !> Number of atoms integer :: nat = 0 !> Number of unique species integer :: nid = 0 !> Number of bonds integer :: nbd = 0 !> Species identifier integer , allocatable :: id (:) !> Atomic number for each species integer , allocatable :: num (:) !> Element symbol for each species character ( len = symbol_length ), allocatable :: sym (:) !> Cartesian coordinates, in Bohr real ( wp ), allocatable :: xyz (:, :) !> Number of unpaired electrons integer :: uhf = 0 !> Total charge real ( wp ) :: charge = 0.0_wp !> Lattice parameters real ( wp ), allocatable :: lattice (:, :) !> Periodic directions logical , allocatable :: periodic (:) !> Bond indices integer , allocatable :: bond (:, :) !> Comment, name or identifier for this structure character ( len = :), allocatable :: comment !> Vendor specific structure annotations type ( structure_info ) :: info = structure_info () !> SDF atomic data annotations type ( sdf_data ), allocatable :: sdf (:) !> PDB atomic data annotations type ( pdb_data ), allocatable :: pdb (:) end type structure_type interface new module procedure :: new_structure module procedure :: new_structure_num module procedure :: new_structure_sym end interface contains !> Constructor for structure representations subroutine new_structure ( self , num , sym , xyz , charge , uhf , lattice , periodic , & & info , bond ) !> Instance of the structure representation type ( structure_type ), intent ( out ) :: self !> Atomic numbers integer , intent ( in ) :: num (:) !> Element symbols character ( len =* ), intent ( in ) :: sym (:) !> Cartesian coordinates real ( wp ), intent ( in ) :: xyz (:, :) !> Total charge real ( wp ), intent ( in ), optional :: charge !> Number of unpaired electrons integer , intent ( in ), optional :: uhf !> Lattice parameters real ( wp ), intent ( in ), optional :: lattice (:, :) !> Periodic directions logical , intent ( in ), optional :: periodic (:) !> Vendor specific structure information type ( structure_info ), intent ( in ), optional :: info !> Bond topology of the system integer , intent ( in ), optional :: bond (:, :) integer :: ndim , iid integer , allocatable :: map (:) ndim = min ( size ( num , 1 ), size ( xyz , 2 ), size ( sym , 1 )) self % nat = ndim allocate ( self % id ( ndim )) allocate ( self % xyz ( 3 , ndim )) if ( present ( lattice )) then self % lattice = lattice else allocate ( self % lattice ( 0 , 0 )) end if if ( present ( periodic )) then self % periodic = periodic else if ( present ( lattice )) then allocate ( self % periodic ( 3 )) self % periodic (:) = . true . else allocate ( self % periodic ( 1 )) self % periodic (:) = . false . end if end if call get_identity ( self % nid , self % id , sym ) allocate ( map ( self % nid )) call collect_identical ( self % id , map ) allocate ( self % num ( self % nid )) allocate ( self % sym ( self % nid )) do iid = 1 , self % nid self % num ( iid ) = num ( map ( iid )) self % sym ( iid ) = sym ( map ( iid )) end do self % xyz (:, :) = xyz (:, : ndim ) if ( present ( charge )) then self % charge = charge else self % charge = 0.0_wp end if if ( present ( uhf )) then self % uhf = uhf else self % uhf = 0 end if if ( present ( info )) then self % info = info else self % info = structure_info () end if if ( present ( bond )) then self % nbd = size ( bond , 2 ) self % bond = bond end if end subroutine new_structure !> Simplified constructor for structure representations subroutine new_structure_num ( self , num , xyz , charge , uhf , lattice , periodic , & & info , bond ) !> Instance of the structure representation type ( structure_type ), intent ( out ) :: self !> Atomic numbers integer , intent ( in ) :: num (:) !> Cartesian coordinates real ( wp ), intent ( in ) :: xyz (:, :) !> Total charge real ( wp ), intent ( in ), optional :: charge !> Number of unpaired electrons integer , intent ( in ), optional :: uhf !> Lattice parameters real ( wp ), intent ( in ), optional :: lattice (:, :) !> Periodic directions logical , intent ( in ), optional :: periodic (:) !> Vendor specific structure information type ( structure_info ), intent ( in ), optional :: info !> Bond topology of the system integer , intent ( in ), optional :: bond (:, :) integer :: ndim , iat character ( len = symbol_length ), allocatable :: sym (:) ndim = min ( size ( num , 1 ), size ( xyz , 2 )) allocate ( sym ( ndim )) do iat = 1 , ndim sym ( iat ) = to_symbol ( num ( iat )) end do call new_structure ( self , num , sym , xyz , charge , uhf , lattice , periodic , & & info , bond ) end subroutine new_structure_num !> Simplified constructor for structure representations subroutine new_structure_sym ( self , sym , xyz , charge , uhf , lattice , periodic , & & info , bond ) !> Instance of the structure representation type ( structure_type ), intent ( out ) :: self !> Element symbols character ( len =* ), intent ( in ) :: sym (:) !> Cartesian coordinates real ( wp ), intent ( in ) :: xyz (:, :) !> Total charge real ( wp ), intent ( in ), optional :: charge !> Number of unpaired electrons integer , intent ( in ), optional :: uhf !> Lattice parameters real ( wp ), intent ( in ), optional :: lattice (:, :) !> Periodic directions logical , intent ( in ), optional :: periodic (:) !> Vendor specific structure information type ( structure_info ), intent ( in ), optional :: info !> Bond topology of the system integer , intent ( in ), optional :: bond (:, :) integer :: ndim , iat integer , allocatable :: num (:) ndim = min ( size ( sym , 1 ), size ( xyz , 2 )) allocate ( num ( ndim )) do iat = 1 , ndim num ( iat ) = to_number ( sym ( iat )) end do call new_structure ( self , num , sym , xyz , charge , uhf , lattice , periodic , & & info , bond ) end subroutine new_structure_sym end module mctc_io_structure","tags":"","loc":"sourcefile/structure.f90.html"},{"title":"vasp.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_vasp use mctc_env_accuracy , only : wp use mctc_io_convert , only : autoaa use mctc_io_math , only : matinv_3x3 use mctc_io_structure , only : structure_type implicit none private public :: write_vasp contains subroutine write_vasp ( self , unit , comment_line ) class ( structure_type ), intent ( in ) :: self integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: comment_line integer :: i , j , izp integer , allocatable :: kinds (:), species (:) real ( wp ), allocatable :: inv_lat (:, :) real ( wp ), allocatable :: abc (:, :) allocate ( species ( self % nat )) allocate ( kinds ( self % nat ), source = 1 ) j = 0 izp = 0 do i = 1 , self % nat if ( izp . eq . self % id ( i )) then kinds ( j ) = kinds ( j ) + 1 else j = j + 1 izp = self % id ( i ) species ( j ) = self % id ( i ) end if end do ! use vasp 5.x format if ( present ( comment_line )) then write ( unit , '(a)' ) comment_line else if ( allocated ( self % comment )) then write ( unit , '(a)' ) self % comment else write ( unit , '(a)' ) end if end if ! scaling factor for lattice parameters is always one write ( unit , '(f20.14)' ) self % info % scale ! write the lattice parameters if ( any ( self % periodic )) then if ( size ( self % lattice , 2 ) == 3 ) then write ( unit , '(3f20.14)' ) self % lattice else write ( unit , '(3f20.14)' ) spread ( 0.0_wp , 1 , 9 ) end if else write ( unit , '(3f20.14)' ) spread ( 0.0_wp , 1 , 9 ) end if do i = 1 , j write ( unit , '(1x, a)' , advance = 'no' ) self % sym ( species ( i )) end do write ( unit , '(a)' ) ! write the count of the consecutive atom types do i = 1 , j write ( unit , '(1x, i0)' , advance = 'no' ) kinds ( i ) end do write ( unit , '(a)' ) deallocate ( kinds , species ) if ( self % info % selective ) write ( unit , '(\"Selective\")' ) ! we write cartesian coordinates if ( any ( shape ( self % lattice ) /= [ 3 , 3 ]) . or . self % info % cartesian ) then write ( unit , '(\"Cartesian\")' ) ! now write the cartesian coordinates do i = 1 , self % nat write ( unit , '(3f20.14)' ) self % xyz (:, i ) * autoaa / self % info % scale end do else write ( unit , '(\"Direct\")' ) inv_lat = matinv_3x3 ( self % lattice ) abc = matmul ( inv_lat , self % xyz ) ! now write the fractional coordinates do i = 1 , self % nat write ( unit , '(3f20.14)' ) abc (:, i ) end do end if end subroutine write_vasp end module mctc_io_write_vasp","tags":"","loc":"sourcefile/vasp.f90.html"},{"title":"aims.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_aims use mctc_env_accuracy , only : wp use mctc_io_convert , only : autoaa use mctc_io_structure , only : structure_type implicit none private public :: write_aims contains subroutine write_aims ( self , unit ) !> Instance of the molecular structure data class ( structure_type ), intent ( in ) :: self !> File handle integer , intent ( in ) :: unit integer :: iat , ilt logical :: expo expo = maxval ( self % xyz ) > 1.0e+5 . or . minval ( self % xyz ) < - 1.0e+5 if ( expo ) then do iat = 1 , self % nat write ( unit , '(a, 1x, 3es24.14, 1x, a)' ) & \"atom\" , self % xyz (:, iat ) * autoaa , trim ( self % sym ( self % id ( iat ))) end do else do iat = 1 , self % nat write ( unit , '(a, 1x, 3f24.14, 1x, a)' ) & \"atom\" , self % xyz (:, iat ) * autoaa , trim ( self % sym ( self % id ( iat ))) end do end if if ( any ( self % periodic )) then if ( size ( self % lattice , 2 ) /= 3 ) return do ilt = 1 , 3 if ( self % periodic ( ilt )) then write ( unit , '(a, 1x, 3f24.14)' ) & \"lattice_vector\" , self % lattice (:, ilt ) * autoaa end if end do end if end subroutine write_aims end module mctc_io_write_aims","tags":"","loc":"sourcefile/aims.f90.html"},{"title":"env.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Public API reexport of environment library module mctc_env use mctc_env_accuracy , only : sp , dp , wp , i1 , i2 , i4 , i8 use mctc_env_error , only : error_type , fatal_error , mctc_stat use mctc_env_system , only : get_argument , get_variable , & & is_unix , is_windows implicit none public end module mctc_env","tags":"","loc":"sourcefile/env.f90.html"},{"title":"turbomole.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_turbomole use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type use mctc_io_constants , only : pi use mctc_io_convert , only : aatoau use mctc_io_resize , only : resize use mctc_io_structure , only : structure_type , new use mctc_io_structure_info , only : structure_info use mctc_io_symbols , only : to_number , symbol_length use mctc_io_utils , only : next_line , token_type , next_token , io_error , io2_error , & filename , read_next_token , to_string implicit none private public :: read_coord logical , parameter :: debug = . false . contains subroutine read_coord ( mol , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: mol !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character , parameter :: flag = '$' integer , parameter :: p_initial_size = 100 integer , parameter :: p_nlv ( 3 ) = [ 1 , 4 , 9 ], p_ncp ( 3 ) = [ 1 , 3 , 6 ] logical :: has_coord , has_periodic , has_lattice , has_cell , has_eht logical :: cartesian , coord_in_bohr , lattice_in_bohr , pbc ( 3 ) integer :: stat , iatom , i , j , natoms , periodic , cell_vectors , icharge , unpaired integer :: lnum , pos , lcell , llattice , lperiodic , lcoord , leht type ( token_type ) :: token , token2 real ( wp ) :: latvec ( 9 ), conv , cellpar ( 6 ), lattice ( 3 , 3 ) real ( wp ), allocatable :: coord (:, :), xyz (:, :), charge character ( len = :), allocatable :: line , cell_string , lattice_string , & & line_cell , line_lattice , line_periodic , line_coord , line_eht character ( len = symbol_length ), allocatable :: sym (:) type ( structure_info ) :: info allocate ( sym ( p_initial_size ), source = repeat ( ' ' , symbol_length )) allocate ( coord ( 3 , p_initial_size ), source = 0.0_wp ) lnum = 0 iatom = 0 periodic = 0 cell_vectors = 0 has_eht = . false . has_coord = . false . has_periodic = . false . has_lattice = . false . has_cell = . false . cartesian = . true . coord_in_bohr = . true . lattice_in_bohr = . true . lattice (:, :) = 0.0_wp pbc (:) = . false . charge = 0.0_wp unpaired = 0 stat = 0 call next_line ( unit , line , pos , lnum , stat ) do while ( stat == 0 ) if ( index ( line , flag ) == 1 ) then call next_token ( line , pos , token ) select case ( line ( token % first : token % last )) case ( '$end' ) exit case ( '$eht' ) if ( has_eht ) then pos = 0 call next_token ( line_eht , pos , token2 ) call io2_error ( error , \"Duplicated eht data group\" , & & line_eht , line , token2 , token , & & filename ( unit ), leht , lnum , & & \"charge/multiplicity first defined here\" , \"duplicated eht data\" ) return end if has_eht = . true . leht = lnum line_eht = line i = index ( line , 'charge=' ) if ( i > 0 ) then pos = i + 6 call read_next_token ( line , pos , token , icharge , stat ) charge = real ( icharge , wp ) end if j = index ( line , 'unpaired=' ) if ( j > 0 . and . stat == 0 ) then pos = j + 8 call read_next_token ( line , pos , token , unpaired , stat ) end if if ( stat /= 0 ) then call io_error ( error , \"Cannot read eht entry\" , & & line , token , filename ( unit ), lnum , \"expected integer value\" ) return end if case ( '$coord' ) if ( has_coord ) then pos = 0 call next_token ( line_coord , pos , token2 ) call io2_error ( error , \"Duplicated coord data group\" , & & line_coord , line , token2 , token , & & filename ( unit ), lcoord , lnum , & & \"coordinates first defined here\" , \"duplicated coordinate group\" ) return end if lcoord = lnum line_coord = line has_coord = . true . ! $coord angs / $coord bohr / $coord frac call select_unit ( line , coord_in_bohr , cartesian ) coord_group : do while ( stat == 0 ) call next_line ( unit , line , pos , lnum , stat ) if ( index ( line , flag ) == 1 ) exit coord_group if ( iatom >= size ( coord , 2 )) call resize ( coord ) if ( iatom >= size ( sym )) call resize ( sym ) iatom = iatom + 1 call read_next_token ( line , pos , token , coord ( 1 , iatom ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 2 , iatom ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 3 , iatom ), stat ) if ( stat == 0 ) & call next_token ( line , pos , token ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read coordinates\" , & & line , token , filename ( unit ), lnum , \"expected real value\" ) return end if token % last = min ( token % last , token % first + symbol_length - 1 ) sym ( iatom ) = line ( token % first : token % last ) if ( to_number ( sym ( iatom )) == 0 ) then call io_error ( error , \"Cannot map symbol to atomic number\" , & & line , token , filename ( unit ), lnum , \"unknown element\" ) return end if end do coord_group cycle case ( '$periodic' ) if ( has_periodic ) then pos = 0 call next_token ( line_periodic , pos , token2 ) call io2_error ( error , \"Duplicated periodic data group\" , & & line_periodic , line , token2 , token , & & filename ( unit ), lperiodic , lnum , & & \"periodicity first defined here\" , \"duplicated periodicity data\" ) return end if lperiodic = lnum line_periodic = line has_periodic = . true . ! $periodic 0/1/2/3 call read_next_token ( line , pos , token , periodic , stat ) if ( stat /= 0 . or . periodic < 0 . or . periodic > 3 ) then call io_error ( error , \"Cannot read periodicity of system\" , & & line , token , filename ( unit ), lnum , \"expected integer (0 to 3)\" ) return end if case ( '$lattice' ) if ( has_lattice ) then pos = 0 call next_token ( line_lattice , pos , token2 ) call io2_error ( error , \"Duplicated lattice data group\" , & & line_lattice , line , token2 , token , & & filename ( unit ), llattice , lnum , & & \"lattice parameters first defined here\" , \"duplicated lattice group\" ) return end if llattice = lnum line_lattice = line has_lattice = . true . ! $lattice bohr / $lattice angs call select_unit ( line , lattice_in_bohr ) cell_vectors = 0 lattice_string = '' lattice_group : do while ( stat == 0 ) call next_line ( unit , line , pos , lnum , stat ) if ( index ( line , flag ) == 1 ) exit lattice_group cell_vectors = cell_vectors + 1 lattice_string = lattice_string // ' ' // line end do lattice_group cycle case ( '$cell' ) if ( has_cell ) then pos = 0 call next_token ( line_cell , pos , token2 ) call io2_error ( error , \"Duplicated cell data group\" , & & line_cell , line , token2 , token , & & filename ( unit ), lcell , lnum , & & \"cell parameters first defined here\" , \"duplicated cell group\" ) return end if lcell = lnum line_cell = line has_cell = . true . ! $cell bohr / $cell angs call select_unit ( line , lattice_in_bohr ) call next_line ( unit , cell_string , pos , lnum , stat ) if ( debug ) print * , cell_string end select end if token = token_type ( 0 , 0 ) call next_line ( unit , line , pos , lnum , stat ) end do if ( allocated ( error )) return if (. not . has_coord . or . iatom == 0 ) then call io_error ( error , \"coordinates not present, cannot work without coordinates\" , & & line , token , filename ( unit ), lnum , \"unexpected end of input\" ) return end if if ( has_cell . and . has_lattice ) then block type ( token_type ) :: tcell , tlattice pos = 0 call next_token ( line_cell , pos , tcell ) pos = 0 call next_token ( line_lattice , pos , tlattice ) tlattice = token_type ( 1 , len ( line_lattice )) if ( lcell > llattice ) then call io2_error ( error , \"Conflicting lattice and cell groups\" , & & line_lattice , line_cell , tlattice , tcell , & & filename ( unit ), llattice , lcell , & & \"lattice first defined here\" , \"conflicting cell group\" ) else call io2_error ( error , \"Conflicting lattice and cell groups\" , & & line_cell , line_lattice , tcell , tlattice , & & filename ( unit ), lcell , llattice , & & \"cell first defined here\" , \"conflicting lattice group\" ) end if end block return end if if (. not . has_periodic . and . ( has_cell . or . has_lattice )) then pos = 0 if ( has_cell ) then call next_token ( line_cell , pos , token ) call io_error ( error , \"Cell parameters defined without periodicity\" , & & line_cell , token , filename ( unit ), & & lcell , \"cell defined here\" ) end if if ( has_lattice ) then call next_token ( line_lattice , pos , token ) call io_error ( error , \"Lattice parameters defined without periodicity\" , & & line_lattice , token , filename ( unit ), & & llattice , \"lattice defined here\" ) end if return end if if ( periodic > 0 . and . . not .( has_cell . or . has_lattice )) then pos = 0 call next_token ( line_periodic , pos , token ) call io_error ( error , \"Missing lattice or cell data\" , & & line_periodic , token , filename ( unit ), & & lperiodic , \"periodic system defined here\" ) return end if if (. not . cartesian . and . periodic == 0 ) then pos = 0 call next_token ( line_coord , pos , token ) call next_token ( line_coord , pos , token ) call io_error ( error , \"Molecular systems cannot have fractional coordinates\" , & & line_coord , token , filename ( unit ), & & lcoord , \"fractional modifier found\" ) return end if natoms = iatom allocate ( xyz ( 3 , natoms )) if ( periodic > 0 ) pbc (: periodic ) = . true . if ( has_cell ) then read ( cell_string , * , iostat = stat ) latvec (: p_ncp ( periodic )) if ( debug ) print * , latvec (: p_ncp ( periodic )) if ( lattice_in_bohr ) then conv = 1.0_wp else conv = aatoau end if select case ( periodic ) case ( 1 ) cellpar = [ latvec ( 1 ) * conv , 1.0_wp , 1.0_wp , & & pi / 2 , pi / 2 , pi / 2 ] case ( 2 ) cellpar = [ latvec ( 1 ) * conv , latvec ( 2 ) * conv , 1.0_wp , & & pi / 2 , pi / 2 , latvec ( 3 ) * pi / 18 0.0_wp ] case ( 3 ) cellpar = [ latvec ( 1 : 3 ) * conv , latvec ( 4 : 6 ) * pi / 18 0.0_wp ] end select call cell_to_dlat ( cellpar , lattice ) end if if ( has_lattice ) then if ( cell_vectors /= periodic ) then pos = 0 call next_token ( line_lattice , pos , token ) pos = len_trim ( line_periodic ) call io2_error ( error , \"Number of lattice vectors does not match periodicity\" , & & line_lattice , line_periodic , token , token_type ( pos , pos ), & & filename ( unit ), llattice , lperiodic , & & \"lattice vectors defined here\" , \"conflicting periodicity\" ) return end if read ( lattice_string , * , iostat = stat ) latvec (: p_nlv ( periodic )) if ( lattice_in_bohr ) then conv = 1.0_wp else conv = aatoau end if j = 0 do i = 1 , periodic lattice (: periodic , i ) = latvec ( j + 1 : j + periodic ) * conv j = j + periodic end do end if if ( cartesian ) then if ( coord_in_bohr ) then conv = 1.0_wp else conv = aatoau end if xyz (:, :) = coord (:, : natoms ) * conv else ! Non-periodic coordinates are in Bohr xyz ( periodic + 1 : 3 , :) = coord ( periodic + 1 : 3 , : natoms ) ! Periodic coordinates must still be transformed with lattice xyz (: periodic , :) = matmul ( lattice (: periodic , : periodic ), coord (: periodic , : natoms )) end if ! save data on input format info = structure_info ( cartesian = cartesian , lattice = has_lattice , & & angs_lattice = . not . lattice_in_bohr , angs_coord = . not . coord_in_bohr ) call new ( mol , sym (: natoms ), xyz , charge = charge , uhf = unpaired , & & lattice = lattice , periodic = pbc , info = info ) contains subroutine select_unit ( line , in_bohr , cartesian ) character ( len =* ), intent ( in ) :: line logical , intent ( out ) :: in_bohr logical , intent ( out ), optional :: cartesian in_bohr = index ( line , ' angs' ) == 0 if ( present ( cartesian )) cartesian = index ( line , ' frac' ) == 0 end subroutine select_unit end subroutine read_coord !> Calculate the lattice vectors from a set of cell parameters pure subroutine cell_to_dlat ( cellpar , lattice ) !> Cell parameters real ( wp ), intent ( in ) :: cellpar ( 6 ) !> Direct lattice real ( wp ), intent ( out ) :: lattice (:, :) real ( wp ) :: dvol dvol = cell_to_dvol ( cellpar ) associate ( alen => cellpar ( 1 ), blen => cellpar ( 2 ), clen => cellpar ( 3 ), & & alp => cellpar ( 4 ), bet => cellpar ( 5 ), gam => cellpar ( 6 )) lattice ( 1 , 1 ) = alen lattice ( 2 , 1 ) = 0.0_wp lattice ( 3 , 1 ) = 0.0_wp lattice ( 3 , 2 ) = 0.0_wp lattice ( 1 , 2 ) = blen * cos ( gam ) lattice ( 2 , 2 ) = blen * sin ( gam ) lattice ( 1 , 3 ) = clen * cos ( bet ) lattice ( 2 , 3 ) = clen * ( cos ( alp ) - cos ( bet ) * cos ( gam )) / sin ( gam ); lattice ( 3 , 3 ) = dvol / ( alen * blen * sin ( gam )) end associate end subroutine cell_to_dlat !> Calculate the cell volume from a set of cell parameters pure function cell_to_dvol ( cellpar ) result ( dvol ) !> Cell parameters real ( wp ), intent ( in ) :: cellpar ( 6 ) !> Cell volume real ( wp ) :: dvol real ( wp ) :: vol2 associate ( alen => cellpar ( 1 ), blen => cellpar ( 2 ), clen => cellpar ( 3 ), & & alp => cellpar ( 4 ), bet => cellpar ( 5 ), gam => cellpar ( 6 ) ) vol2 = 1.0_wp - cos ( alp ) ** 2 - cos ( bet ) ** 2 - cos ( gam ) ** 2 & & + 2.0_wp * cos ( alp ) * cos ( bet ) * cos ( gam ) dvol = sqrt ( abs ( vol2 )) * alen * blen * clen ! return negative volume instead of imaginary one (means bad cell parameters) if ( vol2 < 0.0_wp ) dvol = - dvol ! this should not happen, but who knows... end associate end function cell_to_dvol end module mctc_io_read_turbomole","tags":"","loc":"sourcefile/turbomole.f90.html"},{"title":"version.F90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. #include \"mctc/defs.h\" module mctc_version implicit none private public :: mctc_version_string , mctc_version_compact public :: get_mctc_version , get_mctc_feature !> String representation of the mctc-lib version character ( len =* ), parameter :: mctc_version_string = \"0.3.2\" !> Numeric representation of the mctc-lib version integer , parameter :: mctc_version_compact ( 3 ) = [ 0 , 3 , 2 ] !> With support for JSON logical , parameter :: mctc_with_json = 0 /= WITH_JSON contains !> Getter function to retrieve mctc-lib version pure subroutine get_mctc_version ( major , minor , patch , string ) !> Major version number of the mctc-lib version integer , intent ( out ), optional :: major !> Minor version number of the mctc-lib version integer , intent ( out ), optional :: minor !> Patch version number of the mctc-lib version integer , intent ( out ), optional :: patch !> String representation of the mctc-lib version character ( len = :), allocatable , intent ( out ), optional :: string if ( present ( major )) then major = mctc_version_compact ( 1 ) end if if ( present ( minor )) then minor = mctc_version_compact ( 2 ) end if if ( present ( patch )) then patch = mctc_version_compact ( 3 ) end if if ( present ( string )) then string = mctc_version_string end if end subroutine get_mctc_version pure function get_mctc_feature ( feature ) result ( has_feature ) !> Feature name character ( len =* ), intent ( in ) :: feature !> Whether the feature is enabled logical :: has_feature select case ( feature ) case ( \"json\" ) has_feature = mctc_with_json case default has_feature = . false . end select end function get_mctc_feature end module mctc_version","tags":"","loc":"sourcefile/version.f90.html"},{"title":"cjson.F90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. #include \"mctc/defs.h\" module mctc_io_read_cjson use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error use mctc_io_constants , only : pi use mctc_io_convert , only : aatoau use mctc_io_structure , only : structure_type , new use mctc_io_symbols , only : to_number , symbol_length use mctc_io_utils , only : getline #if WITH_JSON use json_value_module , only : json_core , json_value #endif implicit none private public :: read_cjson contains subroutine read_cjson ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error #if WITH_JSON type ( json_core ) :: json type ( json_value ), pointer :: root , val , child , array logical :: cartesian , found integer :: stat , schema_version , charge , multiplicity , ibond character ( len = :), allocatable :: input , line , message , comment integer , allocatable :: num (:), bond (:, :), list (:), order (:) real ( wp ) :: cellpar ( 6 ) real ( wp ), allocatable :: lattice (:, :) real ( wp ), allocatable , target :: geo (:) real ( wp ), pointer :: xyz (:, :) stat = 0 input = \"\" do call getline ( unit , line , stat ) if ( stat /= 0 ) exit input = input // line end do call json % deserialize ( root , input ) if ( json % failed ()) then call json % check_for_errors ( error_msg = message ) call fatal_error ( error , message ) call json % destroy ( root ) return end if val => root call cjson_get ( json , val , \"chemicalJson\" , \"chemical json\" , child ) if (. not . associated ( child )) then call fatal_error ( error , \"No 'chemical json' key found\" ) call json % destroy ( root ) return end if call json % get ( child , schema_version ) ! There seems to be no actual difference between version 0 and 1, though if ( all ( schema_version /= [ 0 , 1 ])) then call fatal_error ( error , \"Unsupported schema version for 'chemical json'\" ) call json % destroy ( root ) return end if call json % get ( val , \"atoms.elements.number\" , num ) if (. not . allocated ( num ) . or . json % failed ()) then call fatal_error ( error , \"List of atomic symbols must be provided\" ) call json % destroy ( root ) return end if call cjson_get ( json , val , \"unitCell\" , \"unit cell\" , child ) if ( associated ( child )) then call json % get ( child , \"a\" , cellpar ( 1 )) call json % get ( child , \"b\" , cellpar ( 2 )) call json % get ( child , \"c\" , cellpar ( 3 )) call json % get ( child , \"alpha\" , cellpar ( 4 )) call json % get ( child , \"beta\" , cellpar ( 5 )) call json % get ( child , \"gamma\" , cellpar ( 6 )) if ( json % failed ()) then call json % check_for_errors ( error_msg = message ) call fatal_error ( error , message ) call json % destroy ( root ) return end if cellpar ( 1 : 3 ) = cellpar ( 1 : 3 ) * aatoau cellpar ( 4 : 6 ) = cellpar ( 4 : 6 ) * ( pi / 180 ) allocate ( lattice ( 3 , 3 )) call cell_to_dlat ( cellpar , lattice ) end if call json % get ( val , \"atoms.coords.3d\" , geo , found = cartesian ) if (. not . cartesian . and . allocated ( lattice )) then call cjson_get ( json , val , \"atoms.coords.3dFractional\" , \"atoms.coords.3d fractional\" , & & child ) if ( associated ( child )) call json % get ( child , geo ) end if if (. not . allocated ( geo ) . or . json % failed ()) then call fatal_error ( error , \"Cartesian coordinates must be provided\" ) call json % destroy ( root ) return end if if ( 3 * size ( num ) /= size ( geo )) then call fatal_error ( error , \"Number of atomic numbers and coordinate triples must match\" ) call json % destroy ( root ) return end if call json % get ( val , \"bonds.connections.index\" , list , found = found ) call json % get ( val , \"bonds.order\" , order , found = found ) if (. not . allocated ( order ) . and . allocated ( list )) & allocate ( order ( size ( list ) / 2 ), source = 1 ) if ( json % failed ()) then call fatal_error ( error , \"Cannot read entries from 'bonds'\" ) call json % destroy ( root ) return end if if ( allocated ( list )) then allocate ( bond ( 3 , size ( list ) / 2 )) do ibond = 1 , size ( bond , 2 ) bond (:, ibond ) = [ list ( 2 * ibond - 1 ) + 1 , list ( 2 * ibond ) + 1 , order ( ibond )] end do end if call json % get ( val , \"name\" , comment , default = \"\" ) call json % get ( val , \"properties.totalCharge\" , charge , found = found ) if (. not . found ) then call json % get ( val , \"atoms.formalCharges\" , list , found = found ) charge = 0 if ( allocated ( list )) charge = sum ( list ) end if call json % get ( val , \"properties.totalSpinMultiplicity\" , multiplicity , found = found ) if (. not . found ) multiplicity = 1 if ( json % failed ()) then call json % check_for_errors ( error_msg = message ) call fatal_error ( error , message ) call json % destroy ( root ) return end if xyz ( 1 : 3 , 1 : size ( geo ) / 3 ) => geo xyz (:, :) = xyz * aatoau if (. not . cartesian ) then xyz (:, :) = matmul ( lattice , xyz (:, :)) end if call new ( self , num , xyz , lattice = lattice , charge = real ( charge , wp ), uhf = multiplicity - 1 ) if ( len ( comment ) > 0 ) self % comment = comment if ( allocated ( bond )) then self % nbd = size ( bond , 2 ) call move_alloc ( bond , self % bond ) end if call json % destroy ( root ) contains subroutine cjson_get ( json , val , key1 , key2 , child ) type ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: val type ( json_value ), pointer , intent ( out ) :: child character ( * ), intent ( in ) :: key1 , key2 logical :: found call json % get ( val , key1 , child , found = found ) if (. not . found ) then call json % get ( val , key2 , child , found = found ) end if end subroutine cjson_get #else call fatal_error ( error , \"JSON support not enabled\" ) #endif end subroutine read_cjson !> Calculate the lattice vectors from a set of cell parameters pure subroutine cell_to_dlat ( cellpar , lattice ) !> Cell parameters real ( wp ), intent ( in ) :: cellpar ( 6 ) !> Direct lattice real ( wp ), intent ( out ) :: lattice (:, :) real ( wp ) :: dvol dvol = cell_to_dvol ( cellpar ) associate ( alen => cellpar ( 1 ), blen => cellpar ( 2 ), clen => cellpar ( 3 ), & & alp => cellpar ( 4 ), bet => cellpar ( 5 ), gam => cellpar ( 6 )) lattice ( 1 , 1 ) = alen lattice ( 2 , 1 ) = 0.0_wp lattice ( 3 , 1 ) = 0.0_wp lattice ( 3 , 2 ) = 0.0_wp lattice ( 1 , 2 ) = blen * cos ( gam ) lattice ( 2 , 2 ) = blen * sin ( gam ) lattice ( 1 , 3 ) = clen * cos ( bet ) lattice ( 2 , 3 ) = clen * ( cos ( alp ) - cos ( bet ) * cos ( gam )) / sin ( gam ); lattice ( 3 , 3 ) = dvol / ( alen * blen * sin ( gam )) end associate end subroutine cell_to_dlat !> Calculate the cell volume from a set of cell parameters pure function cell_to_dvol ( cellpar ) result ( dvol ) !> Cell parameters real ( wp ), intent ( in ) :: cellpar ( 6 ) !> Cell volume real ( wp ) :: dvol real ( wp ) :: vol2 associate ( alen => cellpar ( 1 ), blen => cellpar ( 2 ), clen => cellpar ( 3 ), & & alp => cellpar ( 4 ), bet => cellpar ( 5 ), gam => cellpar ( 6 ) ) vol2 = 1.0_wp - cos ( alp ) ** 2 - cos ( bet ) ** 2 - cos ( gam ) ** 2 & & + 2.0_wp * cos ( alp ) * cos ( bet ) * cos ( gam ) dvol = sqrt ( abs ( vol2 )) * alen * blen * clen ! return negative volume instead of imaginary one (means bad cell parameters) if ( vol2 < 0.0_wp ) dvol = - dvol ! this should not happen, but who knows... end associate end function cell_to_dvol end module mctc_io_read_cjson","tags":"","loc":"sourcefile/cjson.f90.html"},{"title":"symbols.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Handle conversion between element symbols and atomic numbers module mctc_io_symbols use mctc_io_resize , only : resize implicit none private public :: symbol_length public :: symbol_to_number , number_to_symbol , number_to_lcsymbol public :: to_number , to_symbol , to_lcsymbol public :: get_identity , collect_identical !> Get chemical identity interface get_identity module procedure :: get_identity_number module procedure :: get_identity_symbol end interface get_identity !> Maximum allowed length of element symbols integer , parameter :: symbol_length = 4 !> Periodic system of elements character ( len = 2 ), parameter :: pse ( 118 ) = [ & & 'H ' , 'He' , & & 'Li' , 'Be' , 'B ' , 'C ' , 'N ' , 'O ' , 'F ' , 'Ne' , & & 'Na' , 'Mg' , 'Al' , 'Si' , 'P ' , 'S ' , 'Cl' , 'Ar' , & & 'K ' , 'Ca' , & & 'Sc' , 'Ti' , 'V ' , 'Cr' , 'Mn' , 'Fe' , 'Co' , 'Ni' , 'Cu' , 'Zn' , & & 'Ga' , 'Ge' , 'As' , 'Se' , 'Br' , 'Kr' , & & 'Rb' , 'Sr' , & & 'Y ' , 'Zr' , 'Nb' , 'Mo' , 'Tc' , 'Ru' , 'Rh' , 'Pd' , 'Ag' , 'Cd' , & & 'In' , 'Sn' , 'Sb' , 'Te' , 'I ' , 'Xe' , & & 'Cs' , 'Ba' , & & 'La' , 'Ce' , 'Pr' , 'Nd' , 'Pm' , 'Sm' , 'Eu' , 'Gd' , 'Tb' , 'Dy' , 'Ho' , 'Er' , 'Tm' , 'Yb' , & & 'Lu' , 'Hf' , 'Ta' , 'W ' , 'Re' , 'Os' , 'Ir' , 'Pt' , 'Au' , 'Hg' , & & 'Tl' , 'Pb' , 'Bi' , 'Po' , 'At' , 'Rn' , & & 'Fr' , 'Ra' , & & 'Ac' , 'Th' , 'Pa' , 'U ' , 'Np' , 'Pu' , 'Am' , 'Cm' , 'Bk' , 'Cf' , 'Es' , 'Fm' , 'Md' , 'No' , & & 'Lr' , 'Rf' , 'Db' , 'Sg' , 'Bh' , 'Hs' , 'Mt' , 'Ds' , 'Rg' , 'Cn' , & & 'Nh' , 'Fl' , 'Mc' , 'Lv' , 'Ts' , 'Og' ] !> Lower case version of the periodic system of elements character ( len = 2 ), parameter :: lcpse ( 118 ) = [ & & 'h ' , 'he' , & & 'li' , 'be' , 'b ' , 'c ' , 'n ' , 'o ' , 'f ' , 'ne' , & & 'na' , 'mg' , 'al' , 'si' , 'p ' , 's ' , 'cl' , 'ar' , & & 'k ' , 'ca' , & & 'sc' , 'ti' , 'v ' , 'cr' , 'mn' , 'fe' , 'co' , 'ni' , 'cu' , 'zn' , & & 'ga' , 'ge' , 'as' , 'se' , 'br' , 'kr' , & & 'rb' , 'sr' , & & 'y ' , 'zr' , 'nb' , 'mo' , 'tc' , 'ru' , 'rh' , 'pd' , 'ag' , 'cd' , & & 'in' , 'sn' , 'sb' , 'te' , 'i ' , 'xe' , & & 'cs' , 'ba' , 'la' , & & 'ce' , 'pr' , 'nd' , 'pm' , 'sm' , 'eu' , 'gd' , 'tb' , 'dy' , 'ho' , 'er' , 'tm' , 'yb' , & & 'lu' , 'hf' , 'ta' , 'w ' , 're' , 'os' , 'ir' , 'pt' , 'au' , 'hg' , & & 'tl' , 'pb' , 'bi' , 'po' , 'at' , 'rn' , & & 'fr' , 'ra' , 'ac' , & & 'th' , 'pa' , 'u ' , 'np' , 'pu' , 'am' , 'cm' , 'bk' , 'cf' , 'es' , 'fm' , 'md' , 'no' , & & 'lr' , 'rf' , 'db' , 'sg' , 'bh' , 'hs' , 'mt' , 'ds' , 'rg' , 'cn' , & & 'nh' , 'fl' , 'mc' , 'lv' , 'ts' , 'og' ] !> ASCII offset between lowercase and uppercase letters integer , parameter :: offset = iachar ( 'a' ) - iachar ( 'A' ) contains !> Convert element symbol to atomic number elemental subroutine symbol_to_number ( number , symbol ) !> Element symbol character ( len =* ), intent ( in ) :: symbol !> Atomic number integer , intent ( out ) :: number character ( len = 2 ) :: lcsymbol integer :: i , j , k , l number = 0 lcsymbol = '  ' k = 0 do j = 1 , len_trim ( symbol ) if ( k > 2 ) exit l = iachar ( symbol ( j : j )) if ( k >= 1 . and . l == iachar ( ' ' )) exit if ( k >= 1 . and . l == 9 ) exit if ( l >= iachar ( 'A' ) . and . l <= iachar ( 'Z' )) l = l + offset if ( l >= iachar ( 'a' ) . and . l <= iachar ( 'z' )) then k = k + 1 if ( k > 2 ) exit lcsymbol ( k : k ) = achar ( l ) endif enddo do i = 1 , size ( lcpse ) if ( lcsymbol == lcpse ( i )) then number = i exit endif enddo if ( number == 0 ) then select case ( lcsymbol ) case ( 'd ' , 't ' ) number = 1 end select end if end subroutine symbol_to_number !> Convert atomic number to element symbol elemental subroutine number_to_symbol ( symbol , number ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ), intent ( out ) :: symbol if ( number <= 0 . or . number > size ( pse )) then symbol = '--' else symbol = pse ( number ) endif end subroutine number_to_symbol !> Convert atomic number to element symbol elemental subroutine number_to_lcsymbol ( symbol , number ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ), intent ( out ) :: symbol if ( number <= 0 . or . number > size ( lcpse )) then symbol = '--' else symbol = lcpse ( number ) endif end subroutine number_to_lcsymbol !> Convert element symbol to atomic number elemental function to_number ( symbol ) result ( number ) !> Element symbol character ( len =* ), intent ( in ) :: symbol !> Atomic number integer :: number call symbol_to_number ( number , symbol ) end function to_number !> Convert atomic number to element symbol elemental function to_symbol ( number ) result ( symbol ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ) :: symbol call number_to_symbol ( symbol , number ) end function to_symbol !> Convert atomic number to element symbol elemental function to_lcsymbol ( number ) result ( symbol ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ) :: symbol call number_to_lcsymbol ( symbol , number ) end function to_lcsymbol !> Get chemical identity from a list of atomic numbers pure subroutine get_identity_number ( nid , identity , number ) !> Number of unique species integer , intent ( out ) :: nid !> Ordinal numbers integer , intent ( in ) :: number (:) !> Chemical identity integer , intent ( out ) :: identity (:) integer , allocatable :: itmp (:) integer :: nat , iat , iid nat = size ( identity ) allocate ( itmp ( nat )) nid = 0 do iat = 1 , nat iid = find_number ( itmp (: nid ), number ( iat )) if ( iid == 0 ) then call append_number ( itmp , nid , number ( iat )) iid = nid end if identity ( iat ) = iid end do end subroutine get_identity_number !> Get chemical identity from a list of element symbols pure subroutine get_identity_symbol ( nid , identity , symbol ) !> Number of unique species integer , intent ( out ) :: nid !> Element symbols character ( len =* ), intent ( in ) :: symbol (:) !> Chemical identity integer , intent ( out ) :: identity (:) character ( len = len ( symbol )), allocatable :: stmp (:) integer :: nat , iat , iid nat = size ( identity ) allocate ( stmp ( nat )) nid = 0 do iat = 1 , nat iid = find_symbol ( stmp (: nid ), symbol ( iat )) if ( iid == 0 ) then call append_symbol ( stmp , nid , symbol ( iat )) iid = nid end if identity ( iat ) = iid end do end subroutine get_identity_symbol !> Establish a mapping between unique atom types and species pure subroutine collect_identical ( identity , mapping ) !> Chemical identity integer , intent ( in ) :: identity (:) !> Mapping from unique atoms integer , intent ( out ) :: mapping (:) integer :: iid , iat do iid = 1 , size ( mapping ) do iat = 1 , size ( identity ) if ( identity ( iat ) == iid ) then mapping ( iid ) = iat exit end if end do end do end subroutine collect_identical !> Find element symbol in an unordered list, all entries are required to be unique pure function find_symbol ( list , symbol ) result ( position ) !> List of element symbols character ( len =* ), intent ( in ) :: list (:) !> Element symbol character ( len =* ), intent ( in ) :: symbol !> Position of the symbol in list if found, otherwise zero integer :: position integer :: isym position = 0 do isym = 1 , size ( list ) if ( symbol == list ( isym )) then position = isym exit end if end do end function find_symbol !> Find atomic number in an unordered list, all entries are required to be unique pure function find_number ( list , number ) result ( position ) !> List of atomic numbers integer , intent ( in ) :: list (:) !> Atomic number integer , intent ( in ) :: number !> Position of the number in list if found, otherwise zero integer :: position integer :: inum position = 0 do inum = 1 , size ( list ) if ( number == list ( inum )) then position = inum exit end if end do end function find_number !> Append an element symbol to an unsorted list, to ensure no duplicates search !> for the element symbol first pure subroutine append_symbol ( list , nlist , symbol ) !> List of element symbols character ( len =* ), allocatable , intent ( inout ) :: list (:) !> Current occupied size of list integer , intent ( inout ) :: nlist !> Elements symbol character ( len =* ), intent ( in ) :: symbol if ( nlist >= size ( list )) then call resize ( list ) end if nlist = nlist + 1 list ( nlist ) = symbol end subroutine append_symbol !> Append an atomic number to an unsorted list, to ensure no duplicates search !> for the atomic number first pure subroutine append_number ( list , nlist , number ) !> List of atomic number integer , allocatable , intent ( inout ) :: list (:) !> Current occupied size of list integer , intent ( inout ) :: nlist !> Atomic number integer , intent ( in ) :: number if ( nlist >= size ( list )) then call resize ( list ) end if nlist = nlist + 1 list ( nlist ) = number end subroutine append_number end module mctc_io_symbols","tags":"","loc":"sourcefile/symbols.f90.html"},{"title":"vasp.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_vasp use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error use mctc_io_convert , only : aatoau use mctc_io_resize , only : resize use mctc_io_structure , only : structure_type , new use mctc_io_structure_info , only : structure_info use mctc_io_symbols , only : to_number , symbol_length use mctc_io_utils , only : next_line , token_type , next_token , io_error , filename , & read_next_token , to_string implicit none private public :: read_vasp contains subroutine read_vasp ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error logical :: selective , cartesian integer :: i , j , k , nn , ntype , natoms , izp , stat , pos , lnum integer , allocatable :: ncount (:) real ( wp ) :: ddum , latvec ( 3 ), scalar , coord ( 3 ), lattice ( 3 , 3 ) real ( wp ), allocatable :: xyz (:, :) type ( token_type ) :: token character ( len = :), allocatable :: line , comment character ( len = 2 * symbol_length ), allocatable :: args (:), args2 (:) character ( len = symbol_length ), allocatable :: sym (:) type ( structure_info ) :: info selective = . false . ! Selective dynamics cartesian = . true . ! Cartesian or direct lattice = 0 stat = 0 lnum = 0 ntype = 0 ! first line contains the symbols of different atom types call next_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if call parse_line ( \" \" // line , args , ntype ) call move_alloc ( line , comment ) ! this line contains the global scaling factor, call next_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if call read_next_token ( line , pos , token , ddum , stat ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read scaling factor\" , & & line , token , filename ( unit ), lnum , \"expected real value\" ) return end if ! the Ang->au conversion is included in the scaling factor scalar = ddum * aatoau ! reading the lattice constants do i = 1 , 3 call next_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of lattice vectors encountered\" ) return end if call read_next_token ( line , pos , token , latvec ( 1 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , latvec ( 2 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , latvec ( 3 ), stat ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read lattice vectors from input\" , & & line , token , filename ( unit ), lnum , \"expected real value\" ) return end if lattice (:, i ) = latvec * scalar end do ! Either here are the numbers of each element, ! or (>vasp.5.1) here are the element symbols call next_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if ! try to verify that first element is actually a number i = max ( verify ( line , ' ' ), 1 ) j = scan ( line ( i :), ' ' ) - 2 + i if ( j < i ) j = len_trim ( line ) ! CONTCAR files have additional Element line here since vasp.5.1 if ( verify ( line ( i : j ), '1234567890' ) /= 0 ) then call parse_line ( \" \" // line , args , ntype ) call next_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if else deallocate ( comment ) end if call parse_line ( \" \" // line , args2 , nn ) if ( nn /= ntype ) then call fatal_error ( error , 'Number of atom types mismatches the number of counts' ) return end if allocate ( ncount ( nn ), source = 0 ) do i = 1 , nn read ( args2 ( i ), * , iostat = stat ) ncount ( i ) izp = to_number ( args ( i )) if ( izp < 1 . or . ncount ( i ) < 1 ) then call fatal_error ( error , \"Unknown element '\" // trim ( args ( i )) // \"' encountered\" ) return end if end do natoms = sum ( ncount ) allocate ( sym ( natoms )) allocate ( xyz ( 3 , natoms )) k = 0 do i = 1 , nn do j = 1 , ncount ( i ) k = k + 1 sym ( k ) = trim ( args ( i )) end do end do call next_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Could not read POSCAR\" ) return end if line = adjustl ( line ) if ( line (: 1 ). eq . 's' . or . line (: 1 ). eq . 'S' ) then selective = . true . call next_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if line = adjustl ( line ) end if cartesian = ( line (: 1 ). eq . 'c' . or . line (: 1 ). eq . 'C' . or . & & line (: 1 ). eq . 'k' . or . line (: 1 ). eq . 'K' ) do i = 1 , natoms call next_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of geometry encountered\" ) return end if call read_next_token ( line , pos , token , coord ( 1 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 2 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 3 ), stat ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read geometry from input\" , & & line , token , filename ( unit ), lnum , \"expected real value\" ) return end if if ( cartesian ) then xyz (:, i ) = coord * scalar else xyz (:, i ) = matmul ( lattice , coord ) end if end do ! save information about this POSCAR for later info = structure_info ( scale = ddum , selective = selective , cartesian = cartesian ) call new ( self , sym , xyz , lattice = lattice , info = info ) if ( allocated ( comment )) self % comment = comment end subroutine read_vasp subroutine parse_line ( line , args , nargs ) character ( len =* ), intent ( in ) :: line character ( len = 2 * symbol_length ), allocatable , intent ( out ) :: args (:) integer , intent ( out ) :: nargs integer , parameter :: p_initial_size = 50 integer :: istart , iend allocate ( args ( p_initial_size ), source = repeat ( ' ' , 2 * symbol_length )) istart = 1 iend = 1 nargs = 0 do while ( iend < len_trim ( line )) istart = verify ( line ( iend :), ' ' ) - 1 + iend iend = scan ( line ( istart :), ' ' ) - 1 + istart if ( iend < istart ) iend = len_trim ( line ) if ( nargs >= size ( args )) then call resize ( args ) end if nargs = nargs + 1 args ( nargs ) = trim ( line ( istart : iend )) end do end subroutine parse_line end module mctc_io_read_vasp","tags":"","loc":"sourcefile/vasp.f90~2.html"},{"title":"turbomole.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_turbomole use mctc_env_accuracy , only : wp use mctc_io_structure , only : structure_type use mctc_io_convert , only : autoaa implicit none private public :: write_coord contains subroutine write_coord ( mol , unit ) class ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer :: iat , ilt , npbc logical :: expo real ( wp ) :: conv_fac logical :: angs angs = mol % info % angs_coord conv_fac = 1.0_wp if ( angs ) conv_fac = autoaa if ( angs ) then write ( unit , '(a)' ) \"$coord angs\" else write ( unit , '(a)' ) \"$coord\" end if expo = maxval ( mol % xyz ) > 1.0e+5 . or . minval ( mol % xyz ) < - 1.0e+5 if ( expo ) then do iat = 1 , mol % nat write ( unit , '(3es24.14, 6x, a)' ) mol % xyz (:, iat ) * conv_fac , & trim ( mol % sym ( mol % id ( iat ))) end do else do iat = 1 , mol % nat write ( unit , '(3f24.14, 6x, a)' ) mol % xyz (:, iat ) * conv_fac , & trim ( mol % sym ( mol % id ( iat ))) end do end if if ( any ([ nint ( mol % charge ), mol % uhf ] /= 0 )) then write ( unit , '(a, *(1x, a, \"=\", i0))' ) & \"$eht\" , \"charge\" , nint ( mol % charge ), \"unpaired\" , mol % uhf end if if ( any ( mol % periodic )) then write ( unit , '(a, 1x, i0)' ) \"$periodic\" , count ( mol % periodic ) npbc = count ( mol % periodic ) if ( size ( mol % lattice , 2 ) == 3 ) then if ( angs ) then write ( unit , '(a)' ) \"$lattice angs\" else write ( unit , '(a)' ) \"$lattice bohr\" end if do ilt = 1 , npbc write ( unit , '(3f20.14)' ) mol % lattice (: npbc , ilt ) * conv_fac end do end if end if write ( unit , '(a)' ) \"$end\" end subroutine write_coord end module mctc_io_write_turbomole","tags":"","loc":"sourcefile/turbomole.f90~2.html"},{"title":"xyz.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_xyz use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error use mctc_io_convert , only : aatoau use mctc_io_structure , only : structure_type , new use mctc_io_symbols , only : to_number , to_symbol , symbol_length use mctc_io_utils , only : next_line , token_type , next_token , io_error , filename , & read_next_token , to_string implicit none private public :: read_xyz contains subroutine read_xyz ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: ii , n , iat , stat , pos , lnum real ( wp ) :: x , y , z , conv real ( wp ), allocatable :: xyz (:, :) type ( token_type ) :: token , tsym , tnat character ( len = symbol_length ) :: chdum character ( len = symbol_length ), allocatable :: sym (:) character ( len = :), allocatable :: line , comment , fline conv = aatoau lnum = 0 call next_line ( unit , fline , pos , lnum , stat ) call read_next_token ( fline , pos , tnat , n , stat ) if ( stat /= 0 ) then call io_error ( error , \"Could not read number of atoms\" , & & fline , tnat , filename ( unit ), lnum , \"expected integer value\" ) return end if if ( n . lt . 1 ) then call io_error ( error , \"Impossible number of atoms provided\" , & & fline , tnat , filename ( unit ), lnum , \"expected positive integer value\" ) return end if allocate ( sym ( n )) allocate ( xyz ( 3 , n )) ! next record is a comment call next_line ( unit , comment , pos , lnum , stat ) if ( stat /= 0 ) then call io_error ( error , \"Unexpected end of file\" , & & \"\" , token_type ( 0 , 0 ), filename ( unit ), lnum + 1 , \"expected value\" ) return end if ii = 0 do while ( ii < n ) call next_line ( unit , line , pos , lnum , stat ) if ( is_iostat_end ( stat )) exit if ( stat /= 0 ) then call io_error ( error , \"Could not read geometry from xyz file\" , & & \"\" , token_type ( 0 , 0 ), filename ( unit ), lnum + 1 , \"expected value\" ) return end if call next_token ( line , pos , tsym ) if ( stat == 0 ) & call read_next_token ( line , pos , token , x , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , y , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , z , stat ) if ( stat /= 0 ) then call io_error ( error , \"Could not parse coordinates from xyz file\" , & & line , token , filename ( unit ), lnum , \"expected real value\" ) return end if ! Adjust the token length to faithfully report the used chars in case of an error tsym % last = min ( tsym % last , tsym % first + symbol_length - 1 ) chdum = line ( tsym % first : tsym % last ) iat = to_number ( chdum ) if ( iat <= 0 ) then read ( chdum , * , iostat = stat ) iat if ( stat == 0 ) then chdum = to_symbol ( iat ) else iat = 0 end if end if if ( iat > 0 ) then ii = ii + 1 sym ( ii ) = trim ( chdum ) xyz (:, ii ) = [ x , y , z ] * conv else call io_error ( error , \"Cannot map symbol to atomic number\" , & & line , tsym , filename ( unit ), lnum , \"unknown element\" ) return end if end do if ( ii /= n ) then call io_error ( error , \"Atom number missmatch in xyz file\" , & & fline , tnat , filename ( unit ), 1 , \"found \" // to_string ( ii ) // \" atoms in input\" ) return end if call new ( self , sym , xyz ) if ( len ( comment ) > 0 ) self % comment = comment end subroutine read_xyz end module mctc_io_read_xyz","tags":"","loc":"sourcefile/xyz.f90~2.html"},{"title":"qchem.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_qchem use mctc_env_accuracy , only : wp use mctc_io_convert , only : autoaa use mctc_io_structure , only : structure_type implicit none private public :: write_qchem contains subroutine write_qchem ( self , unit ) !> Instance of the molecular structure data class ( structure_type ), intent ( in ) :: self !> File handle integer , intent ( in ) :: unit integer :: iat logical :: expo write ( unit , '(a)' ) \"$molecule\" write ( unit , '(*(1x, i0))' ) nint ( self % charge ), self % uhf + 1 expo = maxval ( self % xyz ) > 1.0e+5 . or . minval ( self % xyz ) < - 1.0e+5 if ( expo ) then do iat = 1 , self % nat write ( unit , '(a, 1x, 3es24.14)' ) & self % sym ( self % id ( iat )), self % xyz (:, iat ) * autoaa end do else do iat = 1 , self % nat write ( unit , '(a, 1x, 3f24.14)' ) & self % sym ( self % id ( iat )), self % xyz (:, iat ) * autoaa end do end if write ( unit , '(a)' ) \"$end\" end subroutine write_qchem end module mctc_io_write_qchem","tags":"","loc":"sourcefile/qchem.f90~2.html"},{"title":"cjson.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_cjson use mctc_env_accuracy , only : wp use mctc_io_constants , only : pi use mctc_io_convert , only : autoaa use mctc_io_math , only : matinv_3x3 use mctc_io_structure , only : structure_type implicit none private public :: write_cjson interface json_value module procedure :: json_value_char module procedure :: json_value_int module procedure :: json_value_real end interface json_value interface json_array module procedure :: json_array_char_1 module procedure :: json_array_int_1 module procedure :: json_array_real_1 end interface json_array character ( len =* ), parameter :: nl = new_line ( 'a' ) contains subroutine write_cjson ( mol , unit ) type ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit write ( unit , '(a)' ) json_string ( mol , \"  \" ) end subroutine write_cjson pure function json_string ( mol , indent ) result ( string ) type ( structure_type ), intent ( in ) :: mol character ( len =* ), intent ( in ), optional :: indent character ( len = :), allocatable :: string real ( wp ), allocatable :: inv_lat (:, :) real ( wp ), allocatable :: abc (:, :) real ( wp ) :: cellpar ( 6 ) string = \"{\" if ( present ( indent )) string = string // nl // indent string = string // json_key ( \"chemicalJson\" , indent ) // json_value ( 1 ) if ( allocated ( mol % comment )) then string = string // \",\" if ( present ( indent )) string = string // nl // indent string = string // json_key ( \"name\" , indent ) // json_value ( mol % comment ) end if string = string // \",\" if ( present ( indent )) string = string // nl // indent string = string // json_key ( \"atoms\" , indent ) // \"{\" if ( present ( indent )) string = string // nl // repeat ( indent , 2 ) string = string // json_key ( \"elements\" , indent ) // \"{\" if ( present ( indent )) string = string // nl // repeat ( indent , 3 ) string = string // json_key ( \"number\" , indent ) // json_array ( mol % num ( mol % id ), 3 , indent ) if ( present ( indent )) string = string // nl // repeat ( indent , 2 ) string = string // \"}\" string = string // \",\" if ( present ( indent )) string = string // nl // repeat ( indent , 2 ) string = string // json_key ( \"coords\" , indent ) // \"{\" if ( present ( indent )) string = string // nl // repeat ( indent , 3 ) if ( mol % info % cartesian ) then string = string // json_key ( \"3d\" , indent ) // json_array ([ mol % xyz * autoaa ], 3 , indent ) else inv_lat = matinv_3x3 ( mol % lattice ) abc = matmul ( inv_lat , mol % xyz ) string = string // json_key ( \"3dFractional\" , indent ) // json_array ([ abc ], 3 , indent ) end if if ( present ( indent )) string = string // nl // repeat ( indent , 2 ) string = string // \"}\" if ( present ( indent )) string = string // nl // indent string = string // \"}\" string = string // \",\" if ( present ( indent )) string = string // nl // indent string = string // json_key ( \"properties\" , indent ) // \"{\" if ( present ( indent )) string = string // nl // repeat ( indent , 2 ) string = string // json_key ( \"totalCharge\" , indent ) // json_value ( nint ( mol % charge )) if ( mol % uhf > 0 ) then string = string // \",\" if ( present ( indent )) string = string // nl // repeat ( indent , 2 ) string = string // json_key ( \"totalSpinMultiplicity\" , indent ) // json_value ( mol % uhf + 1 ) end if if ( present ( indent )) string = string // nl // indent string = string // \"}\" if ( allocated ( mol % bond )) then string = string // \",\" if ( present ( indent )) string = string // nl // indent string = string // json_key ( \"bonds\" , indent ) // \"{\" if ( present ( indent )) string = string // nl // repeat ( indent , 2 ) string = string // json_key ( \"connections\" , indent ) // \"{\" if ( present ( indent )) string = string // nl // repeat ( indent , 3 ) string = string // json_key ( \"index\" , indent ) // json_array ([ mol % bond ( 1 : 2 , :) - 1 ], 3 , indent ) if ( present ( indent )) string = string // nl // repeat ( indent , 2 ) string = string // \"}\" if ( size ( mol % bond , 1 ) > 2 ) then string = string // \",\" if ( present ( indent )) string = string // nl // repeat ( indent , 2 ) string = string // json_key ( \"order\" , indent ) // json_array ( mol % bond ( 3 , :), 2 , indent ) if ( present ( indent )) string = string // nl // indent end if string = string // \"}\" end if if ( any ( mol % periodic )) then call dlat_to_cell ( mol % lattice , cellpar ) cellpar ( 1 : 3 ) = cellpar ( 1 : 3 ) * autoaa cellpar ( 4 : 6 ) = cellpar ( 4 : 6 ) * 180 / pi string = string // \",\" if ( present ( indent )) string = string // nl // indent string = string // json_key ( \"unitCell\" , indent ) // \"{\" if ( present ( indent )) string = string // nl // repeat ( indent , 2 ) string = string // json_key ( \"a\" , indent ) // json_value ( cellpar ( 1 ), \"(es23.16)\" ) string = string // \",\" if ( present ( indent )) string = string // nl // repeat ( indent , 2 ) string = string // json_key ( \"b\" , indent ) // json_value ( cellpar ( 2 ), \"(es23.16)\" ) string = string // \",\" if ( present ( indent )) string = string // nl // repeat ( indent , 2 ) string = string // json_key ( \"c\" , indent ) // json_value ( cellpar ( 3 ), \"(es23.16)\" ) string = string // \",\" if ( present ( indent )) string = string // nl // repeat ( indent , 2 ) string = string // json_key ( \"alpha\" , indent ) // json_value ( cellpar ( 4 ), \"(es23.16)\" ) string = string // \",\" if ( present ( indent )) string = string // nl // repeat ( indent , 2 ) string = string // json_key ( \"beta\" , indent ) // json_value ( cellpar ( 5 ), \"(es23.16)\" ) string = string // \",\" if ( present ( indent )) string = string // nl // repeat ( indent , 2 ) string = string // json_key ( \"gamma\" , indent ) // json_value ( cellpar ( 6 ), \"(es23.16)\" ) if ( present ( indent )) string = string // nl // indent string = string // \"}\" end if if ( present ( indent )) string = string // nl string = string // \"}\" end function json_string pure function json_array_int_1 ( array , depth , indent ) result ( string ) integer , intent ( in ) :: array (:) integer , intent ( in ) :: depth character ( len =* ), intent ( in ), optional :: indent character ( len = :), allocatable :: string integer :: i , j string = \"[\" do i = 1 , size ( array ) if ( present ( indent )) string = string // nl // repeat ( indent , depth + 1 ) string = string // json_value ( array ( i )) if ( i /= size ( array )) string = string // \",\" end do if ( present ( indent )) string = string // nl // repeat ( indent , depth ) string = string // \"]\" end function json_array_int_1 pure function json_array_real_1 ( array , depth , indent ) result ( string ) real ( wp ), intent ( in ) :: array (:) integer , intent ( in ) :: depth character ( len =* ), intent ( in ), optional :: indent character ( len = :), allocatable :: string integer :: i , j string = \"[\" do i = 1 , size ( array ) if ( present ( indent )) string = string // nl // repeat ( indent , depth + 1 ) string = string // json_value ( array ( i ), '(es23.16)' ) if ( i /= size ( array )) string = string // \",\" end do if ( present ( indent )) string = string // nl // repeat ( indent , depth ) string = string // \"]\" end function json_array_real_1 pure function json_array_char_1 ( array , depth , indent ) result ( string ) character ( len =* ), intent ( in ) :: array (:) integer , intent ( in ) :: depth character ( len =* ), intent ( in ), optional :: indent character ( len = :), allocatable :: string integer :: i , j string = \"[\" do i = 1 , size ( array ) if ( present ( indent )) string = string // nl // repeat ( indent , depth + 1 ) string = string // json_value ( trim ( array ( i ))) if ( i /= size ( array )) string = string // \",\" end do if ( present ( indent )) string = string // nl // repeat ( indent , depth ) string = string // \"]\" end function json_array_char_1 pure function json_key ( key , indent ) result ( string ) character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ), optional :: indent character ( len = :), allocatable :: string if ( present ( indent )) then string = json_value ( key ) // \": \" else string = json_value ( key ) // \":\" end if end function json_key pure function json_value_char ( val ) result ( string ) character ( len =* ), intent ( in ) :: val character ( len = :), allocatable :: string string = \"\"\"\" // val // \"\"\"\" end function json_value_char pure function json_value_real ( val , format ) result ( str ) real ( wp ), intent ( in ) :: val character ( len =* ), intent ( in ) :: format character ( len = :), allocatable :: str character ( len = 128 ) :: buffer integer :: stat write ( buffer , format , iostat = stat ) val if ( stat == 0 ) then str = trim ( buffer ) else str = \"\"\"*\"\"\" end if end function json_value_real pure function json_value_int ( val ) result ( string ) integer , intent ( in ) :: val character ( len = :), allocatable :: string integer , parameter :: buffer_len = range ( val ) + 2 character ( len = buffer_len ) :: buffer integer :: pos integer :: n character ( len = 1 ), parameter :: numbers ( 0 : 9 ) = & [ \"0\" , \"1\" , \"2\" , \"3\" , \"4\" , \"5\" , \"6\" , \"7\" , \"8\" , \"9\" ] if ( val == 0 ) then string = numbers ( 0 ) return end if n = abs ( val ) buffer = \"\" pos = buffer_len + 1 do while ( n > 0 ) pos = pos - 1 buffer ( pos : pos ) = numbers ( mod ( n , 10 )) n = n / 10 end do if ( val < 0 ) then pos = pos - 1 buffer ( pos : pos ) = '-' end if string = buffer ( pos :) end function json_value_int !> Convert direct lattice to cell parameters pure subroutine dlat_to_cell ( lattice , cellpar ) implicit none real ( wp ), intent ( in ) :: lattice ( 3 , 3 ) !< direct lattice real ( wp ), intent ( out ) :: cellpar ( 6 ) !< cell parameters associate ( alen => cellpar ( 1 ), blen => cellpar ( 2 ), clen => cellpar ( 3 ), & & alp => cellpar ( 4 ), bet => cellpar ( 5 ), gam => cellpar ( 6 ) ) alen = norm2 ( lattice (:, 1 )) blen = norm2 ( lattice (:, 2 )) clen = norm2 ( lattice (:, 3 )) alp = acos ( dot_product ( lattice (:, 2 ), lattice (:, 3 )) / ( blen * clen )) bet = acos ( dot_product ( lattice (:, 1 ), lattice (:, 3 )) / ( alen * clen )) gam = acos ( dot_product ( lattice (:, 1 ), lattice (:, 2 )) / ( alen * blen )) end associate end subroutine dlat_to_cell end module mctc_io_write_cjson","tags":"","loc":"sourcefile/cjson.f90.html"},{"title":"gaussian.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_gaussian use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error use mctc_io_structure , only : structure_type , new use mctc_io_utils , only : next_line , token_type , next_token , io_error , filename , & read_token , to_string implicit none private public :: read_gaussian_external contains subroutine read_gaussian_external ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: stat , n , mode , chrg , spin , iat , ii , pos , lnum type ( token_type ) :: token , tnat character ( len = :), allocatable :: line integer , allocatable :: at (:) real ( wp ), allocatable :: xyz (:,:) real ( wp ) :: coord ( 3 ), q lnum = 0 call next_line ( unit , line , pos , lnum , stat ) if ( stat == 0 ) then token = token_type ( 1 , 10 ) tnat = token call read_token ( line , token , n , stat ) end if if ( stat == 0 ) then token = token_type ( 11 , 20 ) call read_token ( line , token , mode , stat ) end if if ( stat == 0 ) then token = token_type ( 21 , 30 ) call read_token ( line , token , chrg , stat ) end if if ( stat == 0 ) then token = token_type ( 31 , 40 ) call read_token ( line , token , spin , stat ) end if if ( stat /= 0 ) then call io_error ( error , \"Could not read number of atoms\" , & & line , token , filename ( unit ), lnum , \"expected integer value\" ) return end if if ( n <= 0 ) then call io_error ( error , \"Found no atoms, cannot work without atoms!\" , & & line , tnat , filename ( unit ), lnum , \"expected positive integer\" ) return end if allocate ( xyz ( 3 , n )) allocate ( at ( n )) ii = 0 do while ( ii < n ) call next_line ( unit , line , pos , lnum , stat ) if ( is_iostat_end ( stat )) exit if ( stat == 0 ) then token = token_type ( 1 , 10 ) tnat = token call read_token ( line , token , iat , stat ) end if if ( stat == 0 ) then token = token_type ( 11 , 30 ) call read_token ( line , token , coord ( 1 ), stat ) end if if ( stat == 0 ) then token = token_type ( 31 , 50 ) call read_token ( line , token , coord ( 2 ), stat ) end if if ( stat == 0 ) then token = token_type ( 51 , 70 ) call read_token ( line , token , coord ( 3 ), stat ) end if if ( stat == 0 ) then token = token_type ( 71 , 90 ) call read_token ( line , token , q , stat ) end if if ( stat /= 0 ) then call io_error ( error , \"Could not read geometry from Gaussian file\" , & & line , token , filename ( unit ), lnum , \"unexpected value\" ) return end if if ( iat > 0 ) then ii = ii + 1 at ( ii ) = iat xyz (:, ii ) = coord else call io_error ( error , \"Invalid atomic number\" , & & line , tnat , filename ( unit ), lnum , \"expected positive integer\" ) return end if end do call new ( self , at , xyz , charge = real ( chrg , wp ), uhf = spin ) if ( ii /= n ) then call fatal_error ( error , \"Atom number missmatch in Gaussian file\" ) return end if end subroutine read_gaussian_external end module mctc_io_read_gaussian","tags":"","loc":"sourcefile/gaussian.f90~2.html"},{"title":"math.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Simple algebraic functions module mctc_io_math use mctc_env_accuracy , only : wp use mctc_io_constants , only : pi implicit none private public :: matdet_3x3 , matinv_3x3 , crossprod , eigval_3x3 , eigvec_3x3 real ( wp ), parameter :: twothirdpi = 2.0_wp * pi / 3.0_wp contains !> Performs a direct calculation of the inverse of a 3×3 matrix. ! !  reference: http://fortranwiki.org/fortran/show/Matrix+inversion pure function matinv_3x3 ( a ) result ( b ) !> Matrix real ( wp ), intent ( in ) :: a ( 3 , 3 ) !> Inverse matrix real ( wp ) :: b ( 3 , 3 ) real ( wp ) :: detinv ! Calculate the inverse determinant of the matrix detinv = 1.0_wp / matdet_3x3 ( a ) ! Calculate the inverse of the matrix b ( 1 , 1 ) = + detinv * ( a ( 2 , 2 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 3 , 2 )) b ( 2 , 1 ) = - detinv * ( a ( 2 , 1 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 3 , 1 )) b ( 3 , 1 ) = + detinv * ( a ( 2 , 1 ) * a ( 3 , 2 ) - a ( 2 , 2 ) * a ( 3 , 1 )) b ( 1 , 2 ) = - detinv * ( a ( 1 , 2 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 3 , 2 )) b ( 2 , 2 ) = + detinv * ( a ( 1 , 1 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 3 , 1 )) b ( 3 , 2 ) = - detinv * ( a ( 1 , 1 ) * a ( 3 , 2 ) - a ( 1 , 2 ) * a ( 3 , 1 )) b ( 1 , 3 ) = + detinv * ( a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 2 )) b ( 2 , 3 ) = - detinv * ( a ( 1 , 1 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 1 )) b ( 3 , 3 ) = + detinv * ( a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 2 , 1 )) end function matinv_3x3 !> Determinant of 3×3 matrix pure function matdet_3x3 ( a ) result ( det ) !> Matrix real ( wp ), intent ( in ) :: a ( 3 , 3 ) !> Determinant real ( wp ) :: det det = a ( 1 , 1 ) * a ( 2 , 2 ) * a ( 3 , 3 ) & & - a ( 1 , 1 ) * a ( 2 , 3 ) * a ( 3 , 2 ) & & - a ( 1 , 2 ) * a ( 2 , 1 ) * a ( 3 , 3 ) & & + a ( 1 , 2 ) * a ( 2 , 3 ) * a ( 3 , 1 ) & & + a ( 1 , 3 ) * a ( 2 , 1 ) * a ( 3 , 2 ) & & - a ( 1 , 3 ) * a ( 2 , 2 ) * a ( 3 , 1 ) end function matdet_3x3 !> Implements the cross/vector product between two 3D vectors pure function crossprod ( a , b ) result ( c ) !> First vector real ( wp ), intent ( in ) :: a ( 3 ) !> Second vector real ( wp ), intent ( in ) :: b ( 3 ) !> Orthogonal vector real ( wp ) :: c ( 3 ) c ( 1 ) = a ( 2 ) * b ( 3 ) - b ( 2 ) * a ( 3 ) c ( 2 ) = a ( 3 ) * b ( 1 ) - b ( 3 ) * a ( 1 ) c ( 3 ) = a ( 1 ) * b ( 2 ) - b ( 1 ) * a ( 2 ) end function crossprod !> Calculates eigenvalues based on the trigonometric solution of A = pB + qI pure subroutine eigval_3x3 ( a , w ) !> The symmetric input matrix real ( wp ), intent ( in ) :: a ( 3 , 3 ) !> Contains eigenvalues on exit real ( wp ), intent ( out ) :: w ( 3 ) real ( wp ) :: q , p , r r = a ( 1 , 2 ) * a ( 1 , 2 ) + a ( 1 , 3 ) * a ( 1 , 3 ) + a ( 2 , 3 ) * a ( 2 , 3 ) q = ( a ( 1 , 1 ) + a ( 2 , 2 ) + a ( 3 , 3 )) / 3.0_wp w ( 1 ) = a ( 1 , 1 ) - q w ( 2 ) = a ( 2 , 2 ) - q w ( 3 ) = a ( 3 , 3 ) - q p = sqrt (( w ( 1 ) * w ( 1 ) + w ( 2 ) * w ( 2 ) + w ( 3 ) * w ( 3 ) + 2 * r ) / 6.0_wp ) r = ( w ( 1 ) * ( w ( 2 ) * w ( 3 ) - a ( 2 , 3 ) * a ( 2 , 3 )) & & - a ( 1 , 2 ) * ( a ( 1 , 2 ) * w ( 3 ) - a ( 2 , 3 ) * a ( 1 , 3 )) & & + a ( 1 , 3 ) * ( a ( 1 , 2 ) * a ( 2 , 3 ) - w ( 2 ) * a ( 1 , 3 ))) / ( p * p * p ) * 0.5_wp if ( r <= - 1.0_wp ) then r = 0.5_wp * twothirdpi else if ( r >= 1.0_wp ) then r = 0.0_wp else r = acos ( r ) / 3.0_wp end if w ( 3 ) = q + 2 * p * cos ( r ) w ( 1 ) = q + 2 * p * cos ( r + twothirdpi ) w ( 2 ) = 3 * q - w ( 1 ) - w ( 3 ) end subroutine eigval_3x3 !> Calculates eigenvector using an analytical method based on vector cross !  products. pure subroutine eigvec_3x3 ( a , w , q ) real ( wp ), intent ( inout ) :: a ( 3 , 3 ) real ( wp ), intent ( out ) :: w ( 3 ) real ( wp ), intent ( out ) :: q ( 3 , 3 ) real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) real ( wp ) norm , n1 , n2 , n3 , precon integer :: i w ( 1 ) = max ( abs ( a ( 1 , 1 )), abs ( a ( 1 , 2 ))) w ( 2 ) = max ( abs ( a ( 1 , 3 )), abs ( a ( 2 , 2 ))) w ( 3 ) = max ( abs ( a ( 2 , 3 )), abs ( a ( 3 , 3 ))) precon = max ( w ( 1 ), max ( w ( 2 ), w ( 3 ))) ! null matrix if ( precon < eps ) then w ( 1 ) = 0.0_wp w ( 2 ) = 0.0_wp w ( 3 ) = 0.0_wp q ( 1 , 1 ) = 1.0_wp q ( 2 , 2 ) = 1.0_wp q ( 3 , 3 ) = 1.0_wp q ( 1 , 2 ) = 0.0_wp q ( 1 , 3 ) = 0.0_wp q ( 2 , 3 ) = 0.0_wp q ( 2 , 1 ) = 0.0_wp q ( 3 , 1 ) = 0.0_wp q ( 3 , 2 ) = 0.0_wp return end if norm = 1.0_wp / precon a ( 1 , 1 ) = a ( 1 , 1 ) * norm a ( 1 , 2 ) = a ( 1 , 2 ) * norm a ( 2 , 2 ) = a ( 2 , 2 ) * norm a ( 1 , 3 ) = a ( 1 , 3 ) * norm a ( 2 , 3 ) = a ( 2 , 3 ) * norm a ( 3 , 3 ) = a ( 3 , 3 ) * norm ! Calculate eigenvalues call eigval_3x3 ( a , w ) ! Compute first eigenvector a ( 1 , 1 ) = a ( 1 , 1 ) - w ( 1 ) a ( 2 , 2 ) = a ( 2 , 2 ) - w ( 1 ) a ( 3 , 3 ) = a ( 3 , 3 ) - w ( 1 ) q ( 1 , 1 ) = a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 2 ) q ( 2 , 1 ) = a ( 1 , 3 ) * a ( 1 , 2 ) - a ( 1 , 1 ) * a ( 2 , 3 ) q ( 3 , 1 ) = a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 1 , 2 ) q ( 1 , 2 ) = a ( 1 , 2 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 2 , 3 ) q ( 2 , 2 ) = a ( 1 , 3 ) * a ( 1 , 3 ) - a ( 1 , 1 ) * a ( 3 , 3 ) q ( 3 , 2 ) = a ( 1 , 1 ) * a ( 2 , 3 ) - a ( 1 , 2 ) * a ( 1 , 3 ) q ( 1 , 3 ) = a ( 2 , 2 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 2 , 3 ) q ( 2 , 3 ) = a ( 2 , 3 ) * a ( 1 , 3 ) - a ( 1 , 2 ) * a ( 3 , 3 ) q ( 3 , 3 ) = a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 2 , 2 ) * a ( 1 , 3 ) n1 = q ( 1 , 1 ) * q ( 1 , 1 ) + q ( 2 , 1 ) * q ( 2 , 1 ) + q ( 3 , 1 ) * q ( 3 , 1 ) n2 = q ( 1 , 2 ) * q ( 1 , 2 ) + q ( 2 , 2 ) * q ( 2 , 2 ) + q ( 3 , 2 ) * q ( 3 , 2 ) n3 = q ( 1 , 3 ) * q ( 1 , 3 ) + q ( 2 , 3 ) * q ( 2 , 3 ) + q ( 3 , 3 ) * q ( 3 , 3 ) norm = n1 i = 1 if ( n2 > norm ) then i = 2 norm = n1 end if if ( n3 > norm ) then i = 3 end if if ( i == 1 ) then norm = sqrt ( 1.0_wp / n1 ) q ( 1 , 1 ) = q ( 1 , 1 ) * norm q ( 2 , 1 ) = q ( 2 , 1 ) * norm q ( 3 , 1 ) = q ( 3 , 1 ) * norm else if ( i == 2 ) then norm = sqrt ( 1.0_wp / n2 ) q ( 1 , 1 ) = q ( 1 , 2 ) * norm q ( 2 , 1 ) = q ( 2 , 2 ) * norm q ( 3 , 1 ) = q ( 3 , 2 ) * norm else norm = sqrt ( 1.0_wp / n3 ) q ( 1 , 1 ) = q ( 1 , 3 ) * norm q ( 2 , 1 ) = q ( 2 , 3 ) * norm q ( 3 , 1 ) = q ( 3 , 3 ) * norm end if ! Robustly compute a right-hand orthonormal set (ev1, u, v) if ( abs ( q ( 1 , 1 )) > abs ( q ( 2 , 1 ))) then norm = sqrt ( 1.0_wp / ( q ( 1 , 1 ) * q ( 1 , 1 ) + q ( 3 , 1 ) * q ( 3 , 1 ))) q ( 1 , 2 ) = - q ( 3 , 1 ) * norm q ( 2 , 2 ) = 0.0_wp q ( 3 , 2 ) = + q ( 1 , 1 ) * norm else norm = sqrt ( 1.0_wp / ( q ( 2 , 1 ) * q ( 2 , 1 ) + q ( 3 , 1 ) * q ( 3 , 1 ))) q ( 1 , 2 ) = 0.0_wp q ( 2 , 2 ) = + q ( 3 , 1 ) * norm q ( 3 , 2 ) = - q ( 2 , 1 ) * norm end if q ( 1 , 3 ) = q ( 2 , 1 ) * q ( 3 , 2 ) - q ( 3 , 1 ) * q ( 2 , 2 ) q ( 2 , 3 ) = q ( 3 , 1 ) * q ( 1 , 2 ) - q ( 1 , 1 ) * q ( 3 , 2 ) q ( 3 , 3 ) = q ( 1 , 1 ) * q ( 2 , 2 ) - q ( 2 , 1 ) * q ( 1 , 2 ) ! Reset A a ( 1 , 1 ) = a ( 1 , 1 ) + w ( 1 ) a ( 2 , 2 ) = a ( 2 , 2 ) + w ( 1 ) a ( 3 , 3 ) = a ( 3 , 3 ) + w ( 1 ) ! A*U n1 = a ( 1 , 1 ) * q ( 1 , 2 ) + a ( 1 , 2 ) * q ( 2 , 2 ) + a ( 1 , 3 ) * q ( 3 , 2 ) n2 = a ( 1 , 2 ) * q ( 1 , 2 ) + a ( 2 , 2 ) * q ( 2 , 2 ) + a ( 2 , 3 ) * q ( 3 , 2 ) n3 = a ( 1 , 3 ) * q ( 1 , 2 ) + a ( 2 , 3 ) * q ( 2 , 2 ) + a ( 3 , 3 ) * q ( 3 , 2 ) ! A*V, note out of order computation a ( 3 , 3 ) = a ( 1 , 3 ) * q ( 1 , 3 ) + a ( 2 , 3 ) * q ( 2 , 3 ) + a ( 3 , 3 ) * q ( 3 , 3 ) a ( 1 , 3 ) = a ( 1 , 1 ) * q ( 1 , 3 ) + a ( 1 , 2 ) * q ( 2 , 3 ) + a ( 1 , 3 ) * q ( 3 , 3 ) a ( 2 , 3 ) = a ( 1 , 2 ) * q ( 1 , 3 ) + a ( 2 , 2 ) * q ( 2 , 3 ) + a ( 2 , 3 ) * q ( 3 , 3 ) ! UT*(A*U) - l2*E n1 = q ( 1 , 2 ) * n1 + q ( 2 , 2 ) * n2 + q ( 3 , 2 ) * n3 - w ( 2 ) ! UT*(A*V) n2 = q ( 1 , 2 ) * a ( 1 , 3 ) + q ( 2 , 2 ) * a ( 2 , 3 ) + q ( 3 , 2 ) * a ( 3 , 3 ) ! VT*(A*V) - l2*E n3 = q ( 1 , 3 ) * a ( 1 , 3 ) + q ( 2 , 3 ) * a ( 2 , 3 ) + q ( 3 , 3 ) * a ( 3 , 3 ) - w ( 2 ) if ( abs ( n1 ) >= abs ( n3 )) then norm = max ( abs ( n1 ), abs ( n2 )) if ( norm > eps ) then if ( abs ( n1 ) >= abs ( n2 )) then n2 = n2 / n1 n1 = sqrt ( 1.0_wp / ( 1.0_wp + n2 * n2 )) n2 = n2 * n1 else n1 = n1 / n2 n2 = sqrt ( 1.0_wp / ( 1.0_wp + n1 * n1 )) n1 = n1 * n2 end if q ( 1 , 2 ) = n2 * q ( 1 , 2 ) - n1 * q ( 1 , 3 ) q ( 2 , 2 ) = n2 * q ( 2 , 2 ) - n1 * q ( 2 , 3 ) q ( 3 , 2 ) = n2 * q ( 3 , 2 ) - n1 * q ( 3 , 3 ) end if else norm = max ( abs ( n3 ), abs ( n2 )) if ( norm > eps ) then if ( abs ( n3 ) >= abs ( n2 )) then n2 = n2 / n3 n3 = sqrt ( 1.0_wp / ( 1.0_wp + n2 * n2 )) n2 = n2 * n3 else n3 = n3 / n2 n2 = sqrt ( 1.0_wp / ( 1.0_wp + n3 * n3 )) n3 = n3 * n2 end if q ( 1 , 2 ) = n3 * q ( 1 , 2 ) - n2 * q ( 1 , 3 ) q ( 2 , 2 ) = n3 * q ( 2 , 2 ) - n2 * q ( 2 , 3 ) q ( 3 , 2 ) = n3 * q ( 3 , 2 ) - n2 * q ( 3 , 3 ) end if end if ! Calculate third eigenvector from cross product q ( 1 , 3 ) = q ( 2 , 1 ) * q ( 3 , 2 ) - q ( 3 , 1 ) * q ( 2 , 2 ) q ( 2 , 3 ) = q ( 3 , 1 ) * q ( 1 , 2 ) - q ( 1 , 1 ) * q ( 3 , 2 ) q ( 3 , 3 ) = q ( 1 , 1 ) * q ( 2 , 2 ) - q ( 2 , 1 ) * q ( 1 , 2 ) w ( 1 ) = w ( 1 ) * precon w ( 2 ) = w ( 2 ) * precon w ( 3 ) = w ( 3 ) * precon end subroutine eigvec_3x3 end module mctc_io_math","tags":"","loc":"sourcefile/math.f90.html"},{"title":"aims.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_aims use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error use mctc_io_convert , only : aatoau use mctc_io_resize , only : resize use mctc_io_symbols , only : symbol_length , to_number use mctc_io_structure , only : structure_type , new use mctc_io_utils , only : next_line , token_type , next_token , io_error , filename , & read_next_token , to_string implicit none private public :: read_aims integer , parameter :: initial_size = 64 contains subroutine read_aims ( mol , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: mol !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: stat , pos , lnum , ilt , iat type ( token_type ) :: token character ( len = :), allocatable :: line real ( wp ) :: x , y , z character ( len = symbol_length ), allocatable :: sym (:) real ( wp ), allocatable :: xyz (:, :), abc (:, :), lattice (:, :) logical :: is_frac , periodic ( 3 ) logical , allocatable :: frac (:) allocate ( sym ( initial_size ), source = repeat ( ' ' , symbol_length )) allocate ( xyz ( 3 , initial_size ), source = 0.0_wp ) allocate ( abc ( 3 , initial_size ), source = 0.0_wp ) allocate ( frac ( initial_size ), source = . false .) iat = 0 ilt = 0 periodic (:) = . false . lnum = 0 stat = 0 do while ( stat == 0 ) call next_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) exit if ( len ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == \"#\" ) cycle call next_token ( line , pos , token ) select case ( line ( token % first : token % last )) case ( \"atom\" , \"atom_frac\" ) is_frac = token % last - token % first + 1 > 4 call read_next_token ( line , pos , token , x , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , y , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , z , stat ) if ( stat == 0 ) & call next_token ( line , pos , token ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read coordinates\" , & & line , token , filename ( unit ), lnum , \"expected real value\" ) exit end if if ( iat >= size ( sym )) call resize ( sym ) if ( iat >= size ( xyz , 2 )) call resize ( xyz ) if ( iat >= size ( abc , 2 )) call resize ( abc ) if ( iat >= size ( frac )) call resize ( frac ) iat = iat + 1 token % last = min ( token % last , token % first + symbol_length - 1 ) sym ( iat ) = line ( token % first : token % last ) if ( to_number ( sym ( iat )) == 0 ) then call io_error ( error , \"Cannot map symbol to atomic number\" , & & line , token , filename ( unit ), lnum , \"unknown element\" ) exit end if frac ( iat ) = is_frac if ( frac ( iat )) then abc (:, iat ) = [ x , y , z ] xyz (:, iat ) = 0.0_wp else abc (:, iat ) = 0.0_wp xyz (:, iat ) = [ x , y , z ] * aatoau end if case ( \"lattice_vector\" ) ilt = ilt + 1 if ( ilt > 3 ) then call io_error ( error , \"Too many lattice vectors\" , & & line , token , filename ( unit ), lnum , \"forth lattice vector found\" ) exit end if call read_next_token ( line , pos , token , x , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , y , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , z , stat ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read lattice vectors\" , & & line , token , filename ( unit ), lnum , \"expected real value\" ) exit end if if (. not . allocated ( lattice )) allocate ( lattice ( 3 , 3 ), source = 0.0_wp ) lattice (:, ilt ) = [ x , y , z ] * aatoau case default call io_error ( error , \"Unexpected keyword found\" , & & line , token , filename ( unit ), lnum , \"invalid in this context\" ) exit end select end do if ( allocated ( error )) return if ( iat == 0 ) then token = token_type ( 0 , 0 ) call io_error ( error , \"No atoms found\" , & & line , token , filename ( unit ), lnum + 1 , \"expected atom specification\" ) return end if if ( allocated ( lattice )) then xyz ( ilt + 1 : 3 , : iat ) = xyz ( ilt + 1 : 3 , : iat ) + abc ( ilt + 1 : 3 , : iat ) * aatoau xyz (: ilt , : iat ) = xyz (: ilt , : iat ) + matmul ( lattice (: ilt , : ilt ), abc (: ilt , : iat )) periodic (: ilt ) = . true . end if call new ( mol , sym (: iat ), xyz , lattice = lattice , periodic = periodic ) end subroutine read_aims end module mctc_io_read_aims","tags":"","loc":"sourcefile/aims.f90~2.html"},{"title":"system.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Module collecting commands to conveniently interface with system commands module mctc_env_system implicit none private public :: get_argument , get_variable public :: is_windows , is_unix contains !> Obtain the command line argument at a given index subroutine get_argument ( idx , arg ) !> Index of command line argument, range [0:command_argument_count()] integer , intent ( in ) :: idx !> Command line argument character ( len = :), allocatable , intent ( out ) :: arg integer :: length , stat call get_command_argument ( idx , length = length , status = stat ) if ( stat /= 0 ) then return endif allocate ( character ( len = length ) :: arg , stat = stat ) if ( stat /= 0 ) then return endif if ( length > 0 ) then call get_command_argument ( idx , arg , status = stat ) if ( stat /= 0 ) then deallocate ( arg ) return end if end if end subroutine get_argument !> Obtain the value of an environment variable subroutine get_variable ( var , val ) !> Name of variable character ( len =* ), intent ( in ) :: var !> Value of variable character ( len = :), allocatable , intent ( out ) :: val integer :: length , stat call get_environment_variable ( var , length = length , status = stat ) if ( stat /= 0 ) then return endif allocate ( character ( len = length ) :: val , stat = stat ) if ( stat /= 0 ) then return endif if ( length > 0 ) then call get_environment_variable ( var , val , status = stat ) if ( stat /= 0 ) then deallocate ( val ) return end if end if end subroutine get_variable !> Try to determine if we run on Windows and don't have POSIX compliance around function is_windows () !> Operating system seems to be Windows logical :: is_windows character ( len = :), allocatable :: tmp is_windows = . false . call get_variable ( 'OS' , tmp ) if ( allocated ( tmp )) then is_windows = index ( tmp , 'Windows_NT' ) > 0 end if if (. not . is_windows ) then call get_variable ( 'OSTYPE' , tmp ) if ( allocated ( tmp )) then is_windows = index ( tmp , 'win' ) > 0 . or . index ( tmp , 'msys' ) > 0 end if end if end function is_windows !> Try to determine if we run on Unix and probably can rely on POSIX compliance function is_unix () !> Operating system seems to be Unix logical :: is_unix character ( len = :), allocatable :: tmp is_unix = . not . is_windows () end function is_unix end module mctc_env_system","tags":"","loc":"sourcefile/system.f90.html"},{"title":"genformat.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_genformat use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type use mctc_io_constants , only : pi use mctc_io_convert , only : aatoau use mctc_io_structure , only : structure_type , new use mctc_io_structure_info , only : structure_info use mctc_io_symbols , only : to_number , symbol_length use mctc_io_utils , only : next_line , token_type , next_token , io_error , filename , & read_next_token , to_string implicit none private public :: read_genformat contains subroutine read_genformat ( mol , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: mol !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: line integer :: natoms , nspecies , iatom , dummy , isp , ilat , stat , istart , iend logical :: cartesian , periodic ( 3 ) real ( wp ) :: coord ( 3 ), origin ( 3 ) character ( len = 1 ) :: variant type ( token_type ) :: token character ( len = symbol_length ), allocatable :: species (:), sym (:) real ( wp ), allocatable :: xyz (:, :), abc (:, :), lattice (:, :) type ( structure_info ) :: info integer :: pos , lnum lnum = 0 call advance_line ( unit , line , pos , lnum , stat ) call read_next_token ( line , pos , token , natoms , stat ) if ( stat /= 0 . or . natoms < 1 ) then call io_error ( error , \"Could not read number of atoms\" , & & line , token , filename ( unit ), lnum , \"expected integer value\" ) return end if allocate ( species ( natoms )) allocate ( sym ( natoms )) allocate ( xyz ( 3 , natoms )) allocate ( abc ( 3 , natoms )) call next_token ( line , pos , token ) select case ( line ( token % first : token % last )) case ( 'c' , 'C' ) cartesian = . true . periodic = . false . case ( 's' , 'S' ) cartesian = . true . periodic = . true . allocate ( lattice ( 3 , 3 ), source = 0.0_wp ) case ( 'f' , 'F' ) cartesian = . false . periodic = . true . allocate ( lattice ( 3 , 3 ), source = 0.0_wp ) case ( 'h' , 'H' ) cartesian = . true . periodic = [. false ., . false ., . true .] allocate ( lattice ( 3 , 1 ), source = 0.0_wp ) case default call io_error ( error , \"Invalid input version found\" , & & line , token , filename ( unit ), lnum , \"unknown identifier\" ) return end select call advance_line ( unit , line , pos , lnum , stat ) isp = 0 do while ( pos < len ( line )) call next_token ( line , pos , token ) isp = isp + 1 token % last = min ( token % last , token % first + symbol_length - 1 ) species ( isp ) = line ( token % first : token % last ) if ( to_number ( species ( isp )) == 0 ) then call io_error ( error , \"Cannot map symbol to atomic number\" , & & line , token , filename ( unit ), lnum , \"unknown element\" ) return end if end do nspecies = isp do iatom = 1 , natoms token = token_type ( 0 , 0 ) call advance_line ( unit , line , pos , lnum , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , dummy , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , isp , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 1 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 2 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 3 ), stat ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read coordinates\" , & & line , token , filename ( unit ), lnum , \"unexpected value\" ) return end if sym ( iatom ) = species ( isp ) if ( cartesian ) then xyz (:, iatom ) = coord * aatoau else abc (:, iatom ) = coord end if end do if ( any ( periodic )) then call advance_line ( unit , line , pos , lnum , stat ) if ( stat /= 0 ) then call io_error ( error , \"Unexpected end of file\" , & & line , token_type ( 0 , 0 ), filename ( unit ), lnum , \"missing lattice information\" ) return end if if ( stat == 0 ) & call read_next_token ( line , pos , token , origin ( 1 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , origin ( 2 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , origin ( 3 ), stat ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read origin\" , & & line , token , filename ( unit ), lnum , \"expected real value\" ) return end if end if if ( all ( periodic )) then do ilat = 1 , 3 call advance_line ( unit , line , pos , lnum , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 1 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 2 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 3 ), stat ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read lattice vector\" , & & line , token , filename ( unit ), lnum , \"expected real value\" ) return end if lattice (:, ilat ) = coord * aatoau end do if (. not . cartesian ) then xyz = matmul ( lattice , abc ) end if end if if ( count ( periodic ) == 1 ) then call advance_line ( unit , line , pos , lnum , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 1 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 2 ), stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , coord ( 3 ), stat ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read lattice vector\" , & & line , token , filename ( unit ), lnum , \"expected real value\" ) return end if if ( coord ( 3 ) < 1 ) then call io_error ( error , \"Invalid helical axis rotation order\" , & & line , token , filename ( unit ), lnum , \"expected positive value\" ) return end if ! Store helical axis in *first* lattice vector, however it is not an actual ! lattice vector as on would expect but a screw axis lattice (:, 1 ) = [ coord ( 1 ) * aatoau , coord ( 2 ) * pi / 18 0.0_wp , coord ( 3 )] end if if ( any ( periodic )) then xyz (:, :) = xyz - spread ( origin , 2 , natoms ) end if info = structure_info ( cartesian = cartesian ) call new ( mol , sym , xyz , lattice = lattice , periodic = periodic , info = info ) contains subroutine advance_line ( unit , line , pos , num , stat ) integer , intent ( in ) :: unit integer , intent ( out ) :: pos integer , intent ( inout ) :: num character ( len = :), allocatable , intent ( out ) :: line integer , intent ( out ) :: stat integer :: ihash stat = 0 do while ( stat == 0 ) call next_line ( unit , line , pos , num , stat ) ihash = index ( line , '#' ) if ( ihash > 0 ) line = line (: ihash - 1 ) if ( len_trim ( line ) > 0 ) exit end do line = trim ( adjustl ( line )) end subroutine advance_line end subroutine read_genformat end module mctc_io_read_genformat","tags":"","loc":"sourcefile/genformat.f90.html"},{"title":"genformat.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_genformat use mctc_env_accuracy , only : wp use mctc_io_constants , only : pi use mctc_io_convert , only : autoaa use mctc_io_math , only : matinv_3x3 use mctc_io_symbols , only : to_symbol use mctc_io_structure , only : structure_type implicit none private public :: write_genformat contains subroutine write_genformat ( mol , unit ) class ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer :: iat , izp real ( wp ), parameter :: zero3 ( 3 ) = 0.0_wp real ( wp ), allocatable :: inv_lat (:, :) real ( wp ), allocatable :: abc (:, :) logical :: helical helical = . false . write ( unit , '(i0, 1x)' , advance = 'no' ) mol % nat if (. not . any ( mol % periodic )) then write ( unit , '(\"C\")' ) ! cluster else helical = count ( mol % periodic ) == 1 . and . mol % periodic ( 3 ) . and . size ( mol % lattice , 2 ) == 1 if ( helical ) then write ( unit , '(\"H\")' ) ! helical else if ( mol % info % cartesian ) then write ( unit , '(\"S\")' ) ! supercell else write ( unit , '(\"F\")' ) ! fractional endif end if endif do izp = 1 , mol % nid write ( unit , '(1x, a)' , advance = 'no' ) trim ( mol % sym ( izp )) enddo write ( unit , '(a)' ) if (. not . any ( mol % periodic ) . or . mol % info % cartesian ) then ! now write the cartesian coordinates do iat = 1 , mol % nat write ( unit , '(2i5, 3es24.14)' ) iat , mol % id ( iat ), mol % xyz (:, iat ) * autoaa enddo else inv_lat = matinv_3x3 ( mol % lattice ) abc = matmul ( inv_lat , mol % xyz ) ! now write the fractional coordinates do iat = 1 , mol % nat write ( unit , '(2i5, 3es24.15)' ) iat , mol % id ( iat ), abc (:, iat ) enddo endif if ( any ( mol % periodic )) then write ( unit , '(3f20.14)' ) zero3 ! write the lattice parameters if ( helical ) then write ( unit , '(2f20.14,1x,i0)' ) & & mol % lattice ( 1 , 1 ) * autoaa , mol % lattice ( 2 , 1 ) * 18 0.0_wp / pi , nint ( mol % lattice ( 3 , 1 )) else write ( unit , '(3f20.14)' ) mol % lattice (:, :) * autoaa end if endif end subroutine write_genformat end module mctc_io_write_genformat","tags":"","loc":"sourcefile/genformat.f90~2.html"},{"title":"filetype.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> File type support module mctc_io_filetype implicit none private public :: filetype , get_filetype !> Possible file types type :: enum_filetype !> Unknown file type integer :: unknown = 0 !> xyz-format integer :: xyz = 1 !> Turbomole coordinate format integer :: tmol = 2 !> mol-format integer :: molfile = 3 !> Vasp coordinate input integer :: vasp = 4 !> Protein database format integer :: pdb = 5 !> Structure data format integer :: sdf = 6 !> GenFormat of DFTB+ integer :: gen = 7 !> Gaussian external format integer :: gaussian = 8 !> QCSchema JSON file integer :: qcschema = 9 !> FHI-aims geometry.in format integer :: aims = 10 !> Q-Chem molecule format integer :: qchem = 11 !> Chemical JSON format (avogadro) integer :: cjson = 12 end type enum_filetype !> File type enumerator type ( enum_filetype ), parameter :: filetype = enum_filetype () contains elemental function get_filetype ( file ) result ( ftype ) !> Name of the file character ( len =* ), intent ( in ) :: file !> File type from extension integer :: ftype integer :: iext , isep ftype = filetype % unknown iext = index ( file , '.' , back = . true .) isep = scan ( file , '\\/' , back = . true .) if ( iext > isep . and . iext > 0 ) then select case ( to_lower ( file ( iext + 1 :))) case ( 'coord' , 'tmol' ) ftype = filetype % tmol case ( 'xyz' , 'log' ) ftype = filetype % xyz case ( 'mol' ) ftype = filetype % molfile case ( 'sdf' ) ftype = filetype % sdf case ( 'poscar' , 'contcar' , 'vasp' ) ftype = filetype % vasp case ( 'pdb' ) ftype = filetype % pdb case ( 'gen' ) ftype = filetype % gen case ( 'ein' ) ftype = filetype % gaussian case ( 'json' ) ftype = filetype % qcschema case ( 'cjson' ) ftype = filetype % cjson case ( 'qchem' ) ftype = filetype % qchem end select if ( ftype /= filetype % unknown ) return else iext = len ( file ) + 1 end if if ( iext > isep ) then if ( file ( isep + 1 :) == 'geometry.in' ) then ftype = filetype % aims end if select case ( to_lower ( file ( isep + 1 : iext - 1 ))) case ( 'geometry.in' ) ftype = filetype % aims case ( 'coord' ) ftype = filetype % tmol case ( 'poscar' , 'contcar' ) ftype = filetype % vasp end select end if end function get_filetype !> Convert input string to lowercase elemental function to_lower ( str ) result ( lcstr ) !> Input string character ( len =* ), intent ( in ) :: str !> Lowercase version of string character ( len = len ( str )) :: lcstr integer :: ilen , iquote , i , iav , iqc integer , parameter :: offset = iachar ( 'A' ) - iachar ( 'a' ) ilen = len ( str ) iquote = 0 lcstr = str do i = 1 , ilen iav = iachar ( str ( i : i )) if ( iquote == 0 . and . ( iav == 34 . or . iav == 39 )) then iquote = 1 iqc = iav cycle end if if ( iquote == 1 . and . iav == iqc ) then iquote = 0 cycle end if if ( iquote == 1 ) cycle if ( iav >= iachar ( 'A' ) . and . iav <= iachar ( 'Z' )) then lcstr ( i : i ) = achar ( iav - offset ) else lcstr ( i : i ) = str ( i : i ) end if end do end function to_lower end module mctc_io_filetype","tags":"","loc":"sourcefile/filetype.f90.html"},{"title":"constants.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Numerical constants module mctc_io_constants use mctc_env_accuracy , only : wp use mctc_io_codata2018 , only : planck_constant , speed_of_light_in_vacuum , & & boltzmann_constant , avogadro_constant , elementary_charge , fine_structure_constant , & & electron_mass implicit none private public :: pi , codata !> Ratio between a circles diameter and its circumfence real ( wp ), parameter :: pi = 3.1415926535897932384626433832795029_wp !> Natural constants defining the SI unit base type :: enum_codata !> Planck's constant real ( wp ) :: h = planck_constant !> Speed of light in vacuum real ( wp ) :: c = speed_of_light_in_vacuum !> Boltzmann's constant real ( wp ) :: kb = boltzmann_constant !> Avogadro's number real ( wp ) :: NA = avogadro_constant !> Elementary charge real ( wp ) :: e = elementary_charge !> fine structure constant (CODATA2018) real ( wp ) :: alpha = fine_structure_constant !> electron rest mass real ( wp ) :: me = electron_mass end type enum_codata !> Actual collection of natural constants type ( enum_codata ), parameter :: codata = enum_codata () end module mctc_io_constants","tags":"","loc":"sourcefile/constants.f90.html"},{"title":"pdb.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_pdb use mctc_env_accuracy , only : wp use mctc_io_convert , only : autoaa use mctc_io_structure , only : structure_type implicit none private public :: write_pdb contains subroutine write_pdb ( mol , unit , number ) type ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer , intent ( in ), optional :: number character ( len = 6 ) :: w1 character ( len = 4 ) :: sym character ( len = 2 ) :: a_charge character ( len = 1 ) :: last_chain logical :: last_het integer :: offset , iat , jat real ( wp ) :: xyz ( 3 ) character ( len =* ), parameter :: pdb_format = & & '(a6,i5,1x,a4,a1,a3,1x,a1,i4,a1,3x,3f8.3,2f6.2,6x,a4,a2,a2)' if ( present ( number )) write ( unit , '(\"MODEL \",4x,i4)' ) number if ( allocated ( mol % pdb )) then offset = 0 last_chain = mol % pdb ( 1 )% chains last_het = mol % pdb ( 1 )% het do iat = 1 , mol % nat ! handle the terminator if ( mol % pdb ( iat )% het . neqv . last_het ) then write ( unit , '(\"TER   \",i5,6x,a3,1x,a1,i4)' ) iat + offset , & & mol % pdb ( iat - 1 )% residue , last_chain , mol % pdb ( iat )% residue_number last_het = . not . last_het last_chain = mol % pdb ( iat )% chains offset = offset + 1 else if ( mol % pdb ( iat )% chains /= last_chain ) then write ( unit , '(\"TER   \",i5,6x,a3,1x,a1,i4)' ) iat + offset , & & mol % pdb ( iat - 1 )% residue , last_chain , mol % pdb ( iat )% residue_number last_chain = mol % pdb ( iat )% chains offset = offset + 1 endif jat = iat + offset if ( mol % pdb ( iat )% het ) then w1 = \"HETATM\" else w1 = \"ATOM  \" endif sym = adjustr ( mol % sym ( mol % id ( iat ))( 1 : 2 )) xyz = mol % xyz (:, iat ) * autoaa if ( mol % pdb ( iat )% charge < 0 ) then write ( a_charge , '(i1,\"-\")' ) abs ( mol % pdb ( iat )% charge ) else if ( mol % pdb ( iat )% charge > 0 ) then write ( a_charge , '(i1,\"+\")' ) abs ( mol % pdb ( iat )% charge ) else a_charge = '  ' endif write ( unit , pdb_format ) & & w1 , jat , mol % pdb ( iat )% name , mol % pdb ( iat )% loc , & & mol % pdb ( iat )% residue , mol % pdb ( iat )% chains , mol % pdb ( iat )% residue_number , & & mol % pdb ( iat )% code , xyz , 1.0_wp , 0.0_wp , mol % pdb ( iat )% segid , & & sym , a_charge enddo else do iat = 1 , mol % nat w1 = \"HETATM\" sym = adjustr ( mol % sym ( mol % id ( iat ))( 1 : 2 )) xyz = mol % xyz (:, iat ) * autoaa a_charge = '  ' write ( unit , pdb_format ) & & w1 , iat , sym , \" \" , & & \"UNK\" , \"A\" , 1 , \" \" , xyz , 1.0_wp , 0.0_wp , \"    \" , & & sym , \"  \" enddo end if if ( present ( number )) then write ( unit , '(\"ENDMDL\")' ) else write ( unit , '(\"END\")' ) endif end subroutine write_pdb end module mctc_io_write_pdb","tags":"","loc":"sourcefile/pdb.f90.html"},{"title":"pdb.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_pdb use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type use mctc_io_convert , only : aatoau use mctc_io_resize , only : resize use mctc_io_symbols , only : to_number , symbol_length use mctc_io_structure , only : structure_type , new use mctc_io_structure_info , only : pdb_data , resize use mctc_io_utils , only : next_line , token_type , next_token , io_error , filename , & read_token , to_string implicit none private public :: read_pdb contains subroutine read_pdb ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer , parameter :: p_initial_size = 1000 ! this is going to be a protein integer :: iatom , jatom , iresidue , try , stat , atom_type , pos , lnum real ( wp ) :: occ , temp , coords ( 3 ) real ( wp ), allocatable :: xyz (:,:) type ( token_type ) :: token character ( len = 4 ) :: a_charge character ( len = :), allocatable :: line character ( len = symbol_length ), allocatable :: sym (:) type ( pdb_data ), allocatable :: pdb (:) allocate ( sym ( p_initial_size ), source = repeat ( ' ' , symbol_length )) allocate ( xyz ( 3 , p_initial_size ), source = 0.0_wp ) allocate ( pdb ( p_initial_size ), source = pdb_data ()) iatom = 0 iresidue = 0 stat = 0 do while ( stat == 0 ) call next_line ( unit , line , pos , lnum , stat ) if ( index ( line , 'END' ) == 1 ) exit if ( index ( line , 'ATOM' ) == 1 . or . index ( line , 'HETATM' ) == 1 ) then if ( iatom >= size ( xyz , 2 )) call resize ( xyz ) if ( iatom >= size ( sym )) call resize ( sym ) if ( iatom >= size ( pdb )) call resize ( pdb ) iatom = iatom + 1 pdb ( iatom )% het = index ( line , 'HETATM' ) == 1 if ( len ( line ) >= 78 ) then ! a4: 13:16, a1: 17:17, a3: 18:20, a1: 22:22 ! a1: 27:27, a4: 73:76, a2: 77:78, a2: 79:80 pdb ( iatom )% name = line ( 13 : 16 ) pdb ( iatom )% loc = line ( 17 : 17 ) pdb ( iatom )% residue = line ( 18 : 20 ) pdb ( iatom )% chains = line ( 22 : 22 ) pdb ( iatom )% code = line ( 27 : 27 ) pdb ( iatom )% segid = line ( 72 : 74 ) sym ( iatom ) = line ( 77 : 78 ) else token = token_type ( len ( line ) + 1 , len ( line ) + 1 ) call io_error ( error , \"Too few entries provided in record\" , & & line , token , filename ( unit ), lnum , \"record too short\" ) return end if if ( len ( line ) >= 80 ) then a_charge = line ( 79 : 80 ) else a_charge = \"\" end if if ( stat == 0 ) then ! i5: 7-11 token = token_type ( 7 , 11 ) call read_token ( line , token , jatom , stat ) end if if ( stat == 0 ) then ! i4: 23-26 token = token_type ( 23 , 26 ) call read_token ( line , token , pdb ( iatom )% residue_number , stat ) end if if ( stat == 0 ) then ! f8: 31-38 token = token_type ( 31 , 38 ) call read_token ( line , token , coords ( 1 ), stat ) end if if ( stat == 0 ) then ! f8: 39-46 token = token_type ( 39 , 46 ) call read_token ( line , token , coords ( 2 ), stat ) end if if ( stat == 0 ) then ! f8: 47-54 token = token_type ( 47 , 54 ) call read_token ( line , token , coords ( 3 ), stat ) end if if ( stat == 0 ) then ! f6: 55-60 token = token_type ( 55 , 60 ) call read_token ( line , token , occ , stat ) end if if ( stat == 0 ) then ! f6: 61-66 token = token_type ( 60 , 66 ) call read_token ( line , token , temp , stat ) end if if ( stat /= 0 ) then call io_error ( error , \"Cannot read coordinates from record\" , & & line , token , filename ( unit ), lnum , \"unexpected value\" ) return end if xyz (:, iatom ) = coords * aatoau atom_type = to_number ( sym ( iatom )) if ( atom_type == 0 ) then try = scan ( pdb ( iatom )% name , 'HCNOSPF' ) if ( try > 0 ) sym ( iatom ) = pdb ( iatom )% name ( try : try ) // ' ' pdb ( iatom )% charge = 0 else read ( a_charge ( 1 : 1 ), * , iostat = stat ) pdb ( iatom )% charge if ( stat /= 0 ) then stat = 0 pdb ( iatom )% charge = 0 else if ( a_charge ( 2 : 2 ) == '-' ) pdb ( iatom )% charge = - pdb ( iatom )% charge end if end if if ( to_number ( sym ( iatom )) == 0 ) then call io_error ( error , \"Cannot map symbol to atomic number\" , & & line , token_type ( 77 , 78 ), filename ( unit ), lnum , \"unknown element\" ) return end if end if end do call new ( self , sym (: iatom ), xyz (:, : iatom )) self % pdb = pdb (: iatom ) self % charge = sum ( pdb (: iatom )% charge ) end subroutine read_pdb end module mctc_io_read_pdb","tags":"","loc":"sourcefile/pdb.f90~2.html"},{"title":"convert.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Conversion factors module mctc_io_convert use mctc_env_accuracy , only : wp use mctc_io_constants , only : pi , codata implicit none private !> Reduced Planck's constant real ( wp ), parameter :: hbar = codata % h / ( 2.0_wp * pi ) ! J·s = kg·m²·s⁻¹ !> Bohr radius real ( wp ), parameter :: bohr = hbar / ( codata % me * codata % c * codata % alpha ) ! m !> Hartree energy real ( wp ), parameter :: hartree = codata % me * codata % c ** 2 * codata % alpha ** 2 ! J = kg·m²·s⁻² !> Conversion factor from bohr to Ångström real ( wp ), public , parameter :: autoaa = bohr * 1e10_wp !> Conversion factor from Ångström to bohr real ( wp ), public , parameter :: aatoau = 1.0_wp / autoaa !> Conversion factor from hartree to electron volts real ( wp ), public , parameter :: autoeV = hartree / codata % e !> Conversion factor from electron volts to hartree real ( wp ), public , parameter :: evtoau = 1.0_wp / autoev !> Conversion factor between calorie and joule real ( wp ), public , parameter :: caltoj = 4.184_wp !> Conversion factor between joule and calorie real ( wp ), public , parameter :: jtocal = 1.0_wp / caltoj !> Conversion from hartree to kJ/mol real ( wp ), public , parameter :: autokj = hartree * codata % na * 1e-3_wp !> Conversion from kJ/mol to hartree real ( wp ), public , parameter :: kjtoau = 1.0_wp / autokj !> Conversion from hartree to kcal/mol real ( wp ), public , parameter :: autokcal = autokJ * Jtocal !> Conversion from kcal/mol to hartree real ( wp ), public , parameter :: kcaltoau = 1.0_wp / autokcal !> Conversion from hartree to reciprocal centimeters real ( wp ), public , parameter :: autorcm = hartree / ( codata % h * codata % c ) * 1e-2_wp !> Conversion from reciprocal centimeters to hartree real ( wp ), public , parameter :: rcmtoau = 1.0_wp / autorcm !> Conversion from hartree to nanometers (wavelength) real ( wp ), public , parameter :: autonm = codata % h * codata % c / hartree * 1e+9_wp !> Conversion from nanometers (wavelength) to hartree real ( wp ), public , parameter :: nmtoau = 1.0_wp / autonm !> Conversion from electron mass (a.u.) to kg real ( wp ), public , parameter :: autokg = codata % me !> Conversion from kg to electron mass (a.u.) real ( wp ), public , parameter :: kgtoau = 1.0_wp / autokg !> Molecular mass per mole (g/mol) to electron mass (a.u.) real ( wp ), public , parameter :: autogmol = codata % me * codata % na * 1e+3_wp !> Electron mass (a.u.) to molecular mass per mole (g/mol) real ( wp ), public , parameter :: gmoltoau = 1.0_wp / autogmol !> Molecular mass per mole (g/mol) to kg real ( wp ), public , parameter :: gmoltokg = gmoltoau * autokg !> kg to molecular mass per mole (g/mol) real ( wp ), public , parameter :: kgtogmol = 1.0_wp / gmoltokg !> Coulomb to atomic charge units real ( wp ), public , parameter :: autoc = codata % e !> Atomic charge units to Coulomb real ( wp ), public , parameter :: ctoau = 1.0_wp / autoc end module mctc_io_convert","tags":"","loc":"sourcefile/convert.f90.html"},{"title":"accuracy.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Numerical storage size parameters for real and integer values module mctc_env_accuracy implicit none public !> Single precision real numbers integer , parameter :: sp = selected_real_kind ( 6 ) !> Double precision real numbers integer , parameter :: dp = selected_real_kind ( 15 ) !> Wanted precision integer , parameter :: wp = dp !> Char length for integers integer , parameter :: i1 = selected_int_kind ( 2 ) !> Short length for integers integer , parameter :: i2 = selected_int_kind ( 4 ) !> Length of default integers integer , parameter :: i4 = selected_int_kind ( 9 ) !> Long length for integers integer , parameter :: i8 = selected_int_kind ( 18 ) end module mctc_env_accuracy","tags":"","loc":"sourcefile/accuracy.f90.html"},{"title":"ctfile.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_ctfile use mctc_env_accuracy , only : wp use mctc_io_convert , only : autoaa use mctc_io_structure , only : structure_type implicit none private public :: write_molfile , write_sdf contains subroutine write_sdf ( self , unit , energy , gnorm ) class ( structure_type ), intent ( in ) :: self integer , intent ( in ) :: unit real ( wp ), intent ( in ), optional :: energy real ( wp ), intent ( in ), optional :: gnorm !type(tb_buffer) :: sd_values character ( len = :), allocatable :: line character ( len =* ), parameter :: sd_format = & & '(\"> <\", a, \">\", /, f20.12, /)' call write_molfile ( self , unit ) !   sd_values = self%info !   call sd_values%reset !   do while(sd_values%next()) !      call sd_values%getline(line) !      write(unit, '(a)') line !   enddo if ( present ( energy )) then write ( unit , sd_format ) \"total energy / Eh\" , energy endif if ( present ( gnorm )) then write ( unit , sd_format ) \"gradient norm / Eh/a0\" , gnorm endif write ( unit , '(\"\")' ) end subroutine write_sdf subroutine write_molfile ( self , unit , comment_line ) class ( structure_type ), intent ( in ) :: self integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: comment_line integer , parameter :: list4 ( 4 ) = 0 integer :: iatom , ibond , iatoms ( 3 ), list12 ( 12 ) logical :: has_sdf_data integer , parameter :: charge_to_ccc ( - 3 : 3 ) = [ 7 , 6 , 5 , 0 , 3 , 2 , 1 ] character ( len = 8 ) :: date character ( len = 10 ) :: time call date_and_time ( date , time ) if ( present ( comment_line )) then write ( unit , '(a)' ) comment_line else if ( allocated ( self % comment )) then write ( unit , '(a)' ) self % comment else write ( unit , '(a)' ) end if end if write ( unit , '(2x, 3x, 5x, 3a2, a4, \"3D\")' ) & & date ( 5 : 6 ), date ( 7 : 8 ), date ( 3 : 4 ), time (: 4 ) write ( unit , '(a)' ) write ( unit , '(3i3, 3x, 2i3, 12x, i3, 1x, a5)' ) & & self % nat , self % nbd , 0 , 0 , 0 , 999 , 'V2000' has_sdf_data = allocated ( self % sdf ) do iatom = 1 , self % nat if ( has_sdf_data ) then list12 = [ self % sdf ( iatom )% isotope , 0 , 0 , 0 , 0 , self % sdf ( iatom )% valence , & & 0 , 0 , 0 , 0 , 0 , 0 ] else list12 = 0 endif write ( unit , '(3f10.4, 1x, a3, i2, 11i3)' ) & & self % xyz (:, iatom ) * autoaa , self % sym ( self % id ( iatom )), list12 enddo if ( self % nbd > 0 ) then if ( size ( self % bond , 1 ) > 2 ) then do ibond = 1 , self % nbd write ( unit , '(7i3)' ) self % bond (: 3 , ibond ), list4 end do else do ibond = 1 , self % nbd write ( unit , '(7i3)' ) self % bond (: 2 , ibond ), 1 , list4 end do end if end if if ( has_sdf_data ) then if ( sum ( self % sdf % charge ) /= nint ( self % charge )) then write ( unit , '(a, *(i3, 1x, i3, 1x, i3))' ) \"M  CHG\" , 1 , 1 , nint ( self % charge ) else do iatom = 1 , self % nat if ( self % sdf ( iatom )% charge /= 0 ) then write ( unit , '(a, *(i3, 1x, i3, 1x, i3))' ) & & \"M  CHG\" , 1 , iatom , self % sdf ( iatom )% charge end if end do end if else if ( nint ( self % charge ) /= 0 ) then write ( unit , '(a, *(i3, 1x, i3, 1x, i3))' ) \"M  CHG\" , 1 , 1 , nint ( self % charge ) end if end if write ( unit , '(a)' ) \"M  END\" end subroutine write_molfile end module mctc_io_write_ctfile","tags":"","loc":"sourcefile/ctfile.f90.html"},{"title":"ctfile.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_ctfile use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error use mctc_io_convert , only : aatoau use mctc_io_structure , only : structure_type , new use mctc_io_structure_info , only : sdf_data , structure_info use mctc_io_symbols , only : to_number , symbol_length use mctc_io_utils , only : next_line , token_type , next_token , io_error , filename , & read_token , read_next_token , to_string implicit none private public :: read_sdf , read_molfile contains subroutine read_sdf ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: line integer :: stat , lnum , pos call read_molfile ( self , unit , error ) if ( allocated ( error )) return lnum = 0 stat = 0 do while ( stat == 0 ) call next_line ( unit , line , pos , lnum , stat ) if ( index ( line , '' ) == 1 ) exit end do if ( stat /= 0 ) then call fatal_error ( error , \"Failed while reading SDF key-value pairs\" ) return end if end subroutine read_sdf subroutine read_molfile ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: line character ( len = :), allocatable :: comment integer :: stat , lnum , pos integer :: number_of_atoms , number_of_bonds integer :: list7 ( 7 ), list12 ( 12 ) real ( wp ) :: x , y , z character ( len = 2 ) :: sdf_dim logical :: two_dim , v3k type ( token_type ) :: token lnum = 0 two_dim = . false . call next_line ( unit , comment , pos , lnum , stat ) call next_line ( unit , line , pos , lnum , stat ) read ( line , '(20x, a2)' , iostat = stat ) sdf_dim if ( stat == 0 ) then two_dim = sdf_dim == '2D' . or . sdf_dim == '2d' end if call next_line ( unit , line , pos , lnum , stat ) call next_line ( unit , line , pos , lnum , stat ) if ( stat == 0 ) then token = token_type ( 1 , 3 ) call read_token ( line , token , number_of_atoms , stat ) end if if ( stat == 0 ) then token = token_type ( 4 , 6 ) call read_token ( line , token , number_of_bonds , stat ) end if if ( stat /= 0 ) then call io_error ( error , \"Cannot read header of molfile\" , & & line , token , filename ( unit ), lnum , \"expected integer value\" ) return end if token = token_type ( 35 , 39 ) stat = 1 if ( len ( line ) >= 39 ) then v3k = line ( 35 : 39 ) == 'V3000' if ( line ( 35 : 39 ) == 'V2000' . or . v3k ) stat = 0 end if if ( stat /= 0 ) then call io_error ( error , \"Format version not supported\" , & & line , token , filename ( unit ), lnum , \"invalid format version\" ) return end if if (. not . v3k . and . number_of_atoms < 1 ) then call io_error ( error , \"Invalid number of atoms\" , & & line , token_type ( 1 , 3 ), filename ( unit ), lnum , \"expected positive integer\" ) return end if if ( v3k ) then call read_molfile_v3k ( self , unit , error ) else call read_molfile_v2k ( self , unit , number_of_atoms , number_of_bonds , error ) end if if ( allocated ( error )) return ! Attach additional meta data self % info % two_dimensional = two_dim if ( len ( comment ) > 0 ) self % comment = comment end subroutine read_molfile subroutine read_molfile_v2k ( self , unit , number_of_atoms , number_of_bonds , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Number of atoms from header integer , intent ( in ) :: number_of_atoms !> Number of bonds from header integer , intent ( in ) :: number_of_bonds !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: line integer :: i , iatom , jatom , ibond , btype , atomtype integer :: stat , length , charge ( 2 , 15 ), lnum , pos integer :: list7 ( 7 ), list12 ( 12 ) real ( wp ) :: x , y , z character ( len = 3 ) :: symbol integer , parameter :: ccc_to_charge ( 0 : 7 ) = [ 0 , + 3 , + 2 , + 1 , 0 , - 1 , - 2 , - 3 ] type ( token_type ) :: token character ( len = symbol_length ), allocatable :: sym (:) type ( sdf_data ), allocatable :: sdf (:) type ( structure_info ) :: info real ( wp ), allocatable :: xyz (:, :) integer , allocatable :: bond (:, :) lnum = 4 allocate ( sdf ( number_of_atoms )) allocate ( xyz ( 3 , number_of_atoms )) allocate ( sym ( number_of_atoms )) do iatom = 1 , number_of_atoms call next_line ( unit , line , pos , lnum , stat ) if ( stat == 0 ) then token = token_type ( 1 , 10 ) call read_token ( line , token , x , stat ) end if if ( stat == 0 ) then token = token_type ( 11 , 20 ) call read_token ( line , token , y , stat ) end if if ( stat == 0 ) then token = token_type ( 21 , 30 ) call read_token ( line , token , z , stat ) end if if ( len ( line ) >= 34 ) then symbol = line ( 32 : 34 ) end if if ( stat == 0 ) then token = token_type ( 35 , 36 ) call read_token ( line , token , list12 ( 1 ), stat ) end if list12 (:) = 0 do i = 1 , 11 if ( stat == 0 ) then if (( 36 + i * 3 ) > len ( line )) exit token = token_type ( 34 + i * 3 , 36 + i * 3 ) call read_token ( line , token , list12 ( i + 1 ), stat ) end if end do if ( stat /= 0 ) then call io_error ( error , \"Cannot read coordinates from connection table\" , & & line , token , filename ( unit ), lnum , \"unexpected value\" ) return end if atomtype = to_number ( symbol ) if ( atomtype == 0 ) then call io_error ( error , \"Cannot map symbol to atomic number\" , & & line , token_type ( 32 , 34 ), filename ( unit ), lnum , \"unknown element\" ) return end if xyz (:, iatom ) = [ x , y , z ] * aatoau sym ( iatom ) = symbol sdf ( iatom )% isotope = list12 ( 1 ) sdf ( iatom )% charge = ccc_to_charge ( list12 ( 2 )) ! drop doublet radical sdf ( iatom )% hydrogens = list12 ( 4 ) sdf ( iatom )% valence = list12 ( 6 ) end do allocate ( bond ( 3 , number_of_bonds )) do ibond = 1 , number_of_bonds call next_line ( unit , line , pos , lnum , stat ) list7 (:) = 0 do i = 1 , 7 if ( stat == 0 ) then if (( i * 3 ) > len ( line )) exit token = token_type ( i * 3 - 2 , i * 3 ) call read_token ( line , token , list7 ( i ), stat ) end if end do if ( stat /= 0 ) then call io_error ( error , \"Cannot read topology from connection table\" , & & line , token , filename ( unit ), lnum , \"unexpected value\" ) return end if iatom = list7 ( 1 ) jatom = list7 ( 2 ) btype = list7 ( 3 ) bond (:, ibond ) = [ iatom , jatom , btype ] end do do while ( stat == 0 ) call next_line ( unit , line , pos , lnum , stat ) if ( index ( line , 'M  END' ) == 1 ) exit if ( index ( line , 'M  CHG' ) == 1 ) then token = token_type ( 7 , 9 ) read ( line ( 7 : 9 ), * ) length call read_token ( line , token , length , stat ) if ( stat == 0 ) then do i = 1 , length if ( stat /= 0 ) exit token = token_type ( 3 + i * 8 , 5 + i * 8 ) call read_token ( line , token , charge ( 1 , i ), stat ) if ( charge ( 1 , i ) > number_of_atoms . or . charge ( 1 , i ) < 1 ) stat = 1 if ( stat /= 0 ) exit token = token_type ( 7 + i * 8 , 9 + i * 8 ) call read_token ( line , token , charge ( 2 , i ), stat ) end do end if if ( stat /= 0 ) then call io_error ( error , \"Cannot read charges\" , & & line , token , filename ( unit ), lnum , \"expected integer value\" ) return end if do i = 1 , length sdf ( charge ( 1 , i ))% charge = charge ( 2 , i ) end do end if end do if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read connection table\" ) return end if info = structure_info ( missing_hydrogen = any ( sdf % hydrogens > 1 )) call new ( self , sym , xyz , charge = real ( sum ( sdf % charge ), wp ), info = info , bond = bond ) call move_alloc ( sdf , self % sdf ) end subroutine read_molfile_v2k subroutine read_molfile_v3k ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: line , group integer :: i , iatom , jatom , ibond , btype , atomtype , aamap , equal integer :: stat , charge ( 2 , 15 ), lnum , pos , number_of_atoms , number_of_bonds , dummy real ( wp ) :: x , y , z character ( len = 3 ) :: symbol integer , parameter :: ccc_to_charge ( 0 : 7 ) = [ 0 , + 3 , + 2 , + 1 , 0 , - 1 , - 2 , - 3 ] type ( token_type ) :: token , tsym character ( len = symbol_length ), allocatable :: sym (:) type ( sdf_data ), allocatable :: sdf (:) type ( structure_info ) :: info real ( wp ), allocatable :: xyz (:, :) integer , allocatable :: bond (:, :) lnum = 4 call next_v30 ( unit , line , pos , lnum , stat ) do while ( stat == 0 ) call next_token ( line , pos , token ) if ( slice ( line , token % first , token % last ) == 'BEGIN' ) then call next_token ( line , pos , token ) if ( slice ( line , token % first , token % last ) == 'CTAB' ) exit end if call next_v30 ( unit , line , pos , lnum , stat ) end do if ( stat /= 0 ) then call io_error ( error , \"Cannot read connection table\" , & & line , token_type ( 0 , 0 ), filename ( unit ), lnum , \"CTAB header not found\" ) return end if call next_v30 ( unit , line , pos , lnum , stat ) if ( stat == 0 ) then call next_token ( line , pos , token ) if ( slice ( line , token % first , token % last ) /= 'COUNTS' ) then call io_error ( error , \"Cannot read connection table\" , & & line , token , filename ( unit ), lnum , \"COUNTS header not found\" ) return end if end if if ( stat == 0 ) then call read_next_token ( line , pos , token , number_of_atoms , stat ) tsym = token end if if ( stat == 0 ) & call read_next_token ( line , pos , token , number_of_bonds , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , dummy , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , dummy , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , dummy , stat ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read connection table counts\" , & & line , token , filename ( unit ), lnum , \"expected integer value\" ) return end if if ( number_of_atoms < 1 ) then call io_error ( error , \"Invalid number of atoms\" , & & line , tsym , filename ( unit ), lnum , \"expected positive integer\" ) return end if allocate ( sdf ( number_of_atoms )) allocate ( xyz ( 3 , number_of_atoms )) allocate ( sym ( number_of_atoms )) allocate ( bond ( 3 , number_of_bonds )) call next_v30 ( unit , line , pos , lnum , stat ) do while ( stat == 0 ) call next_token ( line , pos , token ) if ( slice ( line , token % first , token % last ) == 'END' ) exit if ( slice ( line , token % first , token % last ) == 'BEGIN' ) then call next_token ( line , pos , token ) group = slice ( line , token % first , token % last ) select case ( group ) case ( \"ATOM\" ) do iatom = 1 , number_of_atoms call next_v30 ( unit , line , pos , lnum , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , dummy , stat ) if ( stat == 0 ) & call next_token ( line , pos , tsym ) if ( stat == 0 ) & call read_next_token ( line , pos , token , x , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , y , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , z , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , aamap , stat ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read coordinates\" , & & line , token , filename ( unit ), lnum , \"unexpected value\" ) return end if if ( aamap > 0 ) then call io_error ( error , \"Mapping atoms is not supported\" , & & line , token , filename ( unit ), lnum , \"unsupported value\" ) return end if tsym % last = min ( tsym % last , tsym % first + symbol_length - 1 ) sym ( iatom ) = slice ( line , tsym % first , tsym % last ) if ( to_number ( sym ( iatom )) == 0 ) then call io_error ( error , \"Cannot map symbol to atomic number\" , & & line , tsym , filename ( unit ), lnum , \"unknown element\" ) return end if xyz (:, iatom ) = [ x , y , z ] * aatoau sdf ( iatom ) = sdf_data () do while ( pos < len ( line )) call next_token ( line , pos , token ) equal = index ( slice ( line , token % first , token % last ), '=' ) + token % first - 1 if ( equal > token % first ) then select case ( slice ( line , token % first , equal - 1 )) case ( \"CHG\" ) token % first = equal + 1 call read_token ( line , token , sdf ( iatom )% charge , stat ) case ( \"VAL\" ) token % first = equal + 1 call read_token ( line , token , sdf ( iatom )% valence , stat ) case ( \"HCOUNT\" ) token % first = equal + 1 call read_token ( line , token , sdf ( iatom )% hydrogens , stat ) end select end if if ( stat /= 0 ) then call io_error ( error , \"Cannot read atom properties\" , & & line , token , filename ( unit ), lnum , \"unexpected value\" ) return end if end do end do call next_v30 ( unit , line , pos , lnum , stat ) call next_token ( line , pos , token ) case ( \"BOND\" ) do ibond = 1 , number_of_bonds call next_v30 ( unit , line , pos , lnum , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , dummy , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , btype , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , iatom , stat ) if ( stat == 0 ) & call read_next_token ( line , pos , token , jatom , stat ) if ( stat /= 0 ) then call io_error ( error , \"Cannot read bond information\" , & & line , token , filename ( unit ), lnum , \"expected integer value\" ) return end if bond (:, ibond ) = [ iatom , jatom , btype ] end do call next_v30 ( unit , line , pos , lnum , stat ) call next_token ( line , pos , token ) case ( \"COLLECTION\" , \"SGROUP\" , \"OBJ3D\" ) do while ( stat == 0 ) call next_v30 ( unit , line , pos , lnum , stat ) call next_token ( line , pos , token ) if ( slice ( line , token % first , token % last ) == 'END' ) exit end do case default call io_error ( error , \"Cannot read connection table\" , & & line , token , filename ( unit ), lnum , \"Unknown entry found\" ) return end select if ( slice ( line , token % first , token % last ) /= 'END' ) then call io_error ( error , group // \" block is not terminated\" , & & line , token , filename ( unit ), lnum , \"expected END label\" ) return end if call next_token ( line , pos , token ) if ( slice ( line , token % first , token % last ) /= group ) then call io_error ( error , group // \" block is not terminated\" , & & line , token , filename ( unit ), lnum , \"expected \" // group // \" label\" ) return end if end if call next_v30 ( unit , line , pos , lnum , stat ) end do if ( slice ( line , token % first , token % last ) /= 'END' ) then call io_error ( error , \"Connection table is not terminated\" , & & line , token , filename ( unit ), lnum , \"expected END label\" ) return end if call next_token ( line , pos , token ) if ( slice ( line , token % first , token % last ) /= 'CTAB' ) then call io_error ( error , \"Connection table is not terminated\" , & & line , token , filename ( unit ), lnum , \"expected ATOM label\" ) return end if call next_v30 ( unit , line , pos , lnum , stat ) do while ( stat == 0 ) call next_token ( line , pos , token ) if ( slice ( line , token % first , token % last ) == 'END' ) exit end do if ( stat /= 0 ) then call io_error ( error , \"Connection table is not terminated\" , & & line , token , filename ( unit ), lnum , \"expected END label\" ) return end if info = structure_info ( missing_hydrogen = any ( sdf % hydrogens > 1 )) call new ( self , sym , xyz , charge = real ( sum ( sdf % charge ), wp ), info = info , bond = bond ) call move_alloc ( sdf , self % sdf ) end subroutine read_molfile_v3k function slice ( string , first , last ) character ( len =* ), intent ( in ), target :: string integer , intent ( in ) :: first , last character ( len = :), pointer :: slice slice => string ( max ( first , 1 ): min ( last , len ( string ))) end function slice subroutine next_v30 ( unit , line , pos , lnum , iostat , iomsg ) !> Formatted IO unit integer , intent ( in ) :: unit !> Line to read character ( len = :), allocatable , intent ( out ) :: line !> Current position in line integer , intent ( out ) :: pos !> Current line number integer , intent ( inout ) :: lnum !> Status of operation integer , intent ( out ) :: iostat !> Error message character ( len = :), allocatable , optional :: iomsg call next_line ( unit , line , pos , lnum , iostat , iomsg ) if ( iostat /= 0 ) return if ( index ( line , 'M  END' ) == 1 ) pos = 3 if ( index ( line , 'M  V30' ) == 1 ) pos = 6 end subroutine next_v30 end module mctc_io_read_ctfile","tags":"","loc":"sourcefile/ctfile.f90~2.html"},{"title":"read.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read use mctc_env_error , only : error_type , fatal_error use mctc_io_filetype , only : filetype , get_filetype use mctc_io_read_aims , only : read_aims use mctc_io_read_cjson , only : read_cjson use mctc_io_read_ctfile , only : read_molfile , read_sdf use mctc_io_read_gaussian , only : read_gaussian_external use mctc_io_read_genformat , only : read_genformat use mctc_io_read_qchem , only : read_qchem use mctc_io_read_qcschema , only : read_qcschema use mctc_io_read_pdb , only : read_pdb use mctc_io_read_turbomole , only : read_coord use mctc_io_read_vasp , only : read_vasp use mctc_io_read_xyz , only : read_xyz use mctc_io_structure , only : structure_type , new_structure implicit none private public :: read_structure public :: structure_reader , get_structure_reader interface read_structure module procedure :: read_structure_from_file module procedure :: read_structure_from_unit end interface read_structure abstract interface !> Read molecular structure data from formatted unit subroutine structure_reader ( self , unit , error ) import :: structure_type , error_type !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error end subroutine structure_reader end interface contains subroutine read_structure_from_file ( self , file , error , format ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> Name of the file to read character ( len =* ), intent ( in ) :: file !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> File type format hint integer , intent ( in ), optional :: format logical :: exist integer :: unit , stat , ftype inquire ( file = file , exist = exist ) if (. not . exist ) then call fatal_error ( error , \"File '\" // file // \"' cannot be found\" ) return end if open ( file = file , newunit = unit , status = 'old' , iostat = stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Cannot open '\" // file // \"'\" ) return end if if ( present ( format )) then ftype = format else ftype = get_filetype ( file ) end if call read_structure ( self , unit , ftype , error ) close ( unit ) end subroutine read_structure_from_file subroutine read_structure_from_unit ( self , unit , ftype , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> File type to read integer , intent ( in ) :: ftype !> Error handling type ( error_type ), allocatable , intent ( out ) :: error procedure ( structure_reader ), pointer :: reader call get_structure_reader ( reader , ftype ) if (. not . associated ( reader )) then call fatal_error ( error , \"Cannot read structure from unknown file format\" ) return end if call reader ( self , unit , error ) end subroutine read_structure_from_unit !> Retrieve reader for corresponding file type subroutine get_structure_reader ( reader , ftype ) !> Reader for the specified file type procedure ( structure_reader ), pointer , intent ( out ) :: reader !> File type to read integer , intent ( in ) :: ftype nullify ( reader ) select case ( ftype ) case ( filetype % xyz ) reader => read_xyz case ( filetype % molfile ) reader => read_molfile case ( filetype % qcschema ) reader => read_qcschema case ( filetype % cjson ) reader => read_cjson case ( filetype % pdb ) reader => read_pdb case ( filetype % gen ) reader => read_genformat case ( filetype % sdf ) reader => read_sdf case ( filetype % vasp ) reader => read_vasp case ( filetype % tmol ) reader => read_coord case ( filetype % gaussian ) reader => read_gaussian_external case ( filetype % aims ) reader => read_aims case ( filetype % qchem ) reader => read_qchem end select end subroutine get_structure_reader end module mctc_io_read","tags":"","loc":"sourcefile/read.f90.html"},{"title":"main.f90 – MCTC-library","text":"Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Example application using tool chain library. !> !> This program uses the [[read_structure]] and [[write_structure]] procedures !> to implement a structure converter. !> Usually, the input structure can be inferred by the name of the input file. !> To allow formats with non-standard extensions (because most geometry formats !> are not really standardized) additional hints can be passed by the command !> line to determine the read/write formats. !> !> To add support for piping standard input and standard output reading and !> writing from units is combined with the additional format hints. !> !> Additional filters or modifications can also be implemented in an intermediary !> step, this program implements an element symbol normalization. Other filters !> like folding back to central cells or removing lattice vector could be added !> in a similar manner. program main use , intrinsic :: iso_fortran_env , only : output_unit , error_unit , input_unit use mctc_env , only : error_type , fatal_error , get_argument , wp use mctc_io , only : structure_type , read_structure , write_structure , & & filetype , get_filetype , to_symbol use mctc_version , only : get_mctc_version implicit none character ( len =* ), parameter :: prog_name = \"mctc-convert\" character ( len = :), allocatable :: input , output , template , filename integer , allocatable :: input_format , output_format , template_format type ( structure_type ) :: mol type ( structure_type ), allocatable :: mol_template type ( error_type ), allocatable :: error logical :: normalize , read_dot_files integer :: charge , unpaired call get_arguments ( input , input_format , output , output_format , normalize , & & template , template_format , read_dot_files , error ) if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if if ( allocated ( template )) then allocate ( mol_template ) if ( template == \"-\" ) then if (. not . allocated ( template_format )) then template_format = merge ( output_format , filetype % xyz , allocated ( output_format )) end if call read_structure ( mol_template , input_unit , template_format , error ) else call read_structure ( mol_template , template , error , template_format ) end if if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if end if if ( input == \"-\" ) then if (. not . allocated ( input_format )) input_format = filetype % xyz call read_structure ( mol , input_unit , input_format , error ) else call read_structure ( mol , input , error , input_format ) if ( read_dot_files ) then charge = nint ( mol % charge ) if (. not . allocated ( error )) then filename = join ( dirname ( input ), \".CHRG\" ) if ( exists ( filename )) call read_file ( filename , charge , error ) end if mol % charge = charge unpaired = mol % uhf if (. not . allocated ( error )) then filename = join ( dirname ( input ), \".UHF\" ) if ( exists ( filename )) call read_file ( filename , unpaired , error ) end if mol % uhf = unpaired end if end if if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if if ( allocated ( mol_template )) then if ( mol % nat /= mol_template % nat ) then write ( error_unit , '(*(a, 1x))' ) & \"Number of atoms missmatch in\" , template , \"and\" , input error stop end if ! move_alloc can also move non-allocated objects call move_alloc ( mol_template % lattice , mol % lattice ) call move_alloc ( mol_template % periodic , mol % periodic ) call move_alloc ( mol_template % bond , mol % bond ) call move_alloc ( mol_template % comment , mol % comment ) call move_alloc ( mol_template % pdb , mol % pdb ) call move_alloc ( mol_template % sdf , mol % sdf ) end if if ( normalize ) then mol % sym = to_symbol ( mol % num ) end if if ( output == \"-\" ) then if (. not . allocated ( output_format )) output_format = filetype % xyz call write_structure ( mol , output_unit , output_format , error ) else call write_structure ( mol , output , error , output_format ) end if if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if contains subroutine help ( unit ) integer , intent ( in ) :: unit write ( unit , '(a, *(1x, a))' ) & \"Usage: \" // prog_name // \" [options] <input> <output>\" write ( unit , '(a)' ) & \"\" , & \"Read structure from input file and writes it to output file.\" , & \"The format is determined by the file extension or the format hint\" , & \"\" write ( unit , '(2x, a, t25, a)' ) & \"-i, --input <format>\" , \"Hint for the format of the input file\" , & \"-o, --output <format>\" , \"Hint for the format of the output file\" , & \"--normalize\" , \"Normalize all element symbols to capitalized format\" , & \"--template <file>\" , \"File to use as template to fill in meta data\" , & \"\" , \"(useful to add back SDF or PDB annotions)\" , & \"--template-format <format>\" , \"\" , \"\" , \"Hint for the format of the template file\" , & \"--ignore-dot-files\" , \"Do not read charge and spin from .CHRG and .UHF files\" , & \"--version\" , \"Print program version and exit\" , & \"--help\" , \"Show this help message\" write ( unit , '(a)' ) end subroutine help subroutine version ( unit ) integer , intent ( in ) :: unit character ( len = :), allocatable :: version_string call get_mctc_version ( string = version_string ) write ( unit , '(a, *(1x, a))' ) & & prog_name , \"version\" , version_string end subroutine version subroutine get_arguments ( input , input_format , output , output_format , normalize , & & template , template_format , read_dot_files , error ) !> Input file name character ( len = :), allocatable :: input !> Input file format integer , allocatable , intent ( out ) :: input_format !> Output file name character ( len = :), allocatable :: output !> Output file format integer , allocatable , intent ( out ) :: output_format !> Template file name character ( len = :), allocatable :: template !> Template file format integer , allocatable , intent ( out ) :: template_format !> Normalize element symbols logical , intent ( out ) :: normalize !> Read information from .CHRG and .UHF files logical , intent ( out ) :: read_dot_files !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: iarg , narg character ( len = :), allocatable :: arg normalize = . false . read_dot_files = . true . iarg = 0 narg = command_argument_count () do while ( iarg < narg ) iarg = iarg + 1 call get_argument ( iarg , arg ) select case ( arg ) case ( \"--help\" ) call help ( output_unit ) stop case ( \"--version\" ) call version ( output_unit ) stop case default if (. not . allocated ( input )) then call move_alloc ( arg , input ) cycle end if if (. not . allocated ( output )) then call move_alloc ( arg , output ) cycle end if call fatal_error ( error , \"Too many positional arguments present\" ) exit case ( \"-i\" , \"--input\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for input format\" ) exit end if if ( index ( arg , \".\" ) == 0 ) arg = \".\" // arg input_format = get_filetype ( arg ) case ( \"-o\" , \"--output\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for output format\" ) exit end if output_format = get_filetype ( \".\" // arg ) case ( \"--normalize\" ) normalize = . true . case ( \"--template\" ) iarg = iarg + 1 call get_argument ( iarg , template ) if (. not . allocated ( template )) then call fatal_error ( error , \"Missing argument for template file\" ) exit end if case ( \"--template-format\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for template format\" ) exit end if template_format = get_filetype ( \".\" // arg ) case ( \"--ignore-dot-files\" ) read_dot_files = . false . end select end do if (. not .( allocated ( input ). and .( allocated ( output )))) then if (. not . allocated ( error )) then call help ( output_unit ) error stop end if end if end subroutine get_arguments !> Extract dirname from path function dirname ( filename ) character ( len =* ), intent ( in ) :: filename character ( len = :), allocatable :: dirname dirname = filename ( 1 : scan ( filename , \"/\\\", back=.true.)) if (len_trim(dirname) == 0) dirname = \" . \" end function dirname !> Construct path by joining strings with os file separator function join(a1, a2) result(path) use mctc_env_system, only : is_windows character(len=*), intent(in) :: a1, a2 character(len=:), allocatable :: path character :: filesep if (is_windows()) then filesep = '\\' else filesep = '/' end if path = a1 // filesep // a2 end function join !> test if pathname already exists function exists(filename) character(len=*), intent(in) :: filename logical :: exists inquire(file=filename, exist=exists) end function exists subroutine read_file(filename, val, error) use mctc_io_utils, only : next_line, read_next_token, io_error, token_type character(len=*), intent(in) :: filename integer, intent(out) :: val type(error_type), allocatable, intent(out) :: error integer :: io, stat, lnum, pos type(token_type) :: token character(len=:), allocatable :: line lnum = 0 open(file=filename, newunit=io, status='old', iostat=stat) if (stat /= 0) then call fatal_error(error, \" Error : Could not open file '\"//filename//\"' \") return end if call next_line(io, line, pos, lnum, stat) if (stat == 0) & call read_next_token(line, pos, token, val, stat) if (stat /= 0) then call io_error(error, \" Cannot read value from file \", line, token, & filename, lnum, \" expected integer value \" ) return end if close ( io , iostat = stat ) end subroutine read_file end program main","tags":"","loc":"sourcefile/main.f90.html"},{"title":"Formats – MCTC-library","text":"This library supports reading and writing of the following formats: xyz with extensions Turbomole’s coord connection table files: molfile, structure data format Vasp’s POSCAR format a subset of PDB format DFTB+ general format Gaussian external format Chemical JSON format QCSchema JSON format FHI-aims geometry.in Q-Chem molecule format","tags":"","loc":"page/index.html"},{"title":"FHI-aims geometry.in format – MCTC-library","text":"Specification Format used by FHI-aims program.\nAtoms are specified by atom or atom_frac keyword followed by three real numbers and an character identifier.\nLattice parameters are given with the lattice_vector keyword followed by three real numbers. Example Caffeine molecule in xyz format atom         1.07320000000000        0.04890000000000       -0.07570000000000 C\natom         2.51370000000000        0.01260000000000       -0.07580000000000 N\natom         3.35200000000000        1.09590000000000       -0.07530000000000 C\natom         4.61900000000000        0.73030000000000       -0.07550000000000 N\natom         4.57910000000000       -0.63140000000000       -0.07530000000000 C\natom         3.30130000000000       -1.10260000000000       -0.07520000000000 C\natom         2.98070000000000       -2.48690000000000       -0.07380000000000 C\natom         1.82530000000000       -2.90040000000000       -0.07580000000000 O\natom         4.11440000000000       -3.30430000000000       -0.06940000000000 N\natom         5.45170000000000       -2.85620000000000       -0.07240000000000 C\natom         6.38930000000000       -3.65970000000000       -0.07230000000000 O\natom         5.66240000000000       -1.47680000000000       -0.07490000000000 N\natom         7.00950000000000       -0.93650000000000       -0.07520000000000 C\natom         3.92060000000000       -4.74090000000000       -0.06160000000000 C\natom         0.73400000000000        1.08790000000000       -0.07500000000000 H\natom         0.71240000000000       -0.45700000000000        0.82340000000000 H\natom         0.71240000000000       -0.45580000000000       -0.97550000000000 H\natom         2.99300000000000        2.11760000000000       -0.07480000000000 H\natom         7.76530000000000       -1.72630000000000       -0.07590000000000 H\natom         7.14860000000000       -0.32180000000000        0.81970000000000 H\natom         7.14800000000000       -0.32080000000000       -0.96950000000000 H\natom         2.86500000000000       -5.02320000000000       -0.05830000000000 H\natom         4.40230000000000       -5.15920000000000        0.82840000000000 H\natom         4.40020000000000       -5.16930000000000       -0.94780000000000 H Carbondioxide in FHI-aims format: atom         6.62447969041000        6.62412068645100        6.63464984519600 C\natom         9.39832080661700        6.63600723231600        9.41199064870100 C\natom         9.39627410479100        9.39525191972100        6.64954571641900 C\natom         6.63330355605800        9.40242623362300        9.41005306161900 C\natom         7.30170129847500        7.29939192380800        7.31169116419300 O\natom         5.94599026584500        5.94975031040400        5.95798102153000 O\natom        10.07176052646200        7.31493655623100        8.73491466703200 O\natom         8.72441947117100        5.95679178597600       10.08835581093400 O\natom        10.07139562176400        8.72199135754100        5.96845847998500 O\natom         8.72031652030300       10.06826009498800        7.33005771988500 O\natom         5.95443684368700       10.08070344665100        8.73771924611400 O\natom         7.31154031517700        8.72379750503500       10.08265551999000 O\nlattice_vector         5.68032472285798        0.00000000000000        0.00000000000000\nlattice_vector         0.00000000000000        5.68032472285798        0.00000000000000\nlattice_vector         0.00000000000000        0.00000000000000        5.68032472285798 Missing Features The implementation of this format is (to our knowledge) feature-complete. Note Feel free to contribute support for missing features\n      or bring missing features to our attention by opening an issue.","tags":"","loc":"page/format-aims.html"},{"title":"Chemical JSON – MCTC-library","text":"Specification Note Reference Chemical JSON files are identified by the extension cjson and parsed following the format implemented in Avogadro 2.\nThe entries name , atoms.elements.number , atoms.coords.3d , atoms.coords.3d fractional , unit cell , atoms.formalCharges , bonds.connections.index , and bonds.order are recognized by the reader. Example Caffeine molecule in qcschema_molecule format. { \"chemicalJson\" : 1 , \"atoms\" : { \"elements\" : { \"number\" : [ 6 , 7 , 6 , 7 , 6 , 6 , 6 , 8 , 7 , 6 , 8 , 7 , 6 , 6 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] }, \"coords\" : { \"3d\" : [ 1.0731997649702911E+00 , 4.8899989290949721E-02 , -7.5699983421776973E-02 , 2.5136994495022558E+00 , 1.2599997240612813E-02 , -7.5799983399877077E-02 , 3.3519992659154081E+00 , 1.0958997599990143E+00 , -7.5299983509376570E-02 , 4.6189989884436962E+00 , 7.3029984006504256E-01 , -7.5499983465576764E-02 , 4.5790989971817559E+00 , -6.3139986172404194E-01 , -7.5299983509376570E-02 , 3.3012992770186567E+00 , -1.1025997585317211E+00 , -7.5199983531276451E-02 , 2.9806993472297307E+00 , -2.4868994553714288E+00 , -7.3799983837875047E-02 , 1.8252996002611557E+00 , -2.9003993648153492E+00 , -7.5799983399877077E-02 , 4.1143990989505834E+00 , -3.3042992763616597E+00 , -6.9399984801470568E-02 , 5.4516988060832432E+00 , -2.8561993744951040E+00 , -7.2399984144473614E-02 , 6.3892986007497967E+00 , -3.6596991985294207E+00 , -7.2299984166373524E-02 , 5.6623987599401575E+00 , -1.4767996765823013E+00 , -7.4899983596976152E-02 , 7.0094984649266268E+00 , -9.3649979490745228E-01 , -7.5199983531276451E-02 , 3.9205991413925863E+00 , -4.7408989617477202E+00 , -6.1599986509662634E-02 , 7.3399983925474632E-01 , 1.0878997617510062E+00 , -7.4999983575076257E-02 , 7.1239984398512435E-01 , -4.5699989991746470E-01 , 8.2339981967623732E-01 , 7.1239984398512435E-01 , -4.5579990018026340E-01 , -9.7549978636649193E-01 , 2.9929993445360430E+00 , 2.1175995362477531E+00 , -7.4799983618876062E-02 , 7.7652982994071955E+00 , -1.7262996219420552E+00 , -7.5899983377977168E-02 , 7.1485984344638682E+00 , -3.2179992952612718E-01 , 8.1969982048653345E-01 , 7.1479984345952676E+00 , -3.2079992974512617E-01 , -9.6949978768048573E-01 , 2.8649993725679135E+00 , -5.0231988999243073E+00 , -5.8299987232359275E-02 , 4.4022990359007768E+00 , -5.1591988701404459E+00 , 8.2839981858124223E-01 , 4.4001990363606742E+00 , -5.1692988679285561E+00 , -9.4779979243276369E-01 ] } }, \"bonds\" : { \"connections\" : { \"index\" : [ 0 , 1 , 1 , 2 , 2 , 3 , 3 , 4 , 1 , 5 , 4 , 5 , 5 , 6 , 6 , 7 , 6 , 8 , 8 , 9 , 9 , 10 , 4 , 11 , 9 , 11 , 11 , 12 , 8 , 13 , 0 , 14 , 0 , 15 , 0 , 16 , 2 , 17 , 12 , 18 , 12 , 19 , 12 , 20 , 13 , 21 , 13 , 22 , 13 , 23 ] }, \"order\" : [ 1 , 4 , 4 , 4 , 1 , 4 , 1 , 2 , 1 , 1 , 2 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] } } Missing features The schema is not verified on completeness and not all data is stored in the final structure type. Note Feel free to contribute support for missing features\n      or bring missing features to our attention by opening an issue.","tags":"","loc":"page/format-cjson.html"},{"title":"Connection table format – MCTC-library","text":"Specification Note Reference The molfile is identified by the extension mol and the structure data format\nis identified by sdf .\nBoth V2000 and V3000 connection tables can be read. Example Caffeine molecule in mol format: 11262021073D\n\n 24  0  0     0  0            999 V2000\n    1.0732    0.0488   -0.0757 C   0  0  0  0  0  0  0  0  0  0  0  0\n    2.5137    0.0126   -0.0758 N   0  0  0  0  0  0  0  0  0  0  0  0\n    3.3520    1.0959   -0.0753 C   0  0  0  0  0  0  0  0  0  0  0  0\n    4.6190    0.7303   -0.0755 N   0  0  0  0  0  0  0  0  0  0  0  0\n    4.5791   -0.6314   -0.0753 C   0  0  0  0  0  0  0  0  0  0  0  0\n    3.3013   -1.1026   -0.0752 C   0  0  0  0  0  0  0  0  0  0  0  0\n    2.9807   -2.4869   -0.0738 C   0  0  0  0  0  0  0  0  0  0  0  0\n    1.8253   -2.9004   -0.0758 O   0  0  0  0  0  0  0  0  0  0  0  0\n    4.1144   -3.3043   -0.0694 N   0  0  0  0  0  0  0  0  0  0  0  0\n    5.4517   -2.8562   -0.0723 C   0  0  0  0  0  0  0  0  0  0  0  0\n    6.3893   -3.6597   -0.0723 O   0  0  0  0  0  0  0  0  0  0  0  0\n    5.6624   -1.4768   -0.0749 N   0  0  0  0  0  0  0  0  0  0  0  0\n    7.0095   -0.9365   -0.0752 C   0  0  0  0  0  0  0  0  0  0  0  0\n    3.9206   -4.7409   -0.0616 C   0  0  0  0  0  0  0  0  0  0  0  0\n    0.7340    1.0879   -0.0750 H   0  0  0  0  0  0  0  0  0  0  0  0\n    0.7124   -0.4570    0.8233 H   0  0  0  0  0  0  0  0  0  0  0  0\n    0.7124   -0.4558   -0.9755 H   0  0  0  0  0  0  0  0  0  0  0  0\n    2.9930    2.1176   -0.0748 H   0  0  0  0  0  0  0  0  0  0  0  0\n    7.7653   -1.7263   -0.0759 H   0  0  0  0  0  0  0  0  0  0  0  0\n    7.1486   -0.3218    0.8197 H   0  0  0  0  0  0  0  0  0  0  0  0\n    7.1480   -0.3208   -0.9695 H   0  0  0  0  0  0  0  0  0  0  0  0\n    2.8650   -5.0232   -0.0583 H   0  0  0  0  0  0  0  0  0  0  0  0\n    4.4023   -5.1592    0.8284 H   0  0  0  0  0  0  0  0  0  0  0  0\n    4.4002   -5.1693   -0.9478 H   0  0  0  0  0  0  0  0  0  0  0  0\nM  END Extensions No extension implemented to the original format. Missing Features The following features are currently not supported: Not all modifiers are supported for the connection table SDF key-value pair annotations are dropped continuation lines in V3000 format are not supported Note Feel free to contribute support for missing features\n      or bring missing features to our attention by opening an issue.","tags":"","loc":"page/format-ctfile.html"},{"title":"Gaussian external format – MCTC-library","text":"Specification Note Reference The first line of the input is read as four integers of width 10, (4i10) ,\ncontaining the number of atoms in the first integer.\nA run mode specific integer is given in the second entry.\nThe third integer contains the total charge and the fourth integer the spin as\nnumber of unpaired electrons.\nThe total charge and the systems spin are stored in the structure_type . The structure is specified by atomic numbers, cartesian coordinates in atomic units\n(Bohr) and a scalar quantity, usually partial charges using the fixed format (i10,4f20.12) .\nThe element is identified by its atomic number,\nwhich is converted to its capitalized element symbol internally.\nOnly positive, non-zero integers are allowed as atomic numbers. The expected file extension is ein . Examples Caffeine molecule in Gaussian external format: 24         1         0         0\n         6      2.027996941030      0.092313100971     -0.143108928077      0.000000000000\n         7      4.750109032883      0.023734954927     -0.143241208877      0.000000000000\n         6      6.334341685252      2.070988200950     -0.142353037792      0.000000000000\n         7      8.728605263543      1.380028892063     -0.142655393906      0.000000000000\n         6      8.653186310426     -1.193248402810     -0.142315243278      0.000000000000\n         6      6.238570386230     -2.083535979669     -0.142182962479      0.000000000000\n         6      5.632667631585     -4.699502178348     -0.139405065684      0.000000000000\n         8      3.449316339873     -5.480922657010     -0.143184517105      0.000000000000\n         7      7.775087464402     -6.244277357876     -0.131071375299      0.000000000000\n         6     10.302293246446     -5.397396780594     -0.136721655174      0.000000000000\n         8     12.074100072866     -6.915734697428     -0.136664963403      0.000000000000\n         7     10.700382864677     -2.790784724183     -0.141483763966      0.000000000000\n         6     13.245975677887     -1.769690333624     -0.142182962479      0.000000000000\n         6      7.408915313425     -8.959057313972     -0.116369309269      0.000000000000\n         1      1.387020877193      2.055757011721     -0.141786120079      0.000000000000\n         1      1.346221699097     -0.863566855309      1.555905663964      0.000000000000\n         1      1.346240596354     -0.861336978970     -1.843408533601      0.000000000000\n         1      5.655967949599      4.001720959646     -0.141313688652      0.000000000000\n         1     14.674305959118     -3.262309083535     -0.143449078705      0.000000000000\n         1     13.508968805056     -0.608151528241      1.548989267863      0.000000000000\n         1     13.507797175115     -0.606148418987     -1.832145768365      0.000000000000\n         1      5.414083058620     -9.492394601323     -0.110227700709      0.000000000000\n         1      8.319196188304     -9.749472887017      1.565392087032      0.000000000000\n         1      8.315114380769     -9.768540219438     -1.791082028670      0.000000000000 Extensions No extension implemented to the original format. Missing Features The following features are currently not supported: the requested run-mode is dropped while reading. scalar atomic quantities are not preserved and dropped. Note Feel free to contribute support for missing features\n      or bring missing features to our attention by opening an issue.","tags":"","loc":"page/format-ein.html"},{"title":"DFTB+ general format – MCTC-library","text":"Specification Note Reference The general (gen) format is used for DFTB+ as geometry input format.\nIt is based on the xyz format . The first line contains the number of atoms and the specific kind of provided\ngeometry.\nAvailable types are cluster ( C ), supercell ( S ), fractional ( F ),\nand helical ( H ), the letter defining the format is case-insensitive. The second line gives the element symbols for each group of atoms separated by\nspaces, the groups are indexed starting from 1 and references in the specification\nof the atomic coordinates by this index rather than their element symbol. The following lines are specified as two integers and three reals separated by\nspaces. The first integer is currently ignored. The second integer references\nthe element symbol in the second line.\nThe atomic coordinates are given in Ångström for cluster, supercell and helical,\nwhile they are given as fraction of the lattice vector for fractional input types. For supercell and fractional input the next lines contains three reals containing\nthe origin of the structure, followed by three lines of each three reals for the\nlattice vectors. Lines starting with the # are comments and are ignored while parsing. The format is identified by the extension gen . Example Caffeine molecule in genFormat: 24 C\n C N O H\n    1    1    1.07317000000000E+00    4.88500000000000E-02   -7.57300000000000E-02\n    2    2    2.51365000000000E+00    1.25600000000000E-02   -7.58000000000000E-02\n    3    1    3.35199000000000E+00    1.09592000000000E+00   -7.53300000000000E-02\n    4    2    4.61898000000000E+00    7.30280000000000E-01   -7.54900000000000E-02\n    5    1    4.57907000000000E+00   -6.31440000000000E-01   -7.53100000000000E-02\n    6    1    3.30131000000000E+00   -1.10256000000000E+00   -7.52400000000000E-02\n    7    1    2.98068000000000E+00   -2.48687000000000E+00   -7.37700000000000E-02\n    8    3    1.82530000000000E+00   -2.90038000000000E+00   -7.57700000000000E-02\n    9    2    4.11440000000000E+00   -3.30433000000000E+00   -6.93600000000000E-02\n   10    1    5.45174000000000E+00   -2.85618000000000E+00   -7.23500000000000E-02\n   11    3    6.38934000000000E+00   -3.65965000000000E+00   -7.23200000000000E-02\n   12    2    5.66240000000000E+00   -1.47682000000000E+00   -7.48700000000000E-02\n   13    1    7.00947000000000E+00   -9.36480000000000E-01   -7.52400000000000E-02\n   14    1    3.92063000000000E+00   -4.74093000000000E+00   -6.15800000000000E-02\n   15    4    7.33980000000000E-01    1.08786000000000E+00   -7.50300000000000E-02\n   16    4    7.12390000000000E-01   -4.56980000000000E-01    8.23350000000000E-01\n   17    4    7.12400000000000E-01   -4.55800000000000E-01   -9.75490000000000E-01\n   18    4    2.99301000000000E+00    2.11762000000000E+00   -7.47800000000000E-02\n   19    4    7.76531000000000E+00   -1.72634000000000E+00   -7.59100000000000E-02\n   20    4    7.14864000000000E+00   -3.21820000000000E-01    8.19690000000000E-01\n   21    4    7.14802000000000E+00   -3.20760000000000E-01   -9.69530000000000E-01\n   22    4    2.86501000000000E+00   -5.02316000000000E+00   -5.83300000000000E-02\n   23    4    4.40233000000000E+00   -5.15920000000000E+00    8.28370000000000E-01\n   24    4    4.40017000000000E+00   -5.16929000000000E+00   -9.47800000000000E-01 Ammonia molecular crystal: 16 S\n H N\n    1    1    2.19855889440000E+00    1.76390058240000E+00    8.80145481600000E-01\n    2    1    1.76390058240000E+00    8.80145481600000E-01    2.19855889440000E+00\n    3    1    8.80145481600000E-01    2.19855889440000E+00    1.76390058240000E+00\n    4    1    4.84115108400000E+00    1.61941554720000E+00    4.93981400880000E+00\n    5    1    4.35630903840000E+00    2.49981169680000E+00    3.63248012160000E+00\n    6    1    3.51957925440000E+00    1.15357413600000E+00    4.08403345680000E+00\n    7    1    4.08403345680000E+00    3.51957925440000E+00    1.15357413600000E+00\n    8    1    4.93981400880000E+00    4.84115108400000E+00    1.61941554720000E+00\n    9    1    3.63248012160000E+00    4.35630903840000E+00    2.49981169680000E+00\n   10    1    2.49981169680000E+00    3.63248012160000E+00    4.35630903840000E+00\n   11    1    1.15357413600000E+00    4.08403345680000E+00    3.51957925440000E+00\n   12    1    1.61941554720000E+00    4.93981400880000E+00    4.84115108400000E+00\n   13    2    1.37461317840000E+00    1.37461317840000E+00    1.37461317840000E+00\n   14    2    3.99815460000000E+00    1.99105592400000E+00    4.46364507600000E+00\n   15    2    4.46364507600000E+00    3.99815460000000E+00    1.99105592400000E+00\n   16    2    1.99105592400000E+00    4.46364507600000E+00    3.99815460000000E+00\n    0.00000000000000    0.00000000000000    0.00000000000000\n    5.01336000000000    0.00000000000000    0.00000000000000\n    0.00000000000000    5.01336000000000    0.00000000000000\n    0.00000000000000    0.00000000000000    5.01336000000000 Extensions No extension implemented to the original format. Missing Features The implementation of this format is (to our knowledge) feature-complete. Note Feel free to contribute support for missing features\n      or bring missing features to our attention by opening an issue.","tags":"","loc":"page/format-gen.html"},{"title":"Protein data bank (PDB) format – MCTC-library","text":"Specification Note Reference The extension identifying this format is pdb . Example 4QXX protein with explicit hydrogen: HEADER    PROTEIN FIBRIL                          22-JUL-14   4QXX              \nTITLE     STRUCTURE OF THE AMYLOID FORMING PEPTIDE GNLVS (RESIDUES 26-30) FROM  \nTITLE    2 THE EOSINOPHIL MAJOR BASIC PROTEIN (EMBP)                            \nDBREF  4QXX Z    1     5  UNP    P13727   PRG2_HUMAN     131    135             \nSEQRES   1 Z    5  GLY ASN LEU VAL SER                                          \nFORMUL   2  HOH   *2(H2 O)                                                      \nCRYST1    4.755   16.816   35.759  90.00  90.00  90.00 P 2 21 21     4          \nORIGX1      1.000000  0.000000  0.000000        0.00000                         \nORIGX2      0.000000  1.000000  0.000000        0.00000                         \nORIGX3      0.000000  0.000000  1.000000        0.00000                         \nSCALE1      0.210305  0.000000  0.000000        0.00000                         \nSCALE2      0.000000  0.059467  0.000000        0.00000                         \nSCALE3      0.000000  0.000000  0.027965        0.00000                         \nATOM      1  N   GLY Z   1      -0.821  -2.072  16.609  1.00  9.93           N\nANISOU    1  N   GLY Z   1     1184   1952    638    314   -191   -326       N\nATOM      2  CA  GLY Z   1      -1.705  -2.345  15.487  1.00  7.38           C\nANISOU    2  CA  GLY Z   1      957   1374    472    279   -124   -261       C\nATOM      3  C   GLY Z   1      -0.968  -3.008  14.344  1.00  4.89           C\nANISOU    3  C   GLY Z   1      899    614    343    211    112   -106       C\nATOM      4  O   GLY Z   1       0.258  -2.982  14.292  1.00  5.05           O\nANISOU    4  O   GLY Z   1      839    595    485    -11     -7   -180       O\nATOM      5  HA2 GLY Z   1      -2.130  -1.405  15.135  1.00  0.00           H\nATOM      6  HA3 GLY Z   1      -2.511  -2.999  15.819  1.00  0.00           H\nATOM      7  H1  GLY Z   1      -1.364  -1.742  17.394  1.00  0.00           H\nATOM      8  H2  GLY Z   1      -0.150  -1.365  16.344  1.00  0.00           H\nATOM      9  H3  GLY Z   1      -0.334  -2.918  16.868  1.00  0.00           H\nATOM     10  N   ASN Z   2      -1.721  -3.603  13.425  1.00  3.53           N\nANISOU   10  N   ASN Z   2      747    329    264   -226    117    -67       N\nATOM     11  CA  ASN Z   2      -1.141  -4.323  12.291  1.00  1.85           C\nANISOU   11  CA  ASN Z   2      313    164    225     76    -23     77       C\nATOM     12  C   ASN Z   2      -1.748  -3.900  10.968  1.00  3.00           C\nANISOU   12  C   ASN Z   2      610    293    238    197     -2    -42       C\nATOM     13  O   ASN Z   2      -2.955  -3.683  10.873  1.00  3.99           O\nANISOU   13  O   ASN Z   2      599    514    402    199    191    -60       O\nATOM     14  CB  ASN Z   2      -1.353  -5.827  12.446  1.00  5.03           C\nANISOU   14  CB  ASN Z   2     1173    368    369    170    -47     37       C\nATOM     15  CG  ASN Z   2      -0.679  -6.391  13.683  1.00  5.08           C\nANISOU   15  CG  ASN Z   2      727    718    484    228   -243     90       C\nATOM     16  OD1 ASN Z   2       0.519  -6.202  13.896  1.00  6.10           O\nANISOU   16  OD1 ASN Z   2      828    960    531    477    -61    100       O\nATOM     17  ND2 ASN Z   2      -1.448  -7.087  14.506  1.00  8.41           N\nANISOU   17  ND2 ASN Z   2     1513   1193    488     40    102    279       N\nATOM     18  H   ASN Z   2      -2.726  -3.557  13.512  1.00  0.00           H\nATOM     19  HA  ASN Z   2      -0.070  -4.123  12.263  1.00  0.00           H\nATOM     20  HB2 ASN Z   2      -0.945  -6.328  11.568  1.00  0.00           H\nATOM     21  HB3 ASN Z   2      -2.423  -6.029  12.503  1.00  0.00           H\nATOM     22 HD21 ASN Z   2      -2.427  -7.218  14.293  1.00  0.00           H\nATOM     23 HD22 ASN Z   2      -1.056  -7.487  15.346  1.00  0.00           H\nATOM     24  N   LEU Z   3      -0.907  -3.803   9.944  1.00  3.47           N\nANISOU   24  N   LEU Z   3      701    405    213   -242     25    -26       N\nATOM     25  CA  LEU Z   3      -1.388  -3.576   8.586  1.00  3.48           C\nANISOU   25  CA  LEU Z   3      728    324    271     79    180     -5       C\nATOM     26  C   LEU Z   3      -0.783  -4.660   7.709  1.00  3.29           C\nANISOU   26  C   LEU Z   3      684    261    306    -17    150    -80       C\nATOM     27  O   LEU Z   3       0.437  -4.788   7.643  1.00  3.80           O\nANISOU   27  O   LEU Z   3      590    437    415    141    178   -122       O\nATOM     28  CB  LEU Z   3      -0.977  -2.185   8.081  1.00  3.88           C\nANISOU   28  CB  LEU Z   3      899    293    282    171    125     42       C\nATOM     29  CG  LEU Z   3      -1.524  -1.669   6.736  1.00  8.66           C\nANISOU   29  CG  LEU Z   3     2091    598    600     63    -94     66       C\nATOM     30  CD1 LEU Z   3      -1.225  -0.191   6.570  1.00  9.89           C\nANISOU   30  CD1 LEU Z   3     2263    792    703    132   -163    143       C\nATOM     31  CD2 LEU Z   3      -0.962  -2.409   5.541  1.00 13.56           C\nANISOU   31  CD2 LEU Z   3     3203   1048    901   -640   -305     94       C\nATOM     32  H   LEU Z   3       0.086  -3.888  10.109  1.00  0.00           H\nATOM     33  HA  LEU Z   3      -2.475  -3.661   8.568  1.00  0.00           H\nATOM     34  HB2 LEU Z   3      -1.284  -1.469   8.843  1.00  0.00           H\nATOM     35  HB3 LEU Z   3       0.111  -2.162   8.026  1.00  0.00           H\nATOM     36  HG  LEU Z   3      -2.606  -1.798   6.737  1.00  0.00           H\nATOM     37 HD11 LEU Z   3      -1.623   0.359   7.423  1.00  0.00           H\nATOM     38 HD12 LEU Z   3      -1.691   0.173   5.654  1.00  0.00           H\nATOM     39 HD13 LEU Z   3      -0.147  -0.043   6.513  1.00  0.00           H\nATOM     40 HD21 LEU Z   3      -1.168  -3.475   5.643  1.00  0.00           H\nATOM     41 HD22 LEU Z   3      -1.429  -2.035   4.630  1.00  0.00           H\nATOM     42 HD23 LEU Z   3       0.115  -2.250   5.489  1.00  0.00           H\nATOM     43  N   VAL Z   4      -1.635  -5.424   7.029  1.00  3.17           N\nANISOU   43  N   VAL Z   4      604    266    333   -100    104   -123       N\nATOM     44  CA  VAL Z   4      -1.165  -6.460   6.119  1.00  3.61           C\nANISOU   44  CA  VAL Z   4      607    353    411    205   -241   -157       C\nATOM     45  C   VAL Z   4      -1.791  -6.230   4.755  1.00  5.31           C\nANISOU   45  C   VAL Z   4      543    915    562    395    -15    -39       C\nATOM     46  O   VAL Z   4      -3.014  -6.209   4.620  1.00  7.31           O\nANISOU   46  O   VAL Z   4      577   1569    630     45     -5   -227       O\nATOM     47  CB  VAL Z   4      -1.567  -7.872   6.593  1.00  5.31           C\nANISOU   47  CB  VAL Z   4     1024    336    657     64     39   -167       C\nATOM     48  CG1 VAL Z   4      -1.012  -8.934   5.633  1.00  6.73           C\nANISOU   48  CG1 VAL Z   4     1131    549    879    220    104   -300       C\nATOM     49  CG2 VAL Z   4      -1.083  -8.120   8.018  1.00  5.48           C\nANISOU   49  CG2 VAL Z   4      819    632    630     15     15     42       C\nATOM     50  H   VAL Z   4      -2.628  -5.282   7.146  1.00  0.00           H\nATOM     51  HA  VAL Z   4      -0.080  -6.402   6.034  1.00  0.00           H\nATOM     52  HB  VAL Z   4      -2.655  -7.939   6.585  1.00  0.00           H\nATOM     53 HG11 VAL Z   4      -1.303  -9.926   5.980  1.00  0.00           H\nATOM     54 HG12 VAL Z   4      -1.414  -8.766   4.634  1.00  0.00           H\nATOM     55 HG13 VAL Z   4       0.075  -8.864   5.603  1.00  0.00           H\nATOM     56 HG21 VAL Z   4      -1.377  -9.121   8.333  1.00  0.00           H\nATOM     57 HG22 VAL Z   4       0.003  -8.032   8.053  1.00  0.00           H\nATOM     58 HG23 VAL Z   4      -1.529  -7.383   8.686  1.00  0.00           H\nATOM     59  N   SER Z   5      -0.966  -6.052   3.736  1.00  7.53           N\nANISOU   59  N   SER Z   5      810   1357    693    337     48    302       N\nATOM     60  CA  SER Z   5      -1.526  -5.888   2.407  1.00 11.48           C\nANISOU   60  CA  SER Z   5     1654   1766    943    560   -145    241       C\nATOM     61  C   SER Z   5      -1.207  -7.085   1.529  1.00 16.35           C\nANISOU   61  C   SER Z   5     3066   2118   1029    758   -523   -208       C\nATOM     62  O   SER Z   5      -0.437  -7.976   1.902  1.00 14.00           O\nANISOU   62  O   SER Z   5     2584   1676   1060    878   -402   -452       O\nATOM     63  CB  SER Z   5      -1.031  -4.596   1.767  1.00 13.36           C\nANISOU   63  CB  SER Z   5     1565   2151   1361    818    -30    608       C\nATOM     64  OG  SER Z   5       0.361  -4.652   1.540  1.00 15.80           O\nANISOU   64  OG  SER Z   5     1604   2812   1587    822     25    763       O\nATOM     65  OXT SER Z   5      -1.737  -7.178   0.429  1.00 17.09           O\nANISOU   65  OXT SER Z   5     2807   2495   1192    648   -712   -430       O\nATOM     66  H   SER Z   5       0.033  -6.031   3.880  1.00  0.00           H\nATOM     67  HA  SER Z   5      -2.610  -5.822   2.504  1.00  0.00           H\nATOM     68  HB2 SER Z   5      -1.543  -4.449   0.816  1.00  0.00           H\nATOM     69  HB3 SER Z   5      -1.254  -3.759   2.428  1.00  0.00           H\nATOM     70  HG  SER Z   5       0.653  -3.831   1.137  1.00  0.00           H\nTER      71      SER Z   5\nHETATM   72  O   HOH Z 101       0.935  -5.175  16.502  1.00 18.83           O\nANISOU   72  O   HOH Z 101     3066   2772   1315  -1227   -232    339       O\nHETATM   73  H1  HOH Z 101       0.794  -5.522  15.621  1.00  0.00           H\nHETATM   74  H2  HOH Z 101       1.669  -4.561  16.489  1.00  0.00           H\nHETATM   75  O  AHOH Z 102       0.691  -8.408  17.879  0.91 56.55           O\nANISOU   75  O  AHOH Z 102     9673   9234   2579      0      5   1219       O\nHETATM   76  O  BHOH Z 102      -0.788  -9.006  16.641  0.09 38.95           O\nANISOU   76  O  BHOH Z 102     6801   4266   3734   2095  -1531    549       O\nHETATM   77  H1 AHOH Z 102       1.392  -8.125  18.466  0.91  0.00           H\nHETATM   78  H1 BHOH Z 102      -1.351  -9.776  16.563  0.09  0.00           H\nHETATM   79  H2 AHOH Z 102       0.993  -8.356  16.972  0.91  0.00           H\nHETATM   80  H2 BHOH Z 102      -0.927  -8.594  17.494  0.09  0.00           H\nCONECT   73   72\nCONECT   74   72\nCONECT   72   73   74\nCONECT   78   76\nCONECT   77   75\nCONECT   80   76\nCONECT   79   75\nCONECT   75   77   79\nCONECT   76   78   80\nEND Extensions No extension implemented to the original format. Missing Features The following features are currently not supported: Support for multiple file PDB input is not available Fractional side occupation is currently not supported\n  all optional sides count as full atoms Cell information is not preserved, PDB input is always handled molecular Note Feel free to contribute support for missing features\n      or bring missing features to our attention by opening an issue.","tags":"","loc":"page/format-pdb.html"},{"title":"Q-Chem molecule format – MCTC-library","text":"Specification Note Reference can be found in the Q-Chem manual . Format used by the Q-Chem program.\nElements can be specified either by atomic numbers or element symbols while the geometry is provided in Ångström by default. Example Caffeine molecule in xyz format $ molecule 0 1 C 1 . 07320000000000 0 . 04890000000000 - 0 . 07570000000000 N 2 . 51370000000000 0 . 01260000000000 - 0 . 07580000000000 C 3 . 35200000000000 1 . 09590000000000 - 0 . 07530000000000 N 4 . 61900000000000 0 . 73030000000000 - 0 . 07550000000000 C 4 . 57910000000000 - 0 . 63140000000000 - 0 . 07530000000000 C 3 . 30130000000000 - 1 . 10260000000000 - 0 . 07520000000000 C 2 . 98070000000000 - 2 . 48690000000000 - 0 . 07380000000000 O 1 . 82530000000000 - 2 . 90040000000000 - 0 . 07580000000000 N 4 . 11440000000000 - 3 . 30430000000000 - 0 . 06940000000000 C 5 . 45170000000000 - 2 . 85620000000000 - 0 . 07240000000000 O 6 . 38930000000000 - 3 . 65970000000000 - 0 . 07230000000000 N 5 . 66240000000000 - 1 . 47680000000000 - 0 . 07490000000000 C 7 . 00950000000000 - 0 . 93650000000000 - 0 . 07520000000000 C 3 . 92060000000000 - 4 . 74090000000000 - 0 . 06160000000000 H 0 . 73400000000000 1 . 08790000000000 - 0 . 07500000000000 H 0 . 71240000000000 - 0 . 45700000000000 0 . 82340000000000 H 0 . 71240000000000 - 0 . 45580000000000 - 0 . 97550000000000 H 2 . 99300000000000 2 . 11760000000000 - 0 . 07480000000000 H 7 . 76530000000000 - 1 . 72630000000000 - 0 . 07590000000000 H 7 . 14860000000000 - 0 . 32180000000000 0 . 81970000000000 H 7 . 14800000000000 - 0 . 32080000000000 - 0 . 96950000000000 H 2 . 86500000000000 - 5 . 02320000000000 - 0 . 05830000000000 H 4 . 40230000000000 - 5 . 15920000000000 0 . 82840000000000 H 4 . 40020000000000 - 5 . 16930000000000 - 0 . 94780000000000 $e nd Missing Features Following features are missing reading of z-matrix input possibility to change coordinate units to Bohr Note Feel free to contribute support for missing features\n      or bring missing features to our attention by opening an issue.","tags":"","loc":"page/format-qchem.html"},{"title":"QCSchema JSON – MCTC-library","text":"Specification Note Reference JSON files are identified by the extension json and parsed following the qcschema_molecule or qcschema_input format.\nThe molecule entry from a qcschema_input will be extracted, but there is no guarantee that the input information will be used by the program. Example Caffeine molecule in qcschema_molecule format. { \"schema_version\" : 2 , \"schema_name\" : \"qcschema_molecule\" , \"provenance\" : { \"creator\" : \"mctc-lib\" , \"version\" : \"0.2.3\" , \"routine\" : \"mctc_io_write_qcschema::write_qcschema\" }, \"symbols\" : [ \"C\" , \"N\" , \"C\" , \"N\" , \"C\" , \"C\" , \"C\" , \"O\" , \"N\" , \"C\" , \"O\" , \"N\" , \"C\" , \"C\" , \"H\" , \"H\" , \"H\" , \"H\" , \"H\" , \"H\" , \"H\" , \"H\" , \"H\" , \"H\" ], \"geometry\" : [ 2.0280536328008760E+00 , 9.2407587256767454E-02 , -1.4305223630546618E-01 , 4.7502035191684326E+00 , 2.3810543955731494E-02 , -1.4324120887654343E-01 , 6.3343605825088858E+00 , 2.0709504064354083E+00 , -1.4229634602115726E-01 , 8.7286430580574415E+00 , 1.3800666865770403E+00 , -1.4267429116331171E-01 , 8.6532430021976250E+00 , -1.1931728137816557E+00 , -1.4229634602115726E-01 , 6.2385514889727283E+00 , -2.0836115686975827E+00 , -1.4210737345008001E-01 , 5.6327054260991156E+00 , -4.6995588701197342E+00 , -1.3946175745499875E-01 , 3.4493163398727531E+00 , -5.4809604515240968E+00 , -1.4324120887654343E-01 , 7.7750874644017181E+00 , -6.2442206661050452E+00 , -1.3114696432760045E-01 , 1.0302217657417570E+01 , -5.3974345751079591E+00 , -1.3681614145991747E-01 , 1.2074024483837716E+01 , -6.9158291837135346E+00 , -1.3662716888884024E-01 , 1.0700382864677302E+01 , -2.7907469296685923E+00 , -1.4154045573684831E-01 , 1.3246032369658721E+01 , -1.7697281281382971E+00 , -1.4210737345008001E-01 , 7.4088586216540389E+00 , -8.9590006222005893E+00 , -1.1640710378357619E-01 , 1.3870586717068980E+00 , 2.0558326007492296E+00 , -1.4172942830792554E-01 , 1.3462405963542154E+00 , -8.6360464982295970E-01 , 1.5560001502499454E+00 , 1.3462405963542154E+00 , -8.6133697897003281E-01 , -1.8434274308584184E+00 , 5.6559490523416152E+00 , 4.0016831651315083E+00 , -1.4135148316577109E-01 , 1.4674287061860456E+01 , -3.2622334945062916E+00 , -1.4343018144762065E-01 , 1.3508893216027154E+01 , -6.0811373372653921E-01 , 1.5490081651200875E+00 , 1.3507759380600691E+01 , -6.0622400801576681E-01 , -1.8320890765937843E+00 , 5.4140641613627567E+00 , -9.4924701903516215E+00 , -1.1017100893802745E-01 , 8.3191394965330758E+00 , -9.7494728870166600E+00 , 1.5654487788038070E+00 , 8.3151710725404531E+00 , -9.7685591166954602E+00 , -1.7910820286700244E+00 ], \"molecular_charge\" : 0 , \"connectivity\" : [ [ 0 , 1 , 1 ], [ 1 , 2 , 4 ], [ 2 , 3 , 4 ], [ 3 , 4 , 4 ], [ 1 , 5 , 1 ], [ 4 , 5 , 4 ], [ 5 , 6 , 1 ], [ 6 , 7 , 2 ], [ 6 , 8 , 1 ], [ 8 , 9 , 1 ], [ 9 , 10 , 2 ], [ 4 , 11 , 1 ], [ 9 , 11 , 1 ], [ 11 , 12 , 1 ], [ 8 , 13 , 1 ], [ 0 , 14 , 1 ], [ 0 , 15 , 1 ], [ 0 , 16 , 1 ], [ 2 , 17 , 1 ], [ 12 , 18 , 1 ], [ 12 , 19 , 1 ], [ 12 , 20 , 1 ], [ 13 , 21 , 1 ], [ 13 , 22 , 1 ], [ 13 , 23 , 1 ] ] } Missing features The schema is not verified on completeness and not all data is stored in the final structure type. Note Feel free to contribute support for missing features\n      or bring missing features to our attention by opening an issue.","tags":"","loc":"page/format-qcschema.html"},{"title":"Turbomole's coordinate data group – MCTC-library","text":"Specification Note Reference The Turbomole format mainly builds around the control file.\nThe control file contains several data groups which are delimited by\ntheir identifier, groups are either present in the control file or\nreferences from the control file.\nThis format is defined by the geometry related information from the control file, mainly the: coord data group lattice data group cell data group periodic data group eht data group For simplicity file references are not allowed and all data groups should be\nin the same file. The data groups are not required to be in any particular order. A group is started by a $ symbol and accept modifiers. It is terminated by\nanother group or the end group which stops the scanning for further groups: $group1 [modifier]...\n[entries]...\n$group2 [modifier]...\n[entries]...\n$end The coord data group contains the cartesian coordinates of all atoms and\ntheir element symbols at the end of each line.\nAtomic coordinates can either be specified in Bohr, by default or with the bohr modifier on the coord data group, in Ångström with the modifier angs or\nas fractions of the lattice vectors with the modifier frac .\nFractional coordinates can only be present for periodicities greater than zero. The periodicity of the system is specified as modifier to the periodic data\ngroup, the group itself is empty. The lattice parameters can either be specified in the lattice or the cell data group, which require different amounts of entries depending on the systems\nperiodicity. Both data groups are either given in atomic units (Bohr) or in\nÅngström with the angs modifier. For 3D periodic systems three lines with each three reals are required in the lattice data group. For a 2D periodic system two lines with each two reals\nare required and the aperiodic direction is the z-axis.\nFinally, for 1D periodic systems one real is required, giving the translation\nvector in the x-direction.\nThe periodic directions are fixed in this format. Similarly, the cell data groups allows for six, three, and one entries for\n3D, 2D, and 1D periodic systems, respectively. The cell parameters are given\nas the length of the lattice vectors and their angles, with the angles given\nin degrees. Charge and spin can be given in the eht data group with $eht charge=<int> unpaired=<int> The format is identified by coord or tmol extension or by using coord as basename. Example Caffeine molecule in Turbomole’s coord format $coord\n    2.02799694102955E+00    9.23131009712288E-02   -1.43108928076789E-01      C\n    4.75010903288289E+00    2.37349549273006E-02   -1.43241208876543E-01      N\n    6.33434168525178E+00    2.07098820094962E+00   -1.42353037792480E-01      C\n    8.72860526354322E+00    1.38002889206282E+00   -1.42655393906204E-01      N\n    8.65318631042630E+00   -1.19324840281009E+00   -1.42315243278265E-01      C\n    6.23857038622984E+00   -2.08353597966915E+00   -1.42182962478511E-01      C\n    5.63266763158490E+00   -4.69950217834841E+00   -1.39405065683676E-01      C\n    3.44931633987275E+00   -5.48092265700988E+00   -1.43184517105220E-01      O\n    7.77508746440172E+00   -6.24427735787637E+00   -1.31071375299170E-01      N\n    1.03022932464460E+01   -5.39739678059374E+00   -1.36721655174379E-01      C\n    1.20741000728661E+01   -6.91573469742800E+00   -1.36664963403056E-01      O\n    1.07003828646773E+01   -2.79078472418281E+00   -1.41483763965525E-01      N\n    1.32459756778874E+01   -1.76969033362408E+00   -1.42182962478511E-01      C\n    7.40891531342536E+00   -8.95905731397191E+00   -1.16369309269361E-01      C\n    1.38702087719268E+00    2.05575701172080E+00   -1.41786120079249E-01      H\n    1.34622169909711E+00   -8.63566855308744E-01    1.55590566396441E+00      H\n    1.34624059635422E+00   -8.61336978970033E-01   -1.84340853360131E+00      H\n    5.65596794959872E+00    4.00172095964572E+00   -1.41313688651556E-01      H\n    1.46743059591176E+01   -3.26230908353472E+00   -1.43449078704728E-01      H\n    1.35089688050556E+01   -6.08151528240755E-01    1.54898926786298E+00      H\n    1.35077971751149E+01   -6.06148418987336E-01   -1.83214576836511E+00      H\n    5.41408305861986E+00   -9.49239460132319E+00   -1.10227700709351E-01      H\n    8.31919618830440E+00   -9.74947288701666E+00    1.56539208703248E+00      H\n    8.31511438076913E+00   -9.76854021943835E+00   -1.79108202867002E+00      H\n$end Ammonia molecular crystal: $coord\n    4.15467326939489E+00    3.33328828180759E+00    1.66323354579962E+00      H\n    3.33328828180759E+00    1.66323354579962E+00    4.15467326939489E+00      H\n    1.66323354579962E+00    4.15467326939489E+00    3.33328828180759E+00      H\n    9.14844767316819E+00    3.06025119596830E+00    9.33489353886275E+00      H\n    8.23222919393441E+00    4.72395843553239E+00    6.86439107965696E+00      H\n    6.65103940814062E+00    2.17993870408119E+00    7.71770302696940E+00      H\n    7.71770302696940E+00    6.65103940814062E+00    2.17993870408119E+00      H\n    9.33489353886275E+00    9.14844767316819E+00    3.06025119596830E+00      H\n    6.86439107965696E+00    8.23222919393441E+00    4.72395843553239E+00      H\n    4.72395843553239E+00    6.86439107965696E+00    8.23222919393441E+00      H\n    2.17993870408119E+00    7.71770302696940E+00    6.65103940814062E+00      H\n    3.06025119596830E+00    9.33489353886275E+00    9.14844767316819E+00      H\n    2.59764186558897E+00    2.59764186558897E+00    2.59764186558897E+00      N\n    7.55541554326270E+00    3.76254957116838E+00    8.43506486387956E+00      N\n    8.43506486387956E+00    7.55541554326270E+00    3.76254957116838E+00      N\n    3.76254957116838E+00    8.43506486387956E+00    7.55541554326270E+00      N\n$periodic 3\n$lattice\n    9.47387528935762    0.00000000000000    0.00000000000000\n    0.00000000000000    9.47387528935762    0.00000000000000\n    0.00000000000000    0.00000000000000    9.47387528935762\n$end Extensions The original format does only allow for the periodic or eht group to\nappear in the control file, to make the format self-contained, all groups\nmust appear in the same file. The coord group only supports the frac modifier in Turbomole, but this\nreader also allows angs and bohr . Missing Features The following features are currently not supported: Preserving information about frozen atoms from coord data group Note Feel free to contribute support for missing features\n      or bring missing features to our attention by opening an issue.","tags":"","loc":"page/format-tmol.html"},{"title":"Vasp's POSCAR format – MCTC-library","text":"Note Reference The format is identified by the extension vasp , poscar or contcar .\nAlternatively, the basenames poscar and contcar identify the format as well. Examples Ammonia molecular crystal in pre Vasp 5 POSCAR format: H  N \n 1.0000000000000000\n     5.0133599999999996    0.0000000000000000    0.0000000000000000\n     0.0000000000000000    5.0133599999999996    0.0000000000000000\n     0.0000000000000000    0.0000000000000000    5.0133599999999996\n  12   4\nCartesian\n  2.1985588943999996  1.7639005823999998  0.8801454815999999\n  1.7639005823999998  0.8801454815999999  2.1985588943999996\n  0.8801454815999999  2.1985588943999996  1.7639005823999998\n  4.8411510839999998  1.6194155471999998  4.9398140088000000\n  4.3563090384000001  2.4998116967999997  3.6324801215999996\n  3.5195792543999995  1.1535741359999998  4.0840334567999994\n  4.0840334567999994  3.5195792543999995  1.1535741359999998\n  4.9398140088000000  4.8411510839999998  1.6194155471999998\n  3.6324801215999996  4.3563090384000001  2.4998116967999997\n  2.4998116967999997  3.6324801215999996  4.3563090384000001\n  1.1535741359999998  4.0840334567999994  3.5195792543999995\n  1.6194155471999998  4.9398140088000000  4.8411510839999998\n  1.3746131783999997  1.3746131783999997  1.3746131783999997\n  3.9981545999999994  1.9910559239999999  4.4636450759999997\n  4.4636450759999997  3.9981545999999994  1.9910559239999999\n  1.9910559239999999  4.4636450759999997  3.9981545999999994 Carbondioxide in POSCAR format: 4CO2\n    1.00000000000000\n    5.68032000000000    0.00000000000000    0.00000000000000\n    0.00000000000000    5.68032000000000    0.00000000000000\n    0.00000000000000    0.00000000000000    5.68032000000000\n C    O   \n 4 8\nCartesian\n    0.94412598720000    0.94378516800000    0.95435056320000\n    3.71799665280000    0.95565703680000    3.73168622400000\n    3.71595173760000    3.71492928000000    0.96923300160000\n    0.95298728640000    3.72208648320000    3.72969811200000\n    1.62139054080000    1.61906160960000    1.63138790400000\n    0.26566856640000    0.26941757760000    0.27765404160000\n    4.39145539200000    1.63462568640000    3.05459208000000\n    3.04408348800000    0.27646117440000    4.40804192640000\n    4.39105776960000    3.04164095040000    0.28810583040000\n    3.03999365760000    4.38793359360000    1.64973533760000\n    0.27413224320000    4.40037349440000    3.05737543680000\n    1.63121749440000    3.04345865280000    4.40230480320000 Extensions No extension implemented to the original format. Missing Features The implementation of this format is (to our knowledge) feature-complete. Note Feel free to bring missing features to our attention by opening an issue.","tags":"","loc":"page/format-vasp.html"},{"title":"xyz format – MCTC-library","text":"Specification Note Reference Simple format to store cartesian coordinates and element symbols.\nThe first line contains the number of atoms in the geometry.\nThe second line is a comment line and ignored, some program store additional\ninformation here.\nThe following lines contain a short character identifier and three reals.\nThe first entry is interpreted as element symbol and defines the atomic species.\nThe atomic coordinates are given in Ångström. A scalar quantity can be added to each atom with one real as well as a vector\nquantity by three reals, allowing additional four reals per atomic entry. The format is identified by the file extension xyz or log . Examples Caffeine molecule in xyz format 24\n\nC            1.07317000000000        0.04885000000000       -0.07573000000000\nN            2.51365000000000        0.01256000000000       -0.07580000000000\nC            3.35199000000000        1.09592000000000       -0.07533000000000\nN            4.61898000000000        0.73028000000000       -0.07549000000000\nC            4.57907000000000       -0.63144000000000       -0.07531000000000\nC            3.30131000000000       -1.10256000000000       -0.07524000000000\nC            2.98068000000000       -2.48687000000000       -0.07377000000000\nO            1.82530000000000       -2.90038000000000       -0.07577000000000\nN            4.11440000000000       -3.30433000000000       -0.06936000000000\nC            5.45174000000000       -2.85618000000000       -0.07235000000000\nO            6.38934000000000       -3.65965000000000       -0.07232000000000\nN            5.66240000000000       -1.47682000000000       -0.07487000000000\nC            7.00947000000000       -0.93648000000000       -0.07524000000000\nC            3.92063000000000       -4.74093000000000       -0.06158000000000\nH            0.73398000000000        1.08786000000000       -0.07503000000000\nH            0.71239000000000       -0.45698000000000        0.82335000000000\nH            0.71240000000000       -0.45580000000000       -0.97549000000000\nH            2.99301000000000        2.11762000000000       -0.07478000000000\nH            7.76531000000000       -1.72634000000000       -0.07591000000000\nH            7.14864000000000       -0.32182000000000        0.81969000000000\nH            7.14802000000000       -0.32076000000000       -0.96953000000000\nH            2.86501000000000       -5.02316000000000       -0.05833000000000\nH            4.40233000000000       -5.15920000000000        0.82837000000000\nH            4.40017000000000       -5.16929000000000       -0.94780000000000 Extensions The reader supports the following extensions: Atomic numbers are allowed instead of element symbols.\n  They are automatically converted to capitalized element symbols Missing Features The following features are currently not supported: Scalar atomic quantities are not preserved and dropped. Vector atomic quantities are not preserved and dropped. Note Feel free to contribute support for missing features\n      or bring missing features to our attention by opening an issue.","tags":"","loc":"page/format-xyz.html"}]}